{
  "slug" : "9594-concurrency-threads-parallelism",
  "meta" : {
    "slug" : "9594-concurrency-threads-parallelism",
    "title" : "kae3g 9593: Concurrency - Threads and Parallelism",
    "filename" : "9594-concurrency-threads-parallelism.md",
    "source-dir" : "hidden"
  },
  "html" : "<h1>kae3g 9593: Concurrency - Threads and Parallelism</h1><p><strong>Phase 1: Foundations & Philosophy</strong> | <strong>Week 4</strong> | <strong>Reading Time: 18 minutes</strong><h2></h2></p><h2>What You'll Learn</h2><ul><li>Concurrency vs parallelism (similar but different!)</li><li>Threads vs processes (lightweight vs heavyweight)</li><li>Race conditions and why they're dangerous</li><li>Synchronization primitives (locks, mutexes, semaphores)</li><li>Deadlock and how to avoid it</li><li>Clojure's concurrency model (atoms, refs, agents)</li><li>Why immutability makes concurrency easier</li><li>The garden metaphor: Multiple gardeners, shared tools<h2></h2></li></ul><h2>Prerequisites</h2><ul><li><strong><a href='/12025-10/9570-processes-programs-in-motion'>9570: Processes</a></strong> - Process basics</li><li><strong><a href='/12025-10/9580-memory-management'>9580: Memory Management</a></strong> - How memory works</li><li><strong><a href='/12025-10/9504-what-is-clojure'>9504: What Is Clojure?</a></strong> - Immutability, functional programming</li><li><strong><a href='/12025-10/9507-helen-atthowe-ecological-systems'>9507: Helen Atthowe</a></strong> - Coordination in living systems<h2></h2></li></ul><h2>Concurrency vs Parallelism</h2><p><strong>Often confused, but different</strong>:</p><h3>Concurrency</h3><p><strong>Definition</strong>: Dealing with multiple things <strong>at once</strong> (interleaved).</p><p><strong>Example</strong>: One CPU, multiple processes:</p><pre><code>Time:   0ms    10ms   20ms   30ms   40ms\nCPU:    Task A Task B Task A Task C Task B\n# Switching rapidly &#40;looks simultaneous&#41;\n</code></pre><p><strong>Like</strong>: One gardener tending multiple plots (switches between them).</p><h3>Parallelism</h3><p><strong>Definition</strong>: Doing multiple things <strong>simultaneously</strong> (truly at same time).</p><p><strong>Example</strong>: Multiple CPUs, multiple processes:</p><pre><code>Time:   0ms    10ms   20ms   30ms   40ms\nCPU 1:  Task A Task A Task A Task A Task A\nCPU 2:  Task B Task B Task B Task B Task B\nCPU 3:  Task C Task C Task C Task C Task C\n# Actually simultaneous\n</code></pre><p><strong>Like</strong>: Multiple gardeners, each on their own plot.</p><p><strong>Key difference</strong>: </p><ul><li><strong>Concurrency</strong> = managing multiple tasks (might be on one CPU)</li><li><strong>Parallelism</strong> = actually executing simultaneously (requires multiple CPUs)</li></ul><p><strong>Rob Pike</strong> (Go creator): \"Concurrency is about <strong>dealing with</strong> lots of things at once. Parallelism is about <strong>doing</strong> lots of things at once.\"<h2></h2></p><h2>Threads vs Processes</h2><p><strong>Both</strong> allow concurrency, but different trade-offs:</p><h3>Processes (Essay 9570)</h3><pre><code>Process A:  &#91;Memory&#93; &#91;CPU&#93; &#91;Files&#93;\nProcess B:  &#91;Memory&#93; &#91;CPU&#93; &#91;Files&#93;\n# Isolated &#40;separate memory spaces&#41;\n</code></pre><p><strong>Pros</strong>:</p><ul><li><strong>Isolation</strong> (one crash doesn't kill others)</li><li><strong>Security</strong> (can't access each other's memory)</li></ul><p><strong>Cons</strong>:</p><ul><li><strong>Heavyweight</strong> (creating process = expensive)</li><li><strong>Communication</strong> requires IPC (inter-process communication - complex)</li></ul><h3>Threads</h3><pre><code>Process:\n  Thread 1: &#91;Stack&#93; →\n  Thread 2: &#91;Stack&#93; → Shared &#91;Heap&#93; &#91;Code&#93; &#91;Files&#93;\n  Thread 3: &#91;Stack&#93; →\n# Share memory &#40;except stack&#41;\n</code></pre><p><strong>Pros</strong>:</p><ul><li><strong>Lightweight</strong> (creating thread = cheap)</li><li><strong>Easy communication</strong> (shared memory)</li></ul><p><strong>Cons</strong>:</p><ul><li><strong>No isolation</strong> (one thread crashes → entire process crashes)</li><li><strong>Race conditions</strong> (multiple threads → shared data → bugs!)</li></ul><p><strong>Plant lens</strong>: </p><ul><li><strong>Processes</strong> = separate gardens (isolated, safe)</li><li><strong>Threads</strong> = multiple gardeners in one garden (coordinated, but conflicts possible)<h2></h2></li></ul><h2>The Race Condition Problem</h2><p><strong>When threads share data</strong>, order matters:</p><pre><code class=\"python\"># Shared counter\ncounter = 0\n\ndef increment&#40;&#41;:\n    global counter\n    temp = counter      # Read\n    temp = temp + 1     # Compute\n    counter = temp      # Write\n\n# Two threads run increment&#40;&#41; simultaneously:\nThread 1:  temp = counter &#40;0&#41;\nThread 2:  temp = counter &#40;0&#41;  # Both read 0!\nThread 1:  temp = temp + 1 &#40;1&#41;\nThread 2:  temp = temp + 1 &#40;1&#41;\nThread 1:  counter = temp &#40;1&#41;\nThread 2:  counter = temp &#40;1&#41;  # Should be 2, but it's 1!\n</code></pre><p><strong>Result</strong>: Lost update! (Expected: 2, actual: 1)</p><p><strong>This is a race condition</strong> (result depends on timing - non-deterministic, awful for debugging).<h2></h2></p><h2>Synchronization: Locks and Mutexes</h2><p><strong>Solution</strong>: Ensure only <strong>one thread</strong> modifies shared data at a time.</p><h3>Mutex (Mutual Exclusion)</h3><pre><code class=\"python\">import threading\n\ncounter = 0\nlock = threading.Lock&#40;&#41;\n\ndef increment&#40;&#41;:\n    global counter\n    with lock:  # Acquire lock\n        temp = counter\n        temp = temp + 1\n        counter = temp\n    # Release lock &#40;automatic with 'with'&#41;\n\n# Now: Only one thread can be inside 'with lock' block at a time\n# Result: counter = 2 &#40;correct!&#41;\n</code></pre><p><strong>Plant lens</strong>: <strong>\"Mutex is like a gate key—only one gardener can have the key (and enter the greenhouse) at a time.\"</strong></p><h3>Semaphore</h3><p><strong>Generalization</strong>: Allow <strong>N</strong> threads (not just 1):</p><pre><code class=\"python\">semaphore = threading.Semaphore&#40;3&#41;  # Max 3 threads\n\ndef limited&#95;access&#40;&#41;:\n    with semaphore:\n        # At most 3 threads here simultaneously\n        expensive&#95;operation&#40;&#41;\n</code></pre><p><strong>Use case</strong>: Limit concurrent database connections, API calls, etc.</p><p><strong>Plant lens</strong>: <strong>\"Semaphore is like a greenhouse with limited space—only 3 gardeners fit at once.\"</strong><h2></h2></p><h2>Deadlock: The Deadly Embrace</h2><p><strong>When threads wait for each other</strong>, forever:</p><pre><code class=\"python\">lock&#95;A = threading.Lock&#40;&#41;\nlock&#95;B = threading.Lock&#40;&#41;\n\n# Thread 1:\nwith lock&#95;A:\n    with lock&#95;B:  # Needs B\n        work&#40;&#41;\n\n# Thread 2:\nwith lock&#95;B:\n    with lock&#95;A:  # Needs A\n        work&#40;&#41;\n\n# Scenario:\n# Thread 1 acquires A, waits for B\n# Thread 2 acquires B, waits for A\n# Both stuck forever! &#40;DEADLOCK&#41;\n</code></pre><p><strong>Prevention</strong>:</p><ol><li><strong>Lock ordering</strong>: Always acquire locks in same order (A then B, never B then A)</li><li><strong>Timeout</strong>: Give up if lock isn't available (retry or fail gracefully)</li><li><strong>Avoid nested locks</strong>: Minimize complexity</li></ol><p><strong>Plant lens</strong>: <strong>\"Deadlock is like two gardeners blocking each other's path—neither can move forward.\"</strong><h2></h2></p><h2>Clojure's Concurrency Model</h2><p><strong>Clojure</strong> (Essay 9504) makes concurrency <strong>safer</strong> through <strong>immutability</strong>:</p><h3>Atoms (Shared, Synchronous)</h3><pre><code class=\"clojure\">&#40;def counter &#40;atom 0&#41;&#41;\n\n;; Increment &#40;thread-safe!&#41;\n&#40;swap! counter inc&#41;\n\n;; Multiple threads can call swap! safely\n;; Clojure handles synchronization internally\n</code></pre><p><strong>No explicit locks needed!</strong> (Clojure uses compare-and-swap internally)</p><h3>Refs (Coordinated, Transactional)</h3><pre><code class=\"clojure\">&#40;def account-a &#40;ref 100&#41;&#41;\n&#40;def account-b &#40;ref 200&#41;&#41;\n\n;; Transfer money &#40;atomic transaction&#41;\n&#40;dosync\n  &#40;alter account-a - 50&#41;\n  &#40;alter account-b + 50&#41;&#41;\n\n;; All-or-nothing &#40;like database transactions&#41;\n;; If one fails, both rollback\n</code></pre><p><strong>STM</strong> (Software Transactional Memory) ensures consistency.</p><h3>Agents (Asynchronous)</h3><pre><code class=\"clojure\">&#40;def logger &#40;agent &#91;&#93;&#41;&#41;\n\n;; Send work to agent &#40;returns immediately&#41;\n&#40;send logger conj &quot;Log message 1&quot;&#41;\n&#40;send logger conj &quot;Log message 2&quot;&#41;\n\n;; Agent processes queue in background\n</code></pre><p><strong>Fire-and-forget</strong>: Good for logging, background tasks.</p><p><strong>Key insight</strong>: <strong>Immutability</strong> + <strong>explicit state management</strong> = safer concurrency (no hidden race conditions).<h2></h2></p><h2>Concurrency Patterns</h2><h3>Producer-Consumer</h3><pre><code>Producer Thread:  &#91;Generate data&#93; → Queue\nConsumer Thread:  Queue → &#91;Process data&#93;\n\n# Producer adds to queue\n# Consumer removes from queue\n# Queue handles synchronization\n</code></pre><p><strong>Use case</strong>: Web scraper (producer) + data analyzer (consumer).</p><h3>Thread Pool</h3><pre><code>Task Queue: &#91;Task 1&#93; &#91;Task 2&#93; &#91;Task 3&#93; ...\n                ↓       ↓       ↓\nWorker Threads: &#91;Thread 1&#93; &#91;Thread 2&#93; &#91;Thread 3&#93;\n# Threads pick tasks from queue\n</code></pre><p><strong>Benefit</strong>: Reuse threads (avoid creation overhead).</p><p><strong>Use case</strong>: Web servers (thread pool handles requests).</p><h3>Map-Reduce</h3><pre><code>Data: &#91;1, 2, 3, 4, 5, 6, 7, 8&#93;\n\nMap &#40;parallel&#41;:\n  Thread 1: &#91;1, 2&#93; → &#91;2, 4&#93;\n  Thread 2: &#91;3, 4&#93; → &#91;6, 8&#93;\n  Thread 3: &#91;5, 6&#93; → &#91;10, 12&#93;\n  Thread 4: &#91;7, 8&#93; → &#91;14, 16&#93;\n\nReduce &#40;combine&#41;:\n  &#91;2, 4, 6, 8, 10, 12, 14, 16&#93; → sum = 72\n</code></pre><p><strong>Functional approach</strong> (no shared state, easier to parallelize).</p><p><strong>Clojure</strong>: <code>pmap</code> (parallel map), <code>reducers</code> library.<h2></h2></p><h2>Why Immutability Helps</h2><p><strong>Mutable shared state</strong> = race conditions:</p><pre><code class=\"python\"># BAD: Mutable list, multiple threads\nshared&#95;list = &#91;&#93;\n\ndef thread&#95;work&#40;&#41;:\n    shared&#95;list.append&#40;1&#41;  # RACE CONDITION!\n</code></pre><p><strong>Immutable</strong> = no race conditions:</p><pre><code class=\"clojure\">;; GOOD: Immutable vector\n&#40;def shared-vec &#40;atom &#91;&#93;&#41;&#41;\n\n&#40;defn thread-work &#91;&#93;\n  &#40;swap! shared-vec conj 1&#41;&#41;  ; Clojure handles synchronization\n</code></pre><p><strong>Key insight</strong>: Can't have a race condition if data <strong>can't be modified</strong>.</p><p><strong>Plant lens</strong>: <strong>\"Immutable data is like seeds (you can't change the genetics). Mutable data is like actively growing plants (multiple gardeners might interfere).\"</strong><h2></h2></p><h2>Try This</h2><h3>Exercise 1: Race Condition Demo</h3><pre><code class=\"python\">import threading\n\ncounter = 0\n\ndef increment&#40;&#41;:\n    global counter\n    for &#95; in range&#40;100000&#41;:\n        counter += 1\n\nthreads = &#91;threading.Thread&#40;target=increment&#41; for &#95; in range&#40;10&#41;&#93;\n\nfor t in threads:\n    t.start&#40;&#41;\n\nfor t in threads:\n    t.join&#40;&#41;\n\nprint&#40;f&quot;Counter: {counter}&quot;&#41;\n# Expected: 1,000,000 &#40;10 threads × 100,000&#41;\n# Actual: &#126;600,000-900,000 &#40;WRONG! Race conditions!&#41;\n</code></pre><p><strong>Fix</strong>: Add a lock around <code>counter += 1</code>.<h2></h2></p><h3>Exercise 2: Deadlock Demo</h3><pre><code class=\"python\">import threading\nimport time\n\nlock&#95;a = threading.Lock&#40;&#41;\nlock&#95;b = threading.Lock&#40;&#41;\n\ndef thread&#95;1&#40;&#41;:\n    with lock&#95;a:\n        print&#40;&quot;Thread 1: acquired A&quot;&#41;\n        time.sleep&#40;0.1&#41;  # Simulate work\n        with lock&#95;b:  # Wait for B\n            print&#40;&quot;Thread 1: acquired B&quot;&#41;\n\ndef thread&#95;2&#40;&#41;:\n    with lock&#95;b:\n        print&#40;&quot;Thread 2: acquired B&quot;&#41;\n        time.sleep&#40;0.1&#41;\n        with lock&#95;a:  # Wait for A\n            print&#40;&quot;Thread 2: acquired A&quot;&#41;\n\n# Run both:\nt1 = threading.Thread&#40;target=thread&#95;1&#41;\nt2 = threading.Thread&#40;target=thread&#95;2&#41;\nt1.start&#40;&#41;\nt2.start&#40;&#41;\n\n# Hangs! &#40;deadlock&#41;\n</code></pre><h2></h2><h3>Exercise 3: Clojure Atoms</h3><pre><code class=\"clojure\">;; In Clojure REPL\n&#40;def counter &#40;atom 0&#41;&#41;\n\n;; Safe increment &#40;no race conditions!&#41;\n&#40;defn safe-increment &#91;&#93;\n  &#40;dotimes &#91;&#95; 100000&#93;\n    &#40;swap! counter inc&#41;&#41;&#41;\n\n;; Run in multiple threads\n&#40;doseq &#91;i &#40;range 10&#41;&#93;\n  &#40;future &#40;safe-increment&#41;&#41;&#41;\n\n;; Wait a bit, then check:\n@counter\n;; Result: 1,000,000 &#40;CORRECT! No locks needed&#41;\n</code></pre><p><strong>Observe</strong>: Immutability + atoms = safe concurrency.<h2></h2></p><h2>Going Deeper</h2><h3>Related Essays</h3><ul><li><strong><a href='/12025-10/9570-processes-programs-in-motion'>9570: Processes</a></strong> - Process-level concurrency</li><li><strong><a href='/12025-10/9504-what-is-clojure'>9504: What Is Clojure?</a></strong> - Immutability, atoms, refs</li><li><strong><a href='/12025-10/9520-functional-programming-basics'>9520: Functional Programming</a></strong> - Pure functions (inherently thread-safe)</li><li><strong><a href='/12025-10/9507-helen-atthowe-ecological-systems'>9507: Helen Atthowe</a></strong> - Coordination in living systems</li></ul><h3>External Resources</h3><ul><li><strong>\"The Little Book of Semaphores\"</strong> - Concurrency patterns</li><li><strong>\"Java Concurrency in Practice\"</strong> - Despite title, concepts apply everywhere</li><li><strong>Clojure Concurrency Docs</strong> - STM, atoms, agents</li><li><strong>Go's Concurrency Model</strong> - Goroutines, channels (alternative approach)<h2></h2></li></ul><h2>Reflection Questions</h2><ol><li><strong>Is concurrency worth the complexity?</strong> (Single-threaded is simpler - when do you really need concurrency?)</li><li><strong>Why does Rust prevent data races at compile-time?</strong> (Ownership system - only one mutable reference at a time!)</li><li><strong>Could all programs be purely functional?</strong> (No mutable state = no race conditions - but what about I/O?)</li><li><strong>Is shared memory the right abstraction?</strong> (Message passing (Go, Erlang) vs shared memory (threads) - which is better?)</li><li><strong>How would Nock handle concurrency?</strong> (Deterministic, no time - concurrency must be explicit input!)<h2></h2></li></ol><h2>Summary</h2><p><strong>Concurrency vs Parallelism</strong>:</p><ul><li><strong>Concurrency</strong>: Dealing with multiple tasks (might be on one CPU)</li><li><strong>Parallelism</strong>: Executing simultaneously (requires multiple CPUs)</li></ul><p><strong>Threads vs Processes</strong>:</p><ul><li><strong>Processes</strong>: Isolated, heavyweight, secure</li><li><strong>Threads</strong>: Shared memory, lightweight, race-prone</li></ul><p><strong>Synchronization Primitives</strong>:</p><ul><li><strong>Mutex/Lock</strong>: One thread at a time</li><li><strong>Semaphore</strong>: N threads at a time</li><li><strong>Condition Variable</strong>: Wait for specific condition</li></ul><p><strong>Concurrency Problems</strong>:</p><ul><li><strong>Race condition</strong>: Result depends on timing (non-deterministic)</li><li><strong>Deadlock</strong>: Threads wait for each other forever</li><li><strong>Starvation</strong>: Thread never gets CPU time</li></ul><p><strong>Clojure's Approach</strong>:</p><ul><li><strong>Atoms</strong>: Shared, synchronous (compare-and-swap)</li><li><strong>Refs</strong>: Coordinated, transactional (STM)</li><li><strong>Agents</strong>: Asynchronous (background queue)</li><li><strong>Immutability</strong>: Eliminates most race conditions</li></ul><p><strong>Key Insights</strong>:</p><ul><li><strong>Shared mutable state is the enemy</strong> (causes races)</li><li><strong>Immutability is thread-safe</strong> (can't modify = can't conflict)</li><li><strong>Locks are error-prone</strong> (forget lock = race, wrong order = deadlock)</li><li><strong>Functional approaches win</strong> (pure functions, immutable data)</li></ul><p><strong>In the Valley</strong>:</p><ul><li><strong>We prefer immutability</strong> (Clojure's atoms, not raw locks)</li><li><strong>We use message passing</strong> when possible (actors, channels)</li><li><strong>We avoid shared mutable state</strong> (functional design)</li><li><strong>We test concurrency</strong> (race conditions are sneaky!)</li></ul><p><strong>Plant lens</strong>: <strong>\"Concurrency is multiple gardeners coordinating in shared garden—immutable tools (can't change hoe itself) prevent conflicts, while mutable soil (shared state) requires careful turn-taking.\"</strong><h2></h2></p><p><strong>Next</strong>: We'll explore <strong>build systems</strong>—how source code becomes executable programs, the compilation pipeline, and why reproducible builds matter!<h2></h2></p><p><strong>Navigation</strong>:<br /> ← Previous: <a href='/12025-10/9593-networking-basics-sockets-protocols'>9593 (networking basics sockets protocols)</a> | <strong>Phase 1 Index</strong> | Next: <a href='/12025-10/9595-build-systems-source-to-binary'>9595 (build systems source to binary)</a></p><p><strong>Metadata</strong>:</p><ul><li><strong>Phase</strong>: 1 (Foundations)</li><li><strong>Week</strong>: 4</li><li><strong>Prerequisites</strong>: 9570, 9580, 9504, 9507</li><li><strong>Concepts</strong>: Concurrency, parallelism, threads, race conditions, locks, deadlock, Clojure concurrency (atoms, refs, agents), immutability</li><li><strong>Next Concepts</strong>: Build systems, compilation, linking, reproducible builds</li><li><strong>Plant Lens</strong>: Multiple gardeners (threads), shared garden (memory), tools (immutable = safe), soil (mutable = conflicts)</li></ul><h2></h2><p><div style=\"text-align: center; opacity: 0.6; font-size: 0.85em; margin-top: 3em; padding-top: 1em; border-top: 1px solid rgba(139, 116, 94, 0.2);\"></p><p><strong>Copyright © 2025 <a href='https://codeberg.org/kae3g/12025-10/'>kae3g</a></strong> | Dual-licensed under <a href='https://www.apache.org/licenses/LICENSE-2.0'>Apache-2.0</a> / <a href='https://opensource.org/licenses/MIT'>MIT</a><br /> Competitive technology in service of clarity and beauty</p><p></div></p><p><em><a href='/12025-10/hidden-docs-index.html'>View Hidden Docs Index</a></em> | <em><a href='/12025-10/'>Return to Main Index</a></em></p>",
  "hash" : "2025-10-22T15:17:39.429439499Z-14291"
}