{
  "slug" : "9570-processes-programs-in-motion",
  "meta" : {
    "slug" : "9570-processes-programs-in-motion",
    "title" : "kae3g 9570: Processes - Programs in Motion",
    "filename" : "9570-processes-programs-in-motion.md",
    "source-dir" : "hidden"
  },
  "html" : "<h1>kae3g 9570: Processes - Programs in Motion</h1><p><strong>Phase 1: Foundations & Philosophy</strong> | <strong>Week 3</strong> | <strong>Reading Time: 15 minutes</strong><h2></h2></p><h2>What You'll Learn</h2><ul><li>What processes are (programs + runtime state)</li><li>How your OS manages hundreds of processes simultaneously</li><li>Process lifecycle: creation, execution, termination</li><li>Signals: How to communicate with running processes</li><li>Process trees: Parent-child relationships</li><li>Practical commands: <code>ps</code>, <code>top</code>, <code>htop</code>, <code>kill</code>, <code>pgrep</code></li><li>Why processes are the \"living cells\" of your computer<h2></h2></li></ul><h2>Prerequisites</h2><ul><li><strong><a href='/12025-10/9500-what-is-a-computer'>9500: What Is a Computer?</a></strong> - CPU, memory, execution</li><li><strong><a href='/12025-10/9560-text-files-universal-format'>9560: Text Files</a></strong> - Source code (text) becomes processes<h2></h2></li></ul><h2>From Text to Life</h2><p><strong>Journey of a program</strong>:</p><pre><code>1. Source code &#40;text file&#41;\n   ↓\n2. Compilation &#40;if needed&#41;\n   ↓\n3. Executable &#40;binary file on disk&#41;\n   ↓\n4. Process &#40;loaded into memory, executing&#41;\n</code></pre><p><strong>Example</strong>:</p><pre><code class=\"clojure\">;; hello.clj &#40;text file - dormant&#41;\n&#40;println &quot;Hello, Valley!&quot;&#41;\n</code></pre><p><strong>Run it</strong>:<pre><code class=\"bash\">clojure hello.clj\n# Now it's a PROCESS &#40;running in memory&#41;\n</code></pre></p><p><strong>Plant lens</strong>: <strong>\"Source code is the seed (dormant). Process is the plant (growing, alive).\"</strong><h2></h2></p><h2>What Is a Process?</h2><p><strong>A process is</strong>:</p><ul><li><strong>Program code</strong> (instructions from executable)</li><li><strong>Memory</strong> (data the program uses)</li><li><strong>CPU time</strong> (when the CPU executes its instructions)</li><li><strong>File handles</strong> (open files, network connections)</li><li><strong>Process ID (PID)</strong> (unique identifier)</li></ul><p><strong>It's a program IN MOTION</strong> (not just sitting on disk, but running).</p><p><strong>Example</strong>:</p><pre><code class=\"bash\"># List running processes\nps aux\n\n# Output &#40;simplified&#41;:\n# USER   PID  %CPU %MEM COMMAND\n# alice  1234 2.0  1.5  /usr/bin/python3 server.py\n# alice  5678 0.5  0.3  clojure app.clj\n# bob    9101 5.0  3.2  /Applications/Chrome.app/Contents/MacOS/Google Chrome\n</code></pre><p><strong>Each line is a process</strong> (a running program).<h2></h2></p><h2>Process Anatomy</h2><p><strong>Key components</strong>:</p><h3>1. Process ID (PID)</h3><p><strong>Every process</strong> has a unique number:</p><pre><code class=\"bash\"># Find PID of a process\npgrep firefox\n# Output: 12345\n\n# Or:\nps aux | grep firefox\n</code></pre><p><strong>PID 1</strong> is special (the init system - first process on boot).</p><h3>2. Parent Process (PPID)</h3><p><strong>Most processes have a parent</strong> (the process that created them):</p><pre><code class=\"bash\"># See process tree\npstree\n# Or &#40;macOS&#41;:\nps auxf  # Shows hierarchy\n</code></pre><p><strong>Example</strong>:</p><pre><code>bash &#40;PID 1000&#41;\n  └─ python3 script.py &#40;PID 2000, PPID 1000&#41;\n      └─ sh -c &quot;echo hello&quot; &#40;PID 3000, PPID 2000&#41;\n</code></pre><p><strong>Plant lens</strong>: <strong>\"Parent process is the stem, child processes are branches.\"</strong></p><h3>3. Memory</h3><p><strong>Each process</strong> has its own memory space:</p><ul><li><strong>Code</strong> (program instructions)</li><li><strong>Data</strong> (global variables)</li><li><strong>Heap</strong> (dynamically allocated memory)</li><li><strong>Stack</strong> (function call frames, local variables)</li></ul><p><strong>Processes are isolated</strong> (one process can't access another's memory directly—security!).</p><h3>4. File Descriptors</h3><p><strong>Open files, sockets, pipes</strong>:</p><pre><code class=\"bash\"># List open files for a process\nlsof -p 12345\n\n# Standard descriptors:\n# 0 = stdin &#40;input&#41;\n# 1 = stdout &#40;output&#41;\n# 2 = stderr &#40;errors&#41;\n</code></pre><p><strong>Example</strong>:<pre><code class=\"bash\"># Redirect stdout to file\npython3 script.py &gt; output.txt\n# &#40;stdout descriptor points to output.txt instead of terminal&#41;\n</code></pre></p><h2></h2><h2>Process Lifecycle</h2><h3>1. Creation (Fork/Exec)</h3><p><strong>On Unix</strong>, processes are created via <code>fork&#40;&#41;</code> + <code>exec&#40;&#41;</code>:</p><p><strong>Fork</strong>: Create a copy of current process<pre><code class=\"c\">pid&#95;t child&#95;pid = fork&#40;&#41;;\n// Now TWO processes &#40;parent + child&#41;\n</code></pre></p><p><strong>Exec</strong>: Replace current process with new program<pre><code class=\"c\">execve&#40;&quot;/bin/ls&quot;, args, env&#41;;\n// Current process is now &quot;ls&quot;\n</code></pre></p><p><strong>Together</strong>:<pre><code class=\"bash\"># When you run &quot;ls&quot; in bash:\n# 1. bash calls fork&#40;&#41; &#40;creates bash copy&#41;\n# 2. Child calls exec&#40;&quot;/bin/ls&quot;&#41; &#40;becomes ls&#41;\n# 3. Parent waits for child to finish\n</code></pre></p><p><strong>Plant lens</strong>: <strong>\"Fork is like a cutting (clone parent plant), exec is grafting (different plant on same root).\"</strong></p><h3>2. Execution (Running)</h3><p><strong>Process states</strong>:</p><ul><li><strong>Running</strong> (currently on CPU)</li><li><strong>Runnable</strong> (ready to run, waiting for CPU)</li><li><strong>Sleeping</strong> (waiting for I/O, timer, signal)</li><li><strong>Stopped</strong> (paused, e.g., by Ctrl-Z)</li><li><strong>Zombie</strong> (finished, but parent hasn't acknowledged yet)</li></ul><p><strong>Check state</strong>:<pre><code class=\"bash\">ps aux\n# Look at STAT column:\n# R = Running\n# S = Sleeping &#40;interruptible&#41;\n# D = Sleeping &#40;uninterruptible, e.g., waiting for disk&#41;\n# T = Stopped\n# Z = Zombie\n</code></pre></p><h3>3. Termination (Exit)</h3><p><strong>Process ends</strong> when:</p><ul><li>Program calls <code>exit&#40;&#41;</code> (normal termination)</li><li>Process receives a signal (e.g., <code>SIGKILL</code>)</li><li>Unhandled error (crash)</li></ul><p><strong>Exit code</strong>:<pre><code class=\"bash\"># Run a command\nls /nonexistent\n\n# Check exit code\necho $?\n# Output: 2 &#40;error!&#41;\n\n# Success:\nls /\necho $?\n# Output: 0 &#40;success&#41;\n</code></pre></p><p><strong>Convention</strong>: <code>0</code> = success, non-zero = error.<h2></h2></p><h2>Signals: Talking to Processes</h2><p><strong>Signals</strong> are messages sent to processes:</p><p><strong>Common signals</strong>:</p><ul><li><strong>SIGINT</strong> (2): Interrupt (Ctrl-C in terminal)</li><li><strong>SIGTERM</strong> (15): Terminate gracefully (default for <code>kill</code>)</li><li><strong>SIGKILL</strong> (9): Kill immediately (can't be caught or ignored!)</li><li><strong>SIGSTOP</strong> (19): Pause process (Ctrl-Z)</li><li><strong>SIGCONT</strong> (18): Resume process</li><li><strong>SIGHUP</strong> (1): Hangup (terminal closed)</li></ul><p><strong>Send signal</strong>:<pre><code class=\"bash\"># Graceful termination\nkill -TERM 12345\n\n# Force kill\nkill -9 12345\n\n# Pause process\nkill -STOP 12345\n\n# Resume it\nkill -CONT 12345\n</code></pre></p><p><strong>Practical example</strong>:<pre><code class=\"bash\"># Start long-running process\npython3 server.py\n# &#40;Ctrl-C to stop - sends SIGINT&#41;\n\n# Or run in background:\npython3 server.py &amp;\n# Get its PID\npgrep -f server.py\n# Kill it later\nkill $&#40;pgrep -f server.py&#41;\n</code></pre></p><h2></h2><h2>Process Inspection</h2><h3><code>ps</code> - Process Status</h3><p><strong>List all processes</strong>:<pre><code class=\"bash\">ps aux\n# a = all users\n# u = user-oriented format\n# x = include processes without terminal\n</code></pre></p><p><strong>Filter</strong>:<pre><code class=\"bash\"># My processes\nps u\n\n# Specific user\nps -u alice\n\n# Process tree &#40;hierarchy&#41;\nps auxf  # Linux\nps aux | grep &lt;pattern&gt;  # macOS\n</code></pre></p><h3><code>top</code> / <code>htop</code> - Interactive Monitor</h3><p><strong>Top</strong>:<pre><code class=\"bash\">top\n# Shows:\n# - PID, USER, %CPU, %MEM, COMMAND\n# - Sorted by CPU usage &#40;by default&#41;\n# - Updates every few seconds\n\n# Useful keys:\n# q = quit\n# M = sort by memory\n# P = sort by CPU\n# k = kill a process &#40;enter PID&#41;\n</code></pre></p><p><strong>htop</strong> (better interface):<pre><code class=\"bash\">htop\n# &#40;Install with: brew install htop&#41;\n# Visual bars for CPU/memory\n# Tree view &#40;F5&#41;\n# Kill process &#40;F9&#41;\n</code></pre></p><h3><code>pgrep</code> / <code>pkill</code> - Find/Kill by Name</h3><pre><code class=\"bash\"># Find PID by name\npgrep firefox\n# Output: 12345 67890\n\n# Find with full command line\npgrep -f &quot;python3 server.py&quot;\n\n# Kill by name\npkill firefox\n\n# Kill with signal\npkill -TERM firefox\n</code></pre><h2></h2><h2>Process Trees</h2><p><strong>Every process</strong> (except PID 1) has a parent.</p><p><strong>Example hierarchy</strong>:</p><pre><code>systemd &#40;PID 1&#41;\n  ├─ sshd &#40;PID 1000&#41;\n  │   └─ sshd &#40;PID 2000, session for alice&#41;\n  │       └─ bash &#40;PID 2100&#41;\n  │           ├─ vim &#40;PID 2200&#41;\n  │           └─ python3 &#40;PID 2300&#41;\n  ├─ cron &#40;PID 3000&#41;\n  └─ nginx &#40;PID 4000&#41;\n      ├─ nginx worker &#40;PID 4001&#41;\n      └─ nginx worker &#40;PID 4002&#41;\n</code></pre><p><strong>View tree</strong>:<pre><code class=\"bash\"># Linux\npstree\n\n# macOS &#40;no pstree by default&#41;\nps auxf  # Or install pstree via brew\n</code></pre></p><p><strong>Why trees matter</strong>:</p><ul><li><strong>Signals propagate</strong> (kill parent → children may also die)</li><li><strong>Resource limits</strong> can apply to entire subtree</li><li><strong>Understand relationships</strong> (which process spawned which)<h2></h2></li></ul><h2>Practical: Process Management</h2><h3>Example 1: Long-Running Script</h3><pre><code class=\"bash\"># Run script &#40;blocks terminal&#41;\npython3 long&#95;task.py\n\n# Better: Run in background\npython3 long&#95;task.py &amp;\n# &#40;Returns immediately, prints PID&#41;\n\n# Check it's running\npgrep -f long&#95;task\n\n# Bring to foreground\nfg\n\n# Send to background again &#40;after Ctrl-Z to pause&#41;\nbg\n</code></pre><h3>Example 2: Kill Unresponsive App</h3><pre><code class=\"bash\"># Find PID\npgrep -f &quot;MyApp&quot;\n# Or:\nps aux | grep MyApp\n\n# Try graceful kill\nkill -TERM &lt;PID&gt;\n\n# Wait 5 seconds...\n\n# Force kill if still running\nkill -9 &lt;PID&gt;\n</code></pre><h3>Example 3: Monitor Resource Usage</h3><pre><code class=\"bash\"># Watch resource usage live\nhtop\n\n# Or for specific process:\ntop -pid &lt;PID&gt;\n\n# Get snapshot\nps aux --sort=-%mem | head -10  # Top 10 memory users &#40;Linux&#41;\nps aux -m | head -10             # macOS\n</code></pre><h2></h2><h2>Zombies and Orphans</h2><h3>Zombie Processes</h3><p><strong>When a process exits</strong>, it becomes a zombie until its parent calls <code>wait&#40;&#41;</code>:</p><pre><code class=\"bash\">ps aux | grep Z\n# Look for STAT = Z\n\n# Example:\n# alice  12345  0.0  0.0  0  0  ?  Z  10:00  &#91;defunct&#93;\n</code></pre><p><strong>Why</strong>: Parent needs to read exit status (then zombie is reaped).</p><p><strong>Usually harmless</strong> (takes no resources), but many zombies indicate a bug (parent not calling <code>wait&#40;&#41;</code>).</p><p><strong>Fix</strong>: Kill the parent (or fix its code).</p><h3>Orphan Processes</h3><p><strong>When a parent dies</strong> before its child:</p><ul><li>Child becomes orphan</li><li>Gets <strong>re-parented</strong> to PID 1 (init/systemd)</li></ul><p><strong>Example</strong>:<pre><code class=\"bash\">bash &#40;PID 1000&#41;\n  └─ python3 &#40;PID 2000&#41;\n\n# Kill bash:\nkill 1000\n\n# Now:\nsystemd &#40;PID 1&#41;\n  └─ python3 &#40;PID 2000, re-parented&#41;\n</code></pre></p><p><strong>Plant lens</strong>: <strong>\"Orphaned process is adopted by the root (PID 1 as the main trunk).\"</strong><h2></h2></p><h2>Concurrency: Many Processes at Once</h2><p><strong>Your computer runs</strong> 100s of processes simultaneously:</p><pre><code class=\"bash\">ps aux | wc -l\n# Output: 237 processes &#40;example&#41;\n</code></pre><p><strong>How?</strong> <strong>Time-slicing</strong> (CPU switches between processes rapidly):</p><pre><code>Time:   0ms    10ms   20ms   30ms   40ms   50ms\nCPU:    A      B      C      A      B      D\n# Each process gets a turn &#40;scheduler decides&#41;\n</code></pre><p><strong>You don't notice</strong> (switching is so fast, feels simultaneous).</p><p><strong>This is multitasking</strong> (essential for modern OS).<h2></h2></p><h2>Try This</h2><h3>Exercise 1: Explore Your Processes</h3><pre><code class=\"bash\"># How many processes?\nps aux | wc -l\n\n# Top CPU users\nps aux --sort=-%cpu | head -10  # Linux\nps aux | sort -nrk 3 | head -10  # macOS\n\n# Top memory users\nps aux --sort=-%mem | head -10  # Linux\nps aux | sort -nrk 4 | head -10  # macOS\n\n# What are they? Recognize them?\n</code></pre><h2></h2><h3>Exercise 2: Process Lifecycle</h3><pre><code class=\"bash\"># Start a long-running process\nsleep 60 &amp;\n# &#40;Prints PID, e.g., 12345&#41;\n\n# Verify it's running\nps aux | grep sleep\n# Or:\npgrep sleep\n\n# Wait 10 seconds...\n\n# Kill it\nkill $&#40;pgrep sleep&#41;\n\n# Verify it's gone\npgrep sleep\n# &#40;No output = process dead&#41;\n</code></pre><h2></h2><h3>Exercise 3: Signals</h3><pre><code class=\"bash\"># Start interactive process\npython3\n# &#40;Python REPL&#41;\n\n# In another terminal:\npgrep -f python3\n# &#40;Get PID, e.g., 12345&#41;\n\n# Send SIGSTOP &#40;pause&#41;\nkill -STOP 12345\n\n# Try typing in Python REPL - frozen!\n\n# Resume it\nkill -CONT 12345\n\n# Python REPL works again!\n</code></pre><h2></h2><h2>Going Deeper</h2><h3>Related Essays</h3><ul><li><strong><a href='/12025-10/9500-what-is-a-computer'>9500: What Is a Computer?</a></strong> - CPU executes processes</li><li><strong><a href='/12025-10/9560-text-files-universal-format'>9560: Text Files</a></strong> - Source code → process</li><li><strong><a href='/12025-10/9550-command-line-your-primary-interface'>9550: Command Line</a></strong> - Tools for managing processes</li><li><strong><a href='/12025-10/9951-init-systems-landscape'>9951: Init Systems</a></strong> - PID 1, process supervision</li></ul><h3>External Resources</h3><ul><li><strong><code>man ps</code></strong> - Process status command manual</li><li><strong><code>man kill</code></strong> - Signal command manual</li><li><strong><code>man 7 signal</code></strong> - Signal overview (Linux)</li><li><strong>\"The Linux Programming Interface\"</strong> - Processes in depth<h2></h2></li></ul><h2>Reflection Questions</h2><ol><li><strong>Why do processes need isolation?</strong> (Security? Stability? What if one process could write to another's memory?)</li><li><strong>Is killing with SIGKILL (9) bad?</strong> (When is it necessary? When should you use SIGTERM instead?)</li><li><strong>How does your OS decide which process runs next?</strong> (Scheduler algorithms - priority, fairness, interactivity)</li><li><strong>Can a process have no parent?</strong> (Only PID 1 - everything else is descended from it)</li><li><strong>What happens if PID 1 crashes?</strong> (Kernel panic! The whole system depends on it)<h2></h2></li></ol><h2>Summary</h2><p><strong>Processes are</strong>:</p><ul><li><strong>Programs in motion</strong> (loaded into memory, executing)</li><li><strong>Isolated</strong> (each has its own memory space)</li><li><strong>Managed by OS</strong> (scheduler, signals, lifecycle)</li><li><strong>Organized in trees</strong> (parent-child relationships)</li></ul><p><strong>Key Concepts</strong>:</p><ul><li><strong>PID</strong>: Unique process identifier</li><li><strong>States</strong>: Running, sleeping, stopped, zombie</li><li><strong>Signals</strong>: Messages to processes (SIGINT, SIGTERM, SIGKILL, etc.)</li><li><strong>Fork/Exec</strong>: How processes are created</li><li><strong>Exit codes</strong>: 0 = success, non-zero = error</li></ul><p><strong>Practical Commands</strong>:</p><ul><li><strong><code>ps aux</code></strong>: List all processes</li><li><strong><code>top</code>/<code>htop</code></strong>: Interactive monitor</li><li><strong><code>pgrep &lt;name&gt;</code></strong>: Find PID by name</li><li><strong><code>kill &lt;PID&gt;</code></strong>: Send signal to process</li><li><strong><code>pkill &lt;name&gt;</code></strong>: Kill by name</li></ul><p><strong>In the Valley</strong>:</p><ul><li><strong>Processes are living entities</strong> (seeds → plants)</li><li><strong>We manage them carefully</strong> (graceful shutdown, not brute force)</li><li><strong>We understand hierarchy</strong> (parent-child, like branches from a trunk)</li><li><strong>We monitor resources</strong> (CPU, memory - like water, nutrients for plants)</li></ul><p><strong>Plant lens</strong>: <strong>\"Source code is the seed (potential), process is the growing plant (actualized, alive, consuming resources).\"</strong><h2></h2></p><p><strong>Next</strong>: We'll explore <strong>memory</strong> in depth—how processes store and access data, the difference between stack and heap, and why memory management matters!<h2></h2></p><p><strong>Navigation</strong>:<br /> ← Previous: <a href='/12025-10/9560-text-files-universal-format'>9560 (text files universal format)</a> | <strong>Phase 1 Index</strong> | Next: <a href='/12025-10/9580-memory-management'>9580 (memory management)</a></p><p><strong>Metadata</strong>:</p><ul><li><strong>Phase</strong>: 1 (Foundations)</li><li><strong>Week</strong>: 3</li><li><strong>Prerequisites</strong>: 9500, 9560</li><li><strong>Concepts</strong>: Processes, PID, signals, fork/exec, process lifecycle, zombies, orphans, concurrency</li><li><strong>Next Concepts</strong>: Memory (stack, heap, virtual memory)</li><li><strong>Plant Lens</strong>: Seeds (code) → plants (processes), isolation as root zones, parent-child as branches</li></ul><h2></h2><p><div style=\"text-align: center; opacity: 0.6; font-size: 0.85em; margin-top: 3em; padding-top: 1em; border-top: 1px solid rgba(139, 116, 94, 0.2);\"></p><p><strong>Copyright © 2025 <a href='https://codeberg.org/kae3g/12025-10/'>kae3g</a></strong> | Dual-licensed under <a href='https://www.apache.org/licenses/LICENSE-2.0'>Apache-2.0</a> / <a href='https://opensource.org/licenses/MIT'>MIT</a><br /> Competitive technology in service of clarity and beauty</p><p></div></p><p><em><a href='/12025-10/hidden-docs-index.html'>View Hidden Docs Index</a></em> | <em><a href='/12025-10/'>Return to Main Index</a></em></p>",
  "hash" : "2025-10-22T15:17:39.429261946Z-14007"
}