{
  "slug" : "9602-shell-scripting-bash-fundamentals",
  "meta" : {
    "slug" : "9602-shell-scripting-bash-fundamentals",
    "title" : "kae3g 9601: Shell Scripting Fundamentals - Variables, Conditionals, Loops",
    "filename" : "9602-shell-scripting-bash-fundamentals.md",
    "source-dir" : "hidden"
  },
  "html" : "<h1>kae3g 9601: Shell Scripting Fundamentals - Variables, Conditionals, Loops</h1><p><strong>Phase 2: Core Systems & Tools</strong> | <strong>Week 6</strong> | <strong>Reading Time: 16 minutes</strong><h2></h2></p><h2>Welcome to Phase 2! 🎉</h2><p><strong>Congratulations</strong> on completing Phase 1! You now understand the <strong>foundations</strong> of computing systems. Phase 2 builds on that knowledge by teaching you <strong>practical mastery</strong> of the tools and systems that power modern infrastructure.</p><p><strong>We start</strong> with the <strong>shell</strong> - your most powerful interface to Unix systems.<h2></h2></p><h2>What You'll Learn</h2><ul><li>Why shell scripting is essential (automation!)</li><li>Variables and quoting rules</li><li>Conditionals (if/then/else)</li><li>Loops (for, while, until)</li><li>Exit codes and error handling</li><li>Best practices for robust scripts</li><li>When to use shell vs other languages<h2></h2></li></ul><h2>Prerequisites</h2><ul><li><strong><a href='/12025-10/9550-command-line-your-primary-interface'>9550: The Command Line</a></strong> - Basic shell usage</li><li><strong><a href='/12025-10/9560-text-files-universal-format'>9560: Text Files</a></strong> - Understanding plain text</li><li><strong><a href='/12025-10/9570-processes-programs-in-motion'>9570: Processes</a></strong> - How programs run<h2></h2></li></ul><h2>Why Shell Scripting?</h2><p><strong>The Unix philosophy</strong> (Essay 9510): \"Do one thing well\" + \"Compose tools\"</p><p><strong>Shell scripts</strong> are the <strong>glue</strong> that combines simple tools into powerful workflows.</p><h3>What Shell Scripts Do Best</h3><p><strong>Automation</strong>:<pre><code class=\"bash\">#!/bin/bash\n# Deploy script - runs every time we ship\n./run-tests.sh\n./build-artifacts.sh\n./upload-to-server.sh\n./restart-services.sh\n</code></pre></p><p><strong>System Administration</strong>:<pre><code class=\"bash\"># Check disk space, clean up if needed\nif &#91; $&#40;df / | tail -1 | awk '{print $5}' | sed 's/%//'&#41; -gt 90 &#93;; then\n    echo &quot;Disk almost full! Cleaning...&quot;\n    find /tmp -type f -mtime +7 -delete\nfi\n</code></pre></p><p><strong>Data Processing</strong>:<pre><code class=\"bash\"># Process logs: extract errors, count, email report\ngrep ERROR /var/log/app.log | \\\n    cut -d' ' -f3 | \\\n    sort | uniq -c | \\\n    mail -s &quot;Error Report&quot; admin@example.com\n</code></pre></p><p><strong>Quick Prototypes</strong>:</p><ul><li>Test an idea in 5 minutes</li><li>Iterate rapidly</li><li>Replace with \"real\" language later (if needed!)<h2></h2></li></ul><h2>Your First Script</h2><h3>The Shebang</h3><pre><code class=\"bash\">#!/bin/bash\n# This is a comment\n\necho &quot;Hello, Valley Builder!&quot;\n</code></pre><p><strong>First line</strong> (<code>#!/bin/bash</code>): <strong>Shebang</strong></p><ul><li>Tells OS which interpreter to use</li><li><code>/bin/bash</code> = Bash shell</li><li>Alternative: <code>#!/bin/sh</code> (POSIX shell, more portable)</li></ul><p><strong>Make it executable</strong>:<pre><code class=\"bash\">chmod +x hello.sh\n./hello.sh\n# Output: Hello, Valley Builder!\n</code></pre></p><h2></h2><h2>Variables</h2><h3>Basic Assignment</h3><pre><code class=\"bash\">name=&quot;Ada Lovelace&quot;\nyear=1842\n\necho &quot;Hello, $name!&quot;\necho &quot;The year is $year&quot;\n</code></pre><p><strong>Rules</strong>:</p><ul><li>No spaces around <code>=</code></li><li>Use <code>$</code> to access value</li><li>Quotes recommended for strings</li></ul><h3>Quoting</h3><p><strong>Three types</strong>:</p><pre><code class=\"bash\"># Single quotes: Literal &#40;no expansion&#41;\necho 'My name is $name'\n# Output: My name is $name\n\n# Double quotes: Variable expansion\necho &quot;My name is $name&quot;\n# Output: My name is Ada Lovelace\n\n# No quotes: Word splitting + globbing\nfiles=$HOME/&#42;.txt\necho $files\n# Output: /home/user/file1.txt /home/user/file2.txt\n</code></pre><p><strong>Best practice</strong>: Always quote variables!</p><pre><code class=\"bash\"># BAD &#40;breaks on spaces&#41;\nfile=$HOME/My Documents/file.txt\ncat $file  # ERROR: tries to cat 3 files\n\n# GOOD\nfile=&quot;$HOME/My Documents/file.txt&quot;\ncat &quot;$file&quot;  # Works!\n</code></pre><h3>Command Substitution</h3><p><strong>Run command, capture output</strong>:</p><pre><code class=\"bash\"># Old style &#40;deprecated&#41;\ncurrent&#95;user=`whoami`\n\n# New style &#40;preferred&#41;\ncurrent&#95;user=$&#40;whoami&#41;\ncurrent&#95;date=$&#40;date +%Y-%m-%d&#41;\n\necho &quot;User: $current&#95;user&quot;\necho &quot;Date: $current&#95;date&quot;\n</code></pre><h2></h2><h2>Conditionals</h2><h3>if/then/else</h3><pre><code class=\"bash\">#!/bin/bash\n\nage=25\n\nif &#91; $age -ge 18 &#93;; then\n    echo &quot;Adult&quot;\nelse\n    echo &quot;Minor&quot;\nfi\n</code></pre><p><strong>Syntax</strong>:</p><ul><li><code>if &#91; condition &#93;; then</code></li><li><code>&#91; &#93;</code> is the <code>test</code> command</li><li><code>-ge</code> = \"greater than or equal\"</li><li><code>fi</code> = \"if\" backwards (closes block)</li></ul><h3>Test Operators</h3><p><strong>Numeric</strong>:<pre><code class=\"bash\">&#91; $a -eq $b &#93;  # Equal\n&#91; $a -ne $b &#93;  # Not equal\n&#91; $a -lt $b &#93;  # Less than\n&#91; $a -le $b &#93;  # Less than or equal\n&#91; $a -gt $b &#93;  # Greater than\n&#91; $a -ge $b &#93;  # Greater than or equal\n</code></pre></p><p><strong>String</strong>:<pre><code class=\"bash\">&#91; &quot;$a&quot; = &quot;$b&quot; &#93;   # Equal &#40;use = not ==!&#41;\n&#91; &quot;$a&quot; != &quot;$b&quot; &#93;  # Not equal\n&#91; -z &quot;$a&quot; &#93;       # Empty string\n&#91; -n &quot;$a&quot; &#93;       # Not empty\n</code></pre></p><p><strong>File</strong>:<pre><code class=\"bash\">&#91; -e &quot;$file&quot; &#93;  # Exists\n&#91; -f &quot;$file&quot; &#93;  # Regular file\n&#91; -d &quot;$file&quot; &#93;  # Directory\n&#91; -r &quot;$file&quot; &#93;  # Readable\n&#91; -w &quot;$file&quot; &#93;  # Writable\n&#91; -x &quot;$file&quot; &#93;  # Executable\n</code></pre></p><h3>Multiple Conditions</h3><pre><code class=\"bash\"># AND &#40;both must be true&#41;\nif &#91; $age -ge 18 &#93; &amp;&amp; &#91; $country = &quot;USA&quot; &#93;; then\n    echo &quot;Can vote in USA&quot;\nfi\n\n# OR &#40;either can be true&#41;\nif &#91; $age -lt 13 &#93; || &#91; $age -gt 65 &#93;; then\n    echo &quot;Discounted ticket&quot;\nfi\n\n# NOT\nif &#91; ! -f &quot;$file&quot; &#93;; then\n    echo &quot;File does not exist&quot;\nfi\n</code></pre><h3>elif (else if)</h3><pre><code class=\"bash\">#!/bin/bash\n\nscore=85\n\nif &#91; $score -ge 90 &#93;; then\n    grade=&quot;A&quot;\nelif &#91; $score -ge 80 &#93;; then\n    grade=&quot;B&quot;\nelif &#91; $score -ge 70 &#93;; then\n    grade=&quot;C&quot;\nelse\n    grade=&quot;F&quot;\nfi\n\necho &quot;Grade: $grade&quot;\n</code></pre><h2></h2><h2>Loops</h2><h3>for Loop</h3><p><strong>Iterate over list</strong>:</p><pre><code class=\"bash\">#!/bin/bash\n\n# Loop over words\nfor fruit in apple banana cherry; do\n    echo &quot;I like $fruit&quot;\ndone\n\n# Loop over files\nfor file in &#42;.txt; do\n    echo &quot;Processing $file&quot;\n    wc -l &quot;$file&quot;\ndone\n\n# Loop over numbers &#40;Bash-specific&#41;\nfor i in {1..5}; do\n    echo &quot;Count: $i&quot;\ndone\n</code></pre><p><strong>C-style for loop</strong> (Bash):</p><pre><code class=\"bash\">for &#40;&#40;i=0; i&lt;10; i++&#41;&#41;; do\n    echo &quot;Number: $i&quot;\ndone\n</code></pre><h3>while Loop</h3><p><strong>Repeat while condition true</strong>:</p><pre><code class=\"bash\">#!/bin/bash\n\ncount=1\n\nwhile &#91; $count -le 5 &#93;; do\n    echo &quot;Count: $count&quot;\n    count=$&#40;&#40;count + 1&#41;&#41;\ndone\n</code></pre><p><strong>Read file line by line</strong>:</p><pre><code class=\"bash\">#!/bin/bash\n\nwhile IFS= read -r line; do\n    echo &quot;Line: $line&quot;\ndone &lt; input.txt\n</code></pre><p><strong>Explanation</strong>:</p><ul><li><code>IFS=</code> preserves whitespace</li><li><code>read -r</code> disables backslash escaping</li><li><code>&lt; input.txt</code> redirects file to stdin</li></ul><h3>until Loop</h3><p><strong>Repeat until condition true</strong> (opposite of while):</p><pre><code class=\"bash\">#!/bin/bash\n\ncount=1\n\nuntil &#91; $count -gt 5 &#93;; do\n    echo &quot;Count: $count&quot;\n    count=$&#40;&#40;count + 1&#41;&#41;\ndone\n</code></pre><p><strong>Use case</strong>: Retry until success</p><pre><code class=\"bash\">#!/bin/bash\n\nuntil ping -c 1 example.com &amp;&gt; /dev/null; do\n    echo &quot;Waiting for network...&quot;\n    sleep 1\ndone\n\necho &quot;Network is up!&quot;\n</code></pre><h2></h2><h2>Exit Codes</h2><p><strong>Every command</strong> returns an <strong>exit code</strong>:</p><ul><li><code>0</code> = success</li><li>Non-zero = failure</li></ul><p><strong>Check last exit code</strong>:</p><pre><code class=\"bash\">ls /nonexistent\necho $?  # Prints: 2 &#40;error&#41;\n\nls /home\necho $?  # Prints: 0 &#40;success&#41;\n</code></pre><h3>Using Exit Codes</h3><pre><code class=\"bash\">#!/bin/bash\n\nif grep &quot;ERROR&quot; /var/log/app.log; then\n    echo &quot;Found errors in log&quot;\n    exit 1  # Signal failure\nelse\n    echo &quot;No errors found&quot;\n    exit 0  # Signal success\nfi\n</code></pre><h3>Short-Circuit Operators</h3><p><strong><code>&amp;&amp;</code></strong> = \"and then\" (run if previous succeeded):</p><pre><code class=\"bash\">cd /tmp &amp;&amp; rm tempfile\n# Only runs rm if cd succeeds\n</code></pre><p><strong><code>||</code></strong> = \"or else\" (run if previous failed):</p><pre><code class=\"bash\">mkdir /var/myapp || exit 1\n# Exit if mkdir fails\n</code></pre><p><strong>Combine</strong>:</p><pre><code class=\"bash\">cd /project &amp;&amp; make &amp;&amp; make test &amp;&amp; echo &quot;Success!&quot;\n# Each step must succeed\n</code></pre><h2></h2><h2>Functions</h2><p><strong>Define reusable code</strong>:</p><pre><code class=\"bash\">#!/bin/bash\n\n# Define function\ngreet&#40;&#41; {\n    echo &quot;Hello, $1!&quot;\n}\n\n# Call function\ngreet &quot;Alice&quot;\ngreet &quot;Bob&quot;\n</code></pre><p><strong>With return value</strong>:</p><pre><code class=\"bash\">#!/bin/bash\n\nis&#95;even&#40;&#41; {\n    local num=$1\n    if &#91; $&#40;&#40;num % 2&#41;&#41; -eq 0 &#93;; then\n        return 0  # True &#40;success&#41;\n    else\n        return 1  # False &#40;failure&#41;\n    fi\n}\n\n# Use in conditional\nif is&#95;even 4; then\n    echo &quot;4 is even&quot;\nfi\n\nif is&#95;even 7; then\n    echo &quot;7 is even&quot;\nelse\n    echo &quot;7 is odd&quot;\nfi\n</code></pre><p><strong>Note</strong>: <code>return</code> sets exit code, not value. To return a value, use <code>echo</code>:</p><pre><code class=\"bash\">add&#40;&#41; {\n    echo $&#40;&#40;$1 + $2&#41;&#41;\n}\n\nresult=$&#40;add 3 5&#41;\necho &quot;3 + 5 = $result&quot;\n</code></pre><h2></h2><h2>Error Handling</h2><h3>set -e (Exit on Error)</h3><pre><code class=\"bash\">#!/bin/bash\nset -e  # Exit immediately if any command fails\n\ncd /project\nmake\nmake test\nmake install\n\necho &quot;All steps succeeded!&quot;\n</code></pre><p><strong>Without <code>set -e</code></strong>: Script continues even if <code>make</code> fails!</p><h3>set -u (Error on Undefined Variable)</h3><pre><code class=\"bash\">#!/bin/bash\nset -u  # Exit if using undefined variable\n\necho $UNDEFINED&#95;VAR  # ERROR: unbound variable\n</code></pre><p><strong>Best practice</strong>: Start scripts with:</p><pre><code class=\"bash\">#!/bin/bash\nset -euo pipefail\n</code></pre><p><strong>Explanation</strong>:</p><ul><li><code>-e</code>: Exit on error</li><li><code>-u</code>: Error on undefined variable</li><li><code>-o pipefail</code>: Pipe fails if any command fails</li></ul><h3>trap (Cleanup on Exit)</h3><pre><code class=\"bash\">#!/bin/bash\n\ncleanup&#40;&#41; {\n    echo &quot;Cleaning up...&quot;\n    rm -f /tmp/tempfile\n}\n\ntrap cleanup EXIT  # Run cleanup on exit\n\n# Script continues...\ntouch /tmp/tempfile\n# ... do work ...\n\n# cleanup&#40;&#41; runs automatically on exit &#40;success or failure!&#41;\n</code></pre><h2></h2><h2>Try This</h2><h3>Exercise 1: Backup Script</h3><p><strong>Write a script</strong> that:</p><ul><li>Takes a directory path as argument</li><li>Creates a timestamped backup (tar.gz)</li><li>Stores in <code>&#126;/backups/</code><pre><code class=\"bash\">#!/bin/bash\nset -euo pipefail\n\n# Check argument\nif &#91; $# -ne 1 &#93;; then\n    echo &quot;Usage: $0 &lt;directory&gt;&quot;\n    exit 1\nfi\n\nsource&#95;dir=&quot;$1&quot;\nbackup&#95;dir=&quot;$HOME/backups&quot;\ntimestamp=$&#40;date +%Y%m%d&#95;%H%M%S&#41;\nbackup&#95;file=&quot;$backup&#95;dir/backup&#95;$timestamp.tar.gz&quot;\n\n# Create backup directory\nmkdir -p &quot;$backup&#95;dir&quot;\n\n# Create backup\necho &quot;Backing up $source&#95;dir...&quot;\ntar -czf &quot;$backup&#95;file&quot; &quot;$source&#95;dir&quot;\n\necho &quot;Backup created: $backup&#95;file&quot;\n</code></pre><h2></h2></li></ul><h3>Exercise 2: System Monitor</h3><p><strong>Write a script</strong> that:</p><ul><li>Checks CPU usage</li><li>Checks disk usage</li><li>Checks memory usage</li><li>Alerts if any > 80%<pre><code class=\"bash\">#!/bin/bash\nset -euo pipefail\n\n# Get metrics\ncpu&#95;usage=$&#40;top -bn1 | grep &quot;Cpu&#40;s&#41;&quot; | awk '{print $2}' | cut -d'%' -f1&#41;\ndisk&#95;usage=$&#40;df / | tail -1 | awk '{print $5}' | sed 's/%//'&#41;\nmem&#95;usage=$&#40;free | grep Mem | awk '{printf &quot;%.0f&quot;, $3/$2 &#42; 100}'&#41;\n\necho &quot;CPU: ${cpu&#95;usage}%&quot;\necho &quot;Disk: ${disk&#95;usage}%&quot;\necho &quot;Memory: ${mem&#95;usage}%&quot;\n\n# Check thresholds\nthreshold=80\n\nif &#40;&#40; $&#40;echo &quot;$cpu&#95;usage &gt; $threshold&quot; | bc -l&#41; &#41;&#41;; then\n    echo &quot;WARNING: High CPU usage!&quot;\nfi\n\nif &#91; $disk&#95;usage -gt $threshold &#93;; then\n    echo &quot;WARNING: High disk usage!&quot;\nfi\n\nif &#91; $mem&#95;usage -gt $threshold &#93;; then\n    echo &quot;WARNING: High memory usage!&quot;\nfi\n</code></pre><h2></h2></li></ul><h3>Exercise 3: Batch Rename</h3><p><strong>Write a script</strong> that:</p><ul><li>Renames all <code>.txt</code> files in current directory</li><li>Changes spaces to underscores</li><li>Converts to lowercase<pre><code class=\"bash\">#!/bin/bash\nset -euo pipefail\n\nfor file in &#42;.txt; do\n    # Skip if no files match\n    &#91; -e &quot;$file&quot; &#93; || continue\n    \n    # Transform filename\n    new&#95;name=$&#40;echo &quot;$file&quot; | tr ' ' '&#95;' | tr '&#91;:upper:&#93;' '&#91;:lower:&#93;'&#41;\n    \n    # Rename if different\n    if &#91; &quot;$file&quot; != &quot;$new&#95;name&quot; &#93;; then\n        mv -v &quot;$file&quot; &quot;$new&#95;name&quot;\n    fi\ndone\n\necho &quot;Batch rename complete!&quot;\n</code></pre><h2></h2></li></ul><h2>Best Practices</h2><h3>1. Always Quote Variables</h3><pre><code class=\"bash\"># BAD\ncat $file\n\n# GOOD\ncat &quot;$file&quot;\n</code></pre><p><strong>Why</strong>: Prevents word splitting and globbing.</p><h3>2. Use Meaningful Names</h3><pre><code class=\"bash\"># BAD\nx=10\nf=$1\n\n# GOOD\nmax&#95;retries=10\nconfig&#95;file=$1\n</code></pre><h3>3. Check Arguments</h3><pre><code class=\"bash\">#!/bin/bash\n\nif &#91; $# -lt 1 &#93;; then\n    echo &quot;Usage: $0 &lt;filename&gt;&quot;\n    exit 1\nfi\n\nfile=&quot;$1&quot;\n</code></pre><h3>4. Use <code>set -euo pipefail</code></h3><p><strong>Catch errors early</strong>, don't continue on failure.</p><h3>5. Provide Help</h3><pre><code class=\"bash\">#!/bin/bash\n\nif &#91; &quot;$1&quot; = &quot;-h&quot; &#93; || &#91; &quot;$1&quot; = &quot;--help&quot; &#93;; then\n    cat &lt;&lt; EOF\nUsage: $0 &#91;OPTIONS&#93; &lt;file&gt;\n\nOptions:\n  -h, --help     Show this help\n  -v, --verbose  Verbose output\n\nExamples:\n  $0 myfile.txt\n  $0 -v myfile.txt\nEOF\n    exit 0\nfi\n</code></pre><h3>6. Log Actions</h3><pre><code class=\"bash\">#!/bin/bash\n\nlog&#40;&#41; {\n    echo &quot;&#91;$&#40;date +'%Y-%m-%d %H:%M:%S'&#41;&#93; $&#42;&quot;\n}\n\nlog &quot;Starting backup...&quot;\n# ... do backup ...\nlog &quot;Backup complete!&quot;\n</code></pre><h2></h2><h2>When NOT to Use Shell</h2><p><strong>Shell is great for</strong>:</p><ul><li>System administration</li><li>Gluing tools together</li><li>Quick automation</li><li>Text processing (with sed/awk/grep)</li></ul><p><strong>Shell is bad for</strong>:</p><ul><li>Complex logic (use Python, Ruby, etc.)</li><li>Data structures (arrays of arrays, hash maps)</li><li>Performance-critical code</li><li>Portability (Bash vs sh vs zsh...)</li></ul><p><strong>Rule of thumb</strong>: If script > 100 lines, consider a \"real\" language.<h2></h2></p><h2>Going Deeper</h2><h3>Related Essays</h3><ul><li><strong><a href='/12025-10/9550-command-line-your-primary-interface'>9550: Command Line</a></strong> - Basic shell usage</li><li><strong><a href='/12025-10/9603-shell-text-processing-grep-sed-awk'>9603: Shell Text Processing</a></strong> - grep, sed, awk (Coming Soon!)</li><li><strong><a href='/12025-10/9603-shell-functions-modularity'>9603: Shell Functions</a></strong> - Reusable scripts (Coming Soon!)</li></ul><h3>External Resources</h3><ul><li><strong>\"Classic Shell Scripting\"</strong> - Robbins & Beebe (definitive guide)</li><li><strong>ShellCheck</strong> - <code>shellcheck.net</code> (linter for shell scripts!)</li><li><strong>Bash Guide</strong> - <code>mywiki.wooledge.org/BashGuide</code></li><li><strong>Advanced Bash Scripting Guide</strong> - TLDP<h2></h2></li></ul><h2>Reflection Questions</h2><ol><li><strong>Why prefer shell over Python</strong> for system tasks? (Speed to write, installed everywhere)</li><li><strong>When is quoting critical?</strong> (Filenames with spaces, preventing injection attacks)</li><li><strong>Why <code>set -e</code> controversial?</strong> (Some argue it hides errors in conditionals—use carefully!)</li><li><strong>Should shell scripts have tests?</strong> (YES! Use BATS or shUnit2)</li><li><strong>How does shell relate to Nock?</strong> (Both are minimal, composable—shell glues Unix, Nock specifies computation!)<h2></h2></li></ol><h2>Summary</h2><p><strong>Shell scripting is</strong>:</p><ul><li><strong>Automation</strong> (deploy, backup, monitor)</li><li><strong>Composition</strong> (combine simple tools)</li><li><strong>Speed</strong> (prototype in minutes)</li><li><strong>Universal</strong> (every Unix system has a shell)</li></ul><p><strong>Core concepts</strong>:</p><ul><li><strong>Variables</strong>: <code>name=&quot;value&quot;</code>, always quote: <code>&quot;$name&quot;</code></li><li><strong>Conditionals</strong>: <code>if &#91; condition &#93;; then ... fi</code></li><li><strong>Loops</strong>: <code>for item in list; do ... done</code>, <code>while &#91; condition &#93;; do ... done</code></li><li><strong>Exit codes</strong>: <code>0</code> = success, <code>$?</code> = last exit code</li><li><strong>Functions</strong>: Reusable code blocks</li><li><strong>Error handling</strong>: <code>set -euo pipefail</code>, <code>trap cleanup EXIT</code></li></ul><p><strong>Best practices</strong>:</p><ul><li>Quote variables</li><li>Check arguments</li><li>Use meaningful names</li><li>Provide help (<code>-h</code>)</li><li>Log actions</li><li>Exit on error (<code>set -e</code>)</li></ul><p><strong>When to use</strong>:</p><ul><li>System administration ✅</li><li>Quick automation ✅</li><li>Text processing ✅</li><li>Complex logic ❌ (use Python/Ruby/etc.)</li></ul><p><strong>In the Valley</strong>:</p><ul><li><strong>Shell is glue</strong> (combines tools, like Unix philosophy!)</li><li><strong>Simple, composable</strong> (relates to Nock, functional programming)</li><li><strong>Ecological lens</strong>: \"Shell scripts are the mycelium network—connecting distinct organisms (tools) into a functioning ecosystem.\"<h2></h2></li></ul><p><strong>Next</strong>: <strong>Essay 9603 - Shell Text Processing!</strong> We'll master <code>grep</code>, <code>sed</code>, and <code>awk</code>—the power trio for text manipulation!<h2></h2></p><p><strong>Navigation</strong>:<br /> ← Previous: <a href='/12025-10/9600-phase-1-synthesis-foundations-laid'>9600 (Phase 1 Synthesis)</a> | <strong>Phase 2 Index</strong> | Next: <a href='/12025-10/9603-shell-text-processing-grep-sed-awk'>9603 (Shell Text Processing)</a> <em>(New!)</em></p><p><strong>Metadata</strong>:</p><ul><li><strong>Phase</strong>: 2 (Core Systems & Tools)</li><li><strong>Week</strong>: 6 (Shell Scripting)</li><li><strong>Prerequisites</strong>: 9550, 9560, 9570</li><li><strong>Concepts</strong>: Variables, quoting, conditionals, loops, exit codes, functions, error handling</li><li><strong>Next Concepts</strong>: grep, sed, awk, text processing pipelines</li><li><strong>Plant Lens</strong>: Shell scripts as mycelium (connecting ecosystem), glue for composition</li><li><strong>Hands-On</strong>: 3 exercises (backup, monitor, batch rename)</li></ul><h2></h2><p><div style=\"text-align: center; opacity: 0.6; font-size: 0.85em; margin-top: 3em; padding-top: 1em; border-top: 1px solid rgba(139, 116, 94, 0.2);\"></p><p><strong>Copyright © 2025 <a href='https://codeberg.org/kae3g/12025-10/'>kae3g</a></strong> | Dual-licensed under <a href='https://www.apache.org/licenses/LICENSE-2.0'>Apache-2.0</a> / <a href='https://opensource.org/licenses/MIT'>MIT</a><br /> Competitive technology in service of clarity and beauty</p><p></div></p><p><em><a href='/12025-10/hidden-docs-index.html'>View Hidden Docs Index</a></em> | <em><a href='/12025-10/'>Return to Main Index</a></em></p>",
  "hash" : "2025-10-22T15:17:39.429725129Z-15284"
}