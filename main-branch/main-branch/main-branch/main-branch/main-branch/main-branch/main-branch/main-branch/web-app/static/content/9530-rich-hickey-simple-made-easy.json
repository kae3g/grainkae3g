{
  "slug" : "9530-rich-hickey-simple-made-easy",
  "meta" : {
    "slug" : "9530-rich-hickey-simple-made-easy",
    "title" : "kae3g 9530: Rich Hickey's \"Simple Made Easy\" - A Design Philosophy",
    "filename" : "9530-rich-hickey-simple-made-easy.md",
    "source-dir" : "hidden"
  },
  "html" : "<h1>kae3g 9530: Rich Hickey's \"Simple Made Easy\" - A Design Philosophy</h1><p><strong>Phase 1: Foundations & Philosophy</strong> | <strong>Week 2</strong> | <strong>Reading Time: 18 minutes</strong><h2></h2></p><h2>What You'll Learn</h2><ul><li>The crucial distinction: Simple vs Easy</li><li>Why we confuse familiarity with simplicity</li><li>Complecting: when things are intertwined (and why that's bad)</li><li>How to identify complexity in systems</li><li>Practical strategies for achieving simplicity</li><li>Why simplicity is a prerequisite for reliability</li><li>How this philosophy guides Clojure, Nix, and valley thinking<h2></h2></li></ul><h2>Prerequisites</h2><ul><li><strong><a href='/12025-10/9504-what-is-clojure'>9504: What Is Clojure?</a></strong> - Rich Hickey's language</li><li><strong><a href='/12025-10/9510-unix-philosophy-do-one-thing-well'>9510: Unix Philosophy</a></strong> - Do one thing well</li><li><strong><a href='/12025-10/9520-functional-programming-basics'>9520: Functional Programming</a></strong> - Pure functions, immutability<h2></h2></li></ul><h2>The Talk That Changed How We Think</h2><p>In <strong>2011</strong>, at Strange Loop conference, <strong>Rich Hickey</strong> gave a talk: <a href='https://www.infoq.com/presentations/Simple-Made-Easy/'>\"Simple Made Easy\"</a>.</p><p><strong>Impact</strong>:</p><ul><li>1.5 million+ views (still growing)</li><li>Referenced in thousands of tech discussions</li><li>Changed how an entire generation thinks about design</li><li><strong>Required viewing</strong> in many engineering teams</li></ul><p><strong>Why it matters</strong>: Hickey <strong>named</strong> something we all felt but couldn't articulate.</p><p>Let's unpack it.<h2></h2></p><h2>The Core Distinction</h2><h3>Simple (from <em>simplex</em> - \"one fold\")</h3><p><strong>Definition</strong>: Not intertwined. One role. One task. One concept. One dimension.</p><p><strong>Objective</strong>: You can <strong>measure</strong> simplicity (count the braids, count the dependencies).</p><p><strong>Examples</strong>:</p><ul><li>A function that adds two numbers: <strong>simple</strong> (one task)</li><li>A rope with separate strands: <strong>simple</strong> (not braided)</li><li>A wheel: <strong>simple</strong> (rotates, that's all)</li></ul><p><strong>Non-examples</strong>:</p><ul><li>A function that adds numbers AND logs to database AND sends email: <strong>not simple</strong> (three tasks braided)</li><li>A rope braided with wire and rubber: <strong>not simple</strong> (intertwined)</li><li>A Swiss Army knife: <strong>not simple</strong> (20 tools in one object)</li></ul><h3>Easy (from <em>adjacens</em> - \"near at hand\")</h3><p><strong>Definition</strong>: Familiar. Near to our current understanding. Close at hand.</p><p><strong>Subjective</strong>: What's easy for you might be hard for me (depends on experience).</p><p><strong>Examples</strong>:</p><ul><li>Python: <strong>easy</strong> for most programmers (familiar syntax, lots of tutorials)</li><li>Spanish: <strong>easy</strong> for English speakers (similar alphabet, shared vocabulary)</li><li>Driving: <strong>easy</strong> after you've done it for years</li></ul><p><strong>Non-examples</strong> (for most people):</p><ul><li>Haskell: <strong>not easy</strong> (unfamiliar paradigm, weird syntax)</li><li>Chinese: <strong>not easy</strong> for English speakers (different writing system, tones)</li><li>Unicycling: <strong>not easy</strong> (requires practice, balance)<h2></h2></li></ul><h2>The Confusion</h2><p><strong>We habitually confuse easy with simple.</strong></p><p><strong>Example</strong>: \"JavaScript is simple!\"</p><p><strong>Actually</strong>: JavaScript is <strong>easy</strong> (familiar, tons of resources), but <strong>not simple</strong> (complex scoping rules, <code>this</code> binding, coercion rules, prototype chains, async/await + promises + callbacks...).</p><p><strong>Example</strong>: \"Nix is complex!\"</p><p><strong>Actually</strong>: Nix is <strong>simple</strong> (pure functions, no hidden state, deterministic), but <strong>not easy</strong> (unfamiliar paradigm, steep learning curve).</p><p><strong>The trap</strong>:</p><pre><code>&quot;This tool is easy to get started with!&quot; \n    ↓\n&quot;I'll use it for my project.&quot;\n    ↓\n&quot;Wait, why is this so complicated now?&quot; \n    ↓\n&#40;It was easy, not simple—complexity appears later&#41;\n</code></pre><p><strong>Better</strong>:</p><pre><code>&quot;This tool is unfamiliar &#40;not easy&#41;.&quot;\n    ↓\n&quot;But it's simple &#40;not intertwined&#41;.&quot;\n    ↓\n&quot;I'll invest time to learn it.&quot;\n    ↓\n&quot;Now it's both simple AND easy &#40;to me&#41;!&quot;\n</code></pre><p><strong>Hickey's point</strong>: <strong>Prefer simple over easy.</strong> Easy is temporary (until complexity emerges). Simple is structural.<h2></h2></p><h2>Complecting: The Root of Complexity</h2><p><strong>Complect</strong> (from <em>complectere</em> - \"to braid together\"):</p><blockquote><p> <strong>To intertwine, entwine, braid together.</strong> </p></blockquote><p><strong>Simple</strong>: Separate strands (can reason about each independently).<br /> <strong>Complex</strong>: Braided strands (must understand all to understand any).</p><h3>Code Example: Complected</h3><pre><code class=\"python\">class UserManager:\n    def &#95;&#95;init&#95;&#95;&#40;self&#41;:\n        self.users = &#91;&#93;  # State\n        self.db = Database&#40;&#41;  # Database\n        self.logger = Logger&#40;&#41;  # Logging\n        self.emailer = Emailer&#40;&#41;  # Email\n    \n    def add&#95;user&#40;self, name, email&#41;:\n        # Complected! Four concerns braided:\n        user = {&quot;name&quot;: name, &quot;email&quot;: email}\n        self.users.append&#40;user&#41;  # State management\n        self.db.insert&#40;user&#41;  # Persistence\n        self.logger.log&#40;f&quot;Added {name}&quot;&#41;  # Logging\n        self.emailer.send&#40;email, &quot;Welcome!&quot;&#41;  # Email\n</code></pre><p><strong>What's complected?</strong></p><ul><li>State management + database + logging + email</li><li>Can't test <code>add&#95;user</code> without all four systems</li><li>Can't replace logger without modifying UserManager</li><li>Can't understand one without understanding all</li></ul><h3>Code Example: Decomplected</h3><pre><code class=\"clojure\">;; Separate concerns &#40;loosely coupled&#41;\n\n&#40;defn add-user &#91;users user&#93;\n  &#40;conj users user&#41;&#41;  ; Just data transformation\n\n&#40;defn persist-user &#91;db user&#93;\n  &#40;insert db user&#41;&#41;  ; Just persistence\n\n&#40;defn log-event &#91;logger event&#93;\n  &#40;write-log logger event&#41;&#41;  ; Just logging\n\n&#40;defn send-welcome &#91;emailer email&#93;\n  &#40;send-email emailer email &quot;Welcome!&quot;&#41;&#41;  ; Just email\n\n;; Compose at call site:\n&#40;defn onboard-user &#91;systems user&#93;\n  &#40;let &#91;users' &#40;add-user &#40;:users systems&#41; user&#41;&#93;\n    &#40;persist-user &#40;:db systems&#41; user&#41;\n    &#40;log-event &#40;:logger systems&#41; {:type :user-added :user user}&#41;\n    &#40;send-welcome &#40;:emailer systems&#41; &#40;:email user&#41;&#41;\n    &#40;assoc systems :users users'&#41;&#41;&#41;\n</code></pre><p><strong>What's decomplected?</strong></p><ul><li>Each function has <strong>one</strong> responsibility</li><li>Can test each independently (pass mock data)</li><li>Can replace any subsystem without changing others</li><li>Can reason about each function in isolation</li></ul><p><strong>Trade-off</strong>: More functions (looks like more code). But each function is <strong>simple</strong> (easier to understand, test, modify).<h2></h2></p><h2>Constructs vs Artifacts</h2><p><strong>Hickey distinguishes</strong>:</p><h3>Constructs (Things we make)</h3><p><strong>We can choose</strong> how to construct our systems.</p><p><strong>Simple constructs</strong>:</p><ul><li><strong>Values</strong> (immutable data)</li><li><strong>Functions</strong> (inputs → output, no side effects)</li><li><strong>Namespaces</strong> (organize code by purpose)</li><li><strong>Data</strong> (maps, vectors, sets—generic structures)</li><li><strong>Queues</strong> (decouple producer from consumer)</li></ul><p><strong>Complex constructs</strong> (complected):</p><ul><li><strong>State</strong> (intertwines value with time)</li><li><strong>Objects</strong> (intertwine data with methods)</li><li><strong>Inheritance</strong> (intertwines parent with child)</li><li><strong>Syntax</strong> (intertwines meaning with representation)</li><li><strong>Loops</strong> (intertwine iteration with operation)</li></ul><h3>Artifacts (Things we use)</h3><p><strong>We're stuck with</strong> some complexity (can't eliminate):</p><ul><li><strong>Computers</strong> (layers of abstraction, hardware quirks)</li><li><strong>Networks</strong> (latency, packet loss, partitions)</li><li><strong>Users</strong> (varied needs, edge cases)</li><li><strong>Time</strong> (things change, state must be managed)</li></ul><p><strong>But</strong>: We can <strong>isolate</strong> artifact complexity. Build simple constructs that <strong>manage</strong> complex artifacts.</p><p><strong>Example</strong>:</p><ul><li><strong>Artifact</strong>: Network is unreliable (packets drop)</li><li><strong>Simple construct</strong>: Retry logic (isolated, testable)</li><li><strong>Complex approach</strong>: Tangle retry with business logic (not testable, not reusable)<h2></h2></li></ul><h2>Dimensions of Simplicity/Complexity</h2><p><strong>Hickey identifies</strong> complecting dimensions:</p><table><thead><tr><th>Dimension</th><th>Simple</th><th>Complex (Complected)</th></tr></thead><tbody><tr><td><strong>State</strong></td><td>Values (immutable)</td><td>Variables (mutation braided with logic)</td></tr><tr><td><strong>Order</strong></td><td>Queues, declarative</td><td>Imperative sequences (step 1 must happen before step 2)</td></tr><tr><td><strong>Time</strong></td><td>Functions (timeless)</td><td>Objects (state changes over time)</td></tr><tr><td><strong>Identity</strong></td><td>Explicit references</td><td>Hidden in <code>this</code> pointers</td></tr><tr><td><strong>Modules</strong></td><td>Namespaces/packages</td><td>Objects (braid structure with behavior)</td></tr><tr><td><strong>Logic</strong></td><td>Rules, pure functions</td><td>Conditionals scattered throughout code</td></tr><tr><td><strong>Data</strong></td><td>Generic structures (maps, lists)</td><td>Classes (specific to one use case)</td></tr></tbody></table><p><strong>Design strategy</strong>: For each dimension, <strong>choose the simple option</strong> unless complexity is <strong>essential</strong> (rare!).<h2></h2></p><h2>Testing Simplicity</h2><p><strong>How to know if something is simple?</strong></p><h3>The Questions</h3><p><strong>1. Can you change one thing without changing another?</strong></p><pre><code class=\"clojure\">;; Simple: change validation without changing persistence\n&#40;defn validate &#91;user&#93; ...&#41;  ; Independent\n&#40;defn persist &#91;user&#93; ...&#41;   ; Independent\n\n;; Complex: changing validation requires changing UserManager class\nclass UserManager {\n  validate&#40;&#41; { ... }\n  persist&#40;&#41; { ... }  // Tangled with validate via shared state\n}\n</code></pre><p><strong>2. Can you understand one part without understanding the whole?</strong></p><pre><code class=\"bash\"># Simple: understand grep without understanding sort\ngrep &quot;error&quot; | sort\n\n# Complex: understand method A requires understanding entire class hierarchy\nclass.methodA&#40;&#41;  # Calls super.methodB&#40;&#41;, which calls this.methodC&#40;&#41;...\n</code></pre><p><strong>3. Can you test one part independently?</strong></p><pre><code class=\"clojure\">;; Simple: test each function alone\n&#40;= &#40;add 2 3&#41; 5&#41;  ; No setup needed\n\n;; Complex: test requires mocking entire system\nUserManager.add&#95;user&#40;&quot;Alice&quot;&#41;  \n; Needs: mock DB, mock logger, mock emailer, setup state...\n</code></pre><p><strong>If the answer is \"no\" to any</strong>: You have complecting. Refactor to separate concerns.<h2></h2></p><h2>Achieving Simplicity</h2><p><strong>Hickey's strategies</strong>:</p><h3>1. Choose Simple Constructs</h3><p><strong>Prefer</strong>:</p><ul><li><strong>Immutable data</strong> over mutable objects</li><li><strong>Pure functions</strong> over methods with side effects</li><li><strong>Data</strong> over classes</li><li><strong>Queues</strong> over locks</li><li><strong>Declarative</strong> over imperative</li></ul><p><strong>Example</strong>:<pre><code class=\"clojure\">;; Simple construct: pure function\n&#40;defn calculate-tax &#91;income&#93;\n  &#40;&#42; income 0.25&#41;&#41;\n\n;; Complex construct: stateful object\nclass TaxCalculator {\n  private config;  // State!\n  private history; // State!\n  \n  calculateTax&#40;income&#41; {\n    this.history.push&#40;income&#41;;  // Side effect!\n    return income &#42; this.config.rate;\n  }\n}\n</code></pre></p><h3>2. Abstract with Data</h3><p><strong>Don't create a class for everything.</strong> Use generic data structures:</p><pre><code class=\"clojure\">;; Good: use maps\n&#40;def user {:name &quot;Alice&quot; :age 30 :role :admin}&#41;\n&#40;def product {:name &quot;Widget&quot; :price 10 :stock 100}&#41;\n\n;; Both are maps—same operations work on both!\n&#40;:name user&#41;     ; =&gt; &quot;Alice&quot;\n&#40;:name product&#41;  ; =&gt; &quot;Widget&quot;\n\n;; Bad: create classes &#40;each needs unique methods&#41;\nclass User { getName&#40;&#41; {...} getAge&#40;&#41; {...} }\nclass Product { getName&#40;&#41; {...} getPrice&#40;&#41; {...} }\n</code></pre><p><strong>Benefits of data</strong>:</p><ul><li><strong>Generic operations</strong> (get, assoc, dissoc work on all maps)</li><li><strong>Easy serialization</strong> (it's already data!)</li><li><strong>Composable</strong> (merge maps, nest them, transform them)</li></ul><h3>3. Separate Policy from Mechanism</h3><p><strong>Mechanism</strong>: How something works.<br /> <strong>Policy</strong>: What it should do.</p><p><strong>Example</strong>:<pre><code class=\"clojure\">;; Mechanism: generic validation function\n&#40;defn validate &#91;rules data&#93;\n  &#40;every? &#40;fn &#91;&#91;key rule&#93;&#93; &#40;rule &#40;get data key&#41;&#41;&#41; rules&#41;&#41;\n\n;; Policy: specific rules for users\n&#40;def user-rules\n  {:age #&#40;&gt;= % 18&#41;\n   :email #&#40;re-matches #&quot;.+@.+\\..+&quot; %&#41;}&#41;\n\n;; Compose:\n&#40;validate user-rules {:age 30 :email &quot;alice@example.com&quot;}&#41;\n</code></pre></p><p><strong>Mechanism</strong> (validate) is reusable. <strong>Policy</strong> (user-rules) is configurable.</p><p><strong>Not complected</strong>: Can change policy without changing mechanism.<h2></h2></p><h2>Real-World Examples</h2><h3>Example 1: Simple vs Complex Build Systems</h3><p><strong>Complex</strong> (Maven):<pre><code class=\"xml\">&lt;!-- pom.xml: 200 lines of XML --&gt;\n&lt;project&gt;\n  &lt;build&gt;\n    &lt;plugins&gt;\n      &lt;plugin&gt;\n        &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n        &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n        &lt;configuration&gt;\n          &lt;source&gt;11&lt;/source&gt;\n          &lt;target&gt;11&lt;/target&gt;\n        &lt;/configuration&gt;\n      &lt;/plugin&gt;\n    &lt;/plugins&gt;\n  &lt;/build&gt;\n  &lt;dependencies&gt;\n    &lt;!-- Another 100 lines --&gt;\n  &lt;/dependencies&gt;\n&lt;/project&gt;\n</code></pre></p><p><strong>What's complected?</strong></p><ul><li>Build configuration + dependency management + plugin lifecycle</li><li>Imperative phases (validate, compile, test, package)</li><li>XML (syntax) + Maven concepts (semantics)</li></ul><p><strong>Simple</strong> (Nix):<pre><code class=\"nix\">{ stdenv, jdk11 }:\n\nstdenv.mkDerivation {\n  name = &quot;my-app&quot;;\n  src = ./.;\n  buildInputs = &#91; jdk11 &#93;;\n  buildPhase = &quot;javac &#42;.java&quot;;\n}\n</code></pre></p><p><strong>What's simple?</strong></p><ul><li>Pure function (inputs → output, deterministic)</li><li>Declarative (say what, not how)</li><li>Minimal DSL (just attribute sets and functions)</li></ul><p><strong>Trade-off</strong>: Nix is <strong>not easy</strong> (unfamiliar). But it's <strong>simple</strong> (not complected).</p><h3>Example 2: Simple vs Complex State Management</h3><p><strong>Complex</strong> (React with classes, pre-hooks):<pre><code class=\"javascript\">class Counter extends React.Component {\n  constructor&#40;props&#41; {\n    super&#40;props&#41;;\n    this.state = { count: 0 };  // State\n    this.increment = this.increment.bind&#40;this&#41;;  // Binding!\n  }\n  \n  increment&#40;&#41; {\n    this.setState&#40;{ count: this.state.count + 1 }&#41;;  // Mutation!\n  }\n  \n  render&#40;&#41; {\n    return &lt;button onClick={this.increment}&gt;{this.state.count}&lt;/button&gt;;\n  }\n}\n</code></pre></p><p><strong>What's complected?</strong></p><ul><li>State + behavior + rendering</li><li><code>this</code> binding (implicit context)</li><li>Lifecycle methods (componentDidMount, etc.)</li></ul><p><strong>Simple</strong> (React with hooks):<pre><code class=\"javascript\">function Counter&#40;&#41; {\n  const &#91;count, setCount&#93; = useState&#40;0&#41;;\n  \n  return &lt;button onClick={&#40;&#41; =&gt; setCount&#40;count + 1&#41;}&gt;{count}&lt;/button&gt;;\n}\n</code></pre></p><p><strong>What's simple?</strong></p><ul><li>State isolated (useState hook)</li><li>Function (no class, no <code>this</code>)</li><li>Declarative (say what you want, not how to construct it)</li></ul><p><strong>Even simpler</strong> (Svelte):<pre><code class=\"svelte\">&lt;script&gt;\n  let count = 0;\n&lt;/script&gt;\n\n&lt;button on:click={&#40;&#41; =&gt; count += 1}&gt;{count}&lt;/button&gt;\n</code></pre></p><p><strong>Simplest</strong>: No framework ceremony. Just reactive variables.<h2></h2></p><h2>The Benefits of Simplicity</h2><h3>1. Easier to Understand</h3><p><strong>Simple code</strong>: Read one function, understand it.</p><pre><code class=\"clojure\">&#40;defn average &#91;numbers&#93;\n  &#40;/ &#40;reduce + numbers&#41;\n     &#40;count numbers&#41;&#41;&#41;\n</code></pre><p><strong>One concept</strong>: Sum divided by count. Done.</p><p><strong>Complex code</strong>: Read one method, must understand entire class.</p><pre><code class=\"java\">class Statistics {\n  private List&lt;Double&gt; data;\n  private boolean sorted = false;\n  \n  public double average&#40;&#41; {\n    if &#40;!sorted&#41; sort&#40;&#41;;  // Side effect!\n    // ... more braiding ...\n  }\n}\n</code></pre><p><strong>Intertwined</strong>: Average depends on sorted state, which depends on data, which might be modified by other methods...</p><h3>2. Easier to Test</h3><p><strong>Simple</strong>:<pre><code class=\"clojure\">&#40;deftest test-average\n  &#40;is &#40;= &#40;average &#91;1 2 3&#93;&#41; 2&#41;&#41;&#41;\n\n;; No setup, no mocking, just call it\n</code></pre></p><p><strong>Complex</strong>:<pre><code class=\"java\">@Test\npublic void testAverage&#40;&#41; {\n  Statistics stats = new Statistics&#40;&#41;;\n  stats.add&#40;1&#41;;\n  stats.add&#40;2&#41;;\n  stats.add&#40;3&#41;;\n  assertEquals&#40;2.0, stats.average&#40;&#41;, 0.001&#41;;\n}\n\n// Setup required, state management, potential for test pollution\n</code></pre></p><h3>3. Easier to Change</h3><p><strong>Simple</strong>: Change one strand, others unaffected.</p><pre><code class=\"clojure\">;; Change validation &#40;doesn't affect persistence&#41;\n&#40;defn validate &#91;user&#93;\n  &#40;and &#40;&gt;= &#40;:age user&#41; 18&#41;\n       &#40;.contains &#40;:email user&#41; &quot;@&quot;&#41;&#41;&#41;  ; Added email check\n\n;; Persistence unchanged:\n&#40;defn persist &#91;db user&#93;\n  &#40;insert db user&#41;&#41;\n</code></pre><p><strong>Complex</strong>: Change one thing, break another.</p><pre><code class=\"python\">class UserManager:\n    def add&#95;user&#40;self, name, email&#41;:\n        # Validation braided with persistence\n        if len&#40;name&#41; &lt; 3:  # Change this...\n            raise ValueError\n        self.db.insert&#40;{&quot;name&quot;: name, &quot;email&quot;: email}&#41;  # ...might break this\n</code></pre><h3>4. More Reliable</h3><p><strong>Dijkstra</strong>:<blockquote><p> \"Simplicity is prerequisite for reliability.\"  </p></blockquote><strong>Why?</strong></p><ul><li><strong>Fewer interactions</strong> = fewer edge cases</li><li><strong>Isolated components</strong> = easier to verify each</li><li><strong>No hidden state</strong> = reproducible behavior</li></ul><p><strong>Real-world</strong>: seL4 microkernel (Essay 9954) is <strong>formally verified</strong> because it's <strong>simple enough</strong> to prove correct (~10,000 lines).</p><p>Linux kernel (28 million lines): <strong>impossible</strong> to formally verify (too complex, too many interactions).<h2></h2></p><h2>Identifying Complexity in Your Code</h2><h3>Warning Signs</h3><p><strong>1. \"To understand this, you need to know...\"</strong></p><p>If explaining one function requires explaining five others: <strong>complected</strong>.</p><p><strong>2. \"This depends on global state X\"</strong></p><p>Global state braids all code that touches it.</p><p><strong>3. \"You can't change this without changing that\"</strong></p><p>Tight coupling = complecting.</p><p><strong>4. \"The tests are really complicated\"</strong></p><p>Tests reflect complexity. Simple code = simple tests.</p><p><strong>5. \"I'm not sure what will happen if...\"</strong></p><p>Intertwined behavior = unpredictable emergence.</p><h3>Refactoring Strategy</h3><p><strong>When you find complecting</strong>:</p><ol><li><strong>Identify the braids</strong>: What concerns are intertwined?</li><li><strong>Separate them</strong>: Create functions for each concern</li><li><strong>Compose explicitly</strong>: Make dependencies visible at call site</li><li><strong>Test independently</strong>: Each function should be testable alone</li></ol><p><strong>Example refactor</strong>:</p><pre><code class=\"python\"># Before &#40;complected&#41;\ndef process&#95;order&#40;order&#41;:\n    validate&#40;order&#41;  # Raises exception on error\n    charge&#95;card&#40;order.card&#41;  # Side effect!\n    update&#95;inventory&#40;order.items&#41;  # Side effect!\n    send&#95;email&#40;order.email&#41;  # Side effect!\n    return order\n\n# After &#40;decomplected&#41;\ndef validate&#95;order&#40;order&#41;:\n    return errors if invalid else None\n\ndef process&#95;order&#40;order&#41;:\n    # Make dependencies explicit, handle errors explicitly\n    errors = validate&#95;order&#40;order&#41;\n    if errors:\n        return {:status :invalid :errors errors}\n    \n    charge&#95;result = charge&#95;card&#40;order.card&#41;\n    inventory&#95;result = update&#95;inventory&#40;order.items&#41;\n    email&#95;result = send&#95;email&#40;order.email&#41;\n    \n    return {:status :success\n            :charge charge&#95;result\n            :inventory inventory&#95;result\n            :email email&#95;result}\n</code></pre><p><strong>Now</strong>:</p><ul><li>Each concern is <strong>separate</strong></li><li>Errors are <strong>values</strong> (not exceptions braiding control flow)</li><li>Side effects are <strong>explicit</strong> (you see every one)</li><li>Testable (mock each subsystem independently)<h2></h2></li></ul><h2>Simple Made Easy (Over Time)</h2><p><strong>Hickey's crucial insight</strong>:</p><blockquote><p> <strong>What's unfamiliar (not easy) can become familiar (easy) through learning.</strong> </p><p> <strong>What's complex (complected) doesn't become simple through familiarity.</strong> </p></blockquote><p><strong>Example</strong>:</p><p><strong>Year 0</strong>: Haskell is <strong>not easy</strong> (unfamiliar) and <strong>simple</strong> (pure functions, no mutation).</p><p><strong>Year 1</strong>: Haskell is <strong>easier</strong> (you've learned it) and still <strong>simple</strong>.</p><p><strong>vs</strong></p><p><strong>Year 0</strong>: Java is <strong>easy</strong> (familiar) and <strong>complex</strong> (OOP, inheritance, mutable state).</p><p><strong>Year 1</strong>: Java is still <strong>easy</strong> (familiar) but <strong>complex</strong> (familiarity didn't fix the braiding).</p><p><strong>Conclusion</strong>: <strong>Invest in learning simple tools.</strong> The difficulty is temporary. The simplicity is permanent.<h2></h2></p><h2>Simplicity in the Valley</h2><p><strong>How we apply this</strong>:</p><h3>1. Prefer Immutability</h3><p><strong>Mutable state complects</strong> value with time.</p><pre><code class=\"clojure\">;; Simple: values don't change\n&#40;def v1 {:count 0}&#41;\n&#40;def v2 &#40;assoc v1 :count 1&#41;&#41;\n\n;; v1 and v2 coexist &#40;no timeline complexity&#41;\n</code></pre><h3>2. Pure Functions</h3><p><strong>Side effects complect</strong> logic with environment.</p><pre><code class=\"clojure\">;; Simple: no side effects\n&#40;defn calculate-total &#91;items&#93;\n  &#40;reduce + &#40;map :price items&#41;&#41;&#41;\n\n;; Complex: side effects braided with logic\n&#40;defn calculate-and-log-total &#91;items&#93;\n  &#40;let &#91;total &#40;reduce + &#40;map :price items&#41;&#41;&#93;\n    &#40;log &quot;Total: &quot; total&#41;  ; Side effect!\n    total&#41;&#41;\n</code></pre><p><strong>Refactor</strong>: Separate calculation from logging.</p><h3>3. Data Orientation</h3><p><strong>Objects complect</strong> data with behavior.</p><pre><code class=\"clojure\">;; Simple: data + functions\n&#40;def user {:name &quot;Alice&quot; :age 30}&#41;\n&#40;defn adult? &#91;user&#93; &#40;&gt;= &#40;:age user&#41; 18&#41;&#41;\n\n;; Complex: data braided with methods\nclass User {\n  private age;\n  public boolean isAdult&#40;&#41; { return age &gt;= 18; }\n}\n</code></pre><h3>4. Explicit Over Implicit</h3><p><strong>Implicit dependencies complect</strong> code with hidden context.</p><pre><code class=\"clojure\">;; Simple: explicit\n&#40;defn process &#91;db config user&#93;\n  ...&#41;  ; Dependencies visible in signature\n\n;; Complex: implicit\n&#40;defn process &#91;user&#93;\n  ... &#40;use global-db&#41; ...  ; Where did this come from?\n  ... &#40;use global-config&#41; ...\n  &#41;\n</code></pre><h2></h2><h2>Practical Exercises</h2><h3>Exercise 1: Identify Complecting</h3><p><strong>Review code you've written.</strong> Find examples of:</p><ul><li><strong>State + logic</strong> (object methods modifying object state)</li><li><strong>Validation + transformation</strong> (one function doing two jobs)</li><li><strong>Error handling + business logic</strong> (try/catch mixed with logic)</li><li><strong>Configuration + execution</strong> (reading config file inside processing function)</li></ul><p><strong>For each</strong>: How would you <strong>separate</strong> them?<h2></h2></p><h3>Exercise 2: Braid Count</h3><p><strong>Take a function</strong>. Count how many concerns it handles:</p><pre><code class=\"python\">def process&#95;user&#40;name, email&#41;:\n    # 1. Validation\n    if len&#40;name&#41; &lt; 3:\n        raise ValueError\n    \n    # 2. Transformation\n    user = {&quot;name&quot;: name.upper&#40;&#41;, &quot;email&quot;: email.lower&#40;&#41;}\n    \n    # 3. Persistence\n    db.insert&#40;user&#41;\n    \n    # 4. Logging\n    log.info&#40;f&quot;Added {name}&quot;&#41;\n    \n    # 5. Notification\n    send&#95;email&#40;email, &quot;Welcome!&quot;&#41;\n    \n    return user\n</code></pre><p><strong>Count</strong>: 5 concerns (validation, transformation, persistence, logging, notification).</p><p><strong>Braid count</strong>: 5.</p><p><strong>Target</strong>: 1 concern per function (braid count = 1).<h2></h2></p><h3>Exercise 3: Decomplect Something</h3><p><strong>Take a complected function</strong> (braid count > 1).</p><p><strong>Refactor</strong> to separate functions:</p><pre><code class=\"clojure\">&#40;defn validate-user &#91;user&#93; ...&#41;\n&#40;defn normalize-user &#91;user&#93; ...&#41;\n&#40;defn persist-user &#91;db user&#93; ...&#41;\n&#40;defn log-user-added &#91;logger user&#93; ...&#41;\n&#40;defn send-welcome-email &#91;emailer email&#93; ...&#41;\n\n;; Compose at call site\n&#40;defn onboard-user &#91;systems user&#93;\n  &#40;when-let &#91;errors &#40;validate-user user&#41;&#93;\n    &#40;return {:status :error :errors errors}&#41;&#41;\n  \n  &#40;let &#91;normalized &#40;normalize-user user&#41;&#93;\n    &#40;persist-user &#40;:db systems&#41; normalized&#41;\n    &#40;log-user-added &#40;:logger systems&#41; normalized&#41;\n    &#40;send-welcome-email &#40;:emailer systems&#41; &#40;:email normalized&#41;&#41;\n    {:status :success :user normalized}&#41;&#41;\n</code></pre><p><strong>Result</strong>: Each concern is <strong>isolated</strong>. All dependencies <strong>explicit</strong>.<h2></h2></p><h2>The Simplicity Toolkit</h2><p><strong>Hickey recommends</strong> specific simple constructs:</p><h3>For State</h3><p><strong>Don't</strong>: Mutable variables everywhere<br /> <strong>Do</strong>: Managed references (Clojure atoms, refs)</p><pre><code class=\"clojure\">;; Explicit state management\n&#40;def app-state &#40;atom {:users &#91;&#93; :products &#91;&#93;}&#41;&#41;\n\n;; Changes are explicit\n&#40;swap! app-state update :users conj new-user&#41;\n</code></pre><h3>For Polymorphism</h3><p><strong>Don't</strong>: Inheritance hierarchies (complex!)<br /> <strong>Do</strong>: Protocols/interfaces (simple)</p><pre><code class=\"clojure\">;; Define interface &#40;simple&#41;\n&#40;defprotocol Storage\n  &#40;save &#91;this data&#93;&#41;\n  &#40;load &#91;this id&#93;&#41;&#41;\n\n;; Implement for different backends &#40;not braided&#41;\n&#40;extend-type FileStorage\n  Storage\n  &#40;save &#91;this data&#93; ...file logic...&#41;\n  &#40;load &#91;this id&#93; ...file logic...&#41;&#41;\n\n&#40;extend-type DBStorage\n  Storage\n  &#40;save &#91;this data&#93; ...db logic...&#41;\n  &#40;load &#91;this id&#93; ...db logic...&#41;&#41;\n</code></pre><h3>For Time</h3><p><strong>Don't</strong>: Stateful objects changing over time<br /> <strong>Do</strong>: Values + transformations</p><pre><code class=\"clojure\">;; Simple: explicit versions\n&#40;def user-v1 {:name &quot;Alice&quot; :age 30}&#41;\n&#40;def user-v2 &#40;assoc user-v1 :age 31&#41;&#41;\n&#40;def user-v3 &#40;assoc user-v2 :role :admin&#41;&#41;\n\n;; Can inspect all versions &#40;time travel!&#41;\n</code></pre><h2></h2><h2>Try This</h2><h3>Exercise 1: Watch the Talk</h3><p><strong><a href='https://www.infoq.com/presentations/Simple-Made-Easy/'>Watch \"Simple Made Easy\"</a></strong> (1 hour)</p><p><strong>Take notes</strong>:</p><ul><li>What examples resonate with your experience?</li><li>Where have you encountered complecting?</li><li>What tools/practices create simplicity in your work?</li></ul><h3>Exercise 2: Audit Your Dependencies</h3><p><strong>List your project's dependencies.</strong></p><p>For each, ask:</p><ul><li><strong>Is it simple?</strong> (Does one thing, or many?)</li><li><strong>Could it be simpler?</strong> (Smaller alternatives?)</li><li><strong>Is the complexity essential?</strong> (Or accidental?)</li></ul><p><strong>Example</strong>:</p><pre><code>Dependency: lodash &#40;utility library, 100+ functions&#41;\n- Simple? No &#40;does many things&#41;\n- Alternative: Native JS &#40;simpler, but less convenient&#41;\n- Complexity essential? Depends &#40;for big apps: maybe. For small: probably not&#41;\n</code></pre><h3>Exercise 3: Simplicity Kata</h3><p><strong>Write a function</strong> to validate a user (name, email, age).</p><p><strong>Version 1</strong>: All concerns in one function (complected).</p><p><strong>Version 2</strong>: Separate functions for each validation rule (decomplected).</p><p><strong>Compare</strong>: Which is easier to test? Which is easier to extend?<h2></h2></p><h2>Going Deeper</h2><h3>Related Essays</h3><ul><li><strong><a href='/12025-10/9504-what-is-clojure'>9504: Clojure</a></strong> - Language designed for simplicity</li><li><strong><a href='/12025-10/9503-what-is-nock'>9503: Nock</a></strong> - Radical simplicity (12 rules)</li><li><strong><a href='/12025-10/9610-nix-package-manager'>9610: Nix</a></strong> - Simple build system (pure functions)</li><li><strong><a href='/12025-10/9949-intro-clojure-nix-ecosystem'>9949: The Wise Elders</a></strong> - Clojure's wisdom narrative</li></ul><h3>External Resources</h3><ul><li><strong><a href='https://www.infoq.com/presentations/Simple-Made-Easy/'>Rich Hickey: \"Simple Made Easy\"</a></strong> - The original talk (watch it!)</li><li><strong><a href='https://www.youtube.com/watch?v=-6BsiVyC1kM'>\"The Value of Values\"</a></strong> - Immutability deep dive</li><li><strong><a href='https://www.youtube.com/watch?v=f84n5oFoZBc'>\"Hammock Driven Development\"</a></strong> - On thinking before coding</li><li><strong>\"Are We There Yet?\"</strong> - Time, identity, and state</li></ul><h3>For the Philosophically Curious</h3><ul><li><strong>Dijkstra</strong>: \"Simplicity is prerequisite for reliability\"</li><li><strong>Tony Hoare</strong>: \"There are two ways to design software: simple with obviously no bugs, or complex with no obvious bugs\"</li><li><strong>Alan Kay</strong>: \"Simple things should be simple, complex things should be possible\"<h2></h2></li></ul><h2>Reflection Questions</h2><ol><li><strong>What's something you thought was \"simple\" that's actually just \"easy\"?</strong> (Familiar but complected?)</li><li><strong>Can you think of a time when \"easy\" won over \"simple\" in a decision?</strong> (What was the long-term cost?)</li><li><strong>Is it worth learning unfamiliar (not easy) tools if they're simpler?</strong> (Investment in understanding vs ongoing complexity cost)</li><li><strong>How do you balance \"ship now\" (choose easy) vs \"build right\" (choose simple)?</strong> (Pragmatism vs idealism)</li><li><strong>Can you identify complecting in systems you use daily?</strong> (Where are things braided that shouldn't be?)<h2></h2></li></ol><h2>Summary</h2><p><strong>Simple vs Easy</strong>:</p><ul><li><strong>Simple</strong> = not intertwined (objective, measurable)</li><li><strong>Easy</strong> = familiar, near at hand (subjective, contextual)</li><li><strong>We confuse them</strong> (choose familiar complex over unfamiliar simple)</li></ul><p><strong>Complecting</strong>:</p><ul><li><strong>Braiding concerns together</strong> (state + logic, validation + transformation)</li><li><strong>Makes code complex</strong> (hard to understand, test, change)</li><li><strong>Can be avoided</strong> (separate functions, explicit dependencies, data orientation)</li></ul><p><strong>Benefits of Simplicity</strong>:</p><ul><li><strong>Easier to understand</strong> (each part is independent)</li><li><strong>Easier to test</strong> (no complex setup)</li><li><strong>Easier to change</strong> (modify one without breaking others)</li><li><strong>More reliable</strong> (fewer interactions = fewer bugs)</li></ul><p><strong>Achieving Simplicity</strong>:</p><ul><li><strong>Choose simple constructs</strong> (values, functions, data)</li><li><strong>Avoid complecting</strong> (separate concerns, make dependencies explicit)</li><li><strong>Abstract with data</strong> (not classes for everything)</li><li><strong>Be willing to learn</strong> (unfamiliar simple > familiar complex)</li></ul><p><strong>Rich Hickey's Gift</strong>:</p><ul><li><strong>Named the problem</strong> (complecting—now we can see it!)</li><li><strong>Provided a framework</strong> (simple vs easy, constructs vs artifacts)</li><li><strong>Showed it's possible</strong> (Clojure proves simple can be practical)</li></ul><p><strong>In the Valley</strong>:</p><ul><li><strong>Simplicity is our north star</strong> (every decision asks: is this simple?)</li><li><strong>We choose simple over easy</strong> (Nix, Clojure, runit—all unfamiliar but simple)</li><li><strong>We decomplect constantly</strong> (separate concerns, explicit dependencies)</li><li><strong>We build for understanding</strong> (not just convenience)<h2></h2></li></ul><p><strong>Next</strong>: We'll explore <strong>types and sets</strong>—the mathematical foundations that let us reason about programs formally. Simplicity meets mathematics!<h2></h2></p><p><strong>Navigation</strong>:<br /> ← Previous: <a href='/12025-10/9520-functional-programming-basics'>9520 (functional programming basics)</a> | <strong>Phase 1 Index</strong> | Next: <a href='/12025-10/9540-types-sets-mathematical-foundations'>9540 (types sets mathematical foundations)</a></p><p><strong>Bridge to Narrative</strong>: For Hickey's wisdom embodied, see <a href='/12025-10/9949-intro-clojure-nix-ecosystem'>9949 (The Wise Elders)</a>!</p><p><strong>Metadata</strong>:</p><ul><li><strong>Phase</strong>: 1 (Foundations)</li><li><strong>Week</strong>: 2-3</li><li><strong>Prerequisites</strong>: 9504, 9510, 9520</li><li><strong>Concepts</strong>: Simple vs easy, complecting, decomplecting, constructs vs artifacts, design philosophy</li><li><strong>Next Concepts</strong>: Types, sets, mathematical foundations, formal reasoning</li><li><strong>Required Viewing</strong>: Rich Hickey's \"Simple Made Easy\" talk (1 hour)</li></ul><h2></h2><p><div style=\"text-align: center; opacity: 0.6; font-size: 0.85em; margin-top: 3em; padding-top: 1em; border-top: 1px solid rgba(139, 116, 94, 0.2);\"></p><p><strong>Copyright © 2025 <a href='https://codeberg.org/kae3g/12025-10/'>kae3g</a></strong> | Dual-licensed under <a href='https://www.apache.org/licenses/LICENSE-2.0'>Apache-2.0</a> / <a href='https://opensource.org/licenses/MIT'>MIT</a><br /> Competitive technology in service of clarity and beauty</p><p></div></p><p><em><a href='/12025-10/hidden-docs-index.html'>View Hidden Docs Index</a></em> | <em><a href='/12025-10/'>Return to Main Index</a></em></p>",
  "hash" : "2025-10-22T15:17:39.429092086Z-28157"
}