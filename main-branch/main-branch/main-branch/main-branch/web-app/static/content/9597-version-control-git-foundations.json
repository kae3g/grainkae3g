{
  "slug" : "9597-version-control-git-foundations",
  "meta" : {
    "slug" : "9597-version-control-git-foundations",
    "title" : "kae3g 9596: Version Control - Git Foundations",
    "filename" : "9597-version-control-git-foundations.md",
    "source-dir" : "hidden"
  },
  "html" : "<h1>kae3g 9596: Version Control - Git Foundations</h1><p><strong>Phase 1: Foundations & Philosophy</strong> | <strong>Week 4</strong> | <strong>Reading Time: 18 minutes</strong><h2></h2></p><h2>What You'll Learn</h2><ul><li>Why version control exists (collaboration, history, backup)</li><li>Git's content-addressed model (like Nix!)</li><li>Commits, branches, and the DAG (directed acyclic graph)</li><li>Common workflows (add, commit, push, pull, merge)</li><li>Why Git won (vs SVN, CVS, Mercurial)</li><li>Immutability in Git (commits never change)</li><li>How Git enables the grainhouse strategy</li><li>Version control as time-traveling through your garden's history<h2></h2></li></ul><h2>Prerequisites</h2><ul><li><strong><a href='/12025-10/9560-text-files-universal-format'>9560: Text Files</a></strong> - Source code versioning</li><li><strong><a href='/12025-10/9590-filesystem-hierarchical-organization'>9590: Filesystem</a></strong> - Where Git stores data</li><li><strong><a href='/12025-10/9595-package-managers-dependency-resolution'>9595: Package Managers</a></strong> - Content-addressing (Nix)<h2></h2></li></ul><h2>The Time-Traveling Garden</h2><p><strong>Without version control</strong>:</p><pre><code>project.zip\nproject-v2.zip\nproject-v2-final.zip\nproject-v2-final-ACTUAL.zip\nproject-v2-final-ACTUAL-USE-THIS.zip\n</code></pre><p><strong>Chaos!</strong> (Which is current? What changed? Can we go back?)</p><p><strong>With Git</strong>:<pre><code class=\"bash\">git log --oneline\n# abc123 Add feature X\n# def456 Fix bug Y\n# ghi789 Initial commit\n\n# Travel to any point:\ngit checkout def456\n# Code is now exactly as it was at that commit!\n</code></pre></p><p><strong>Plant lens</strong>: <strong>\"Git is a time-lapse of your garden—every state preserved, can replay growth from seed to harvest.\"</strong><h2></h2></p><h2>Git's Content-Addressed Model</h2><p><strong>Like Nix</strong> (Essay 9595), Git uses <strong>content addressing</strong>:</p><h3>Objects</h3><p><strong>Everything is an object</strong> (identified by SHA-1 hash):</p><p><strong>Blob</strong> (file contents):<pre><code class=\"bash\">echo &quot;Hello, Valley!&quot; | git hash-object --stdin\n# Output: a1b2c3d4e5f6... &#40;SHA-1 hash of content&#41;\n</code></pre></p><p><strong>Tree</strong> (directory):</p><pre><code>tree abc123\n├── 100644 blob def456 README.md\n└── 100644 blob ghi789 script.sh\n</code></pre><p><strong>Commit</strong> (snapshot + metadata):</p><pre><code>commit jkl012\ntree abc123\nparent mno345\nauthor Alice &lt;alice@example.com&gt;\ncommitter Alice &lt;alice@example.com&gt;\n\nAdd new feature\n</code></pre><p><strong>Tag</strong> (named reference):</p><pre><code>tag v1.0.0\nobject jkl012\n</code></pre><p><strong>All objects</strong> stored in <code>.git/objects/</code>, <strong>named by hash</strong>:</p><pre><code>.git/objects/\n  a1/b2c3d4e5f6...  &#40;blob&#41;\n  ab/c123...        &#40;tree&#41;\n  jk/l012...        &#40;commit&#41;\n</code></pre><p><strong>Same content → same hash</strong> (like Nix!).<h2></h2></p><h2>Commits: Immutable Snapshots</h2><p><strong>A commit is</strong>:</p><ul><li>Snapshot of entire project (tree)</li><li>Metadata (author, date, message)</li><li>Parent commit(s) (history)</li><li><strong>Immutable</strong> (never changes - like Nock spec!)</li></ul><p><strong>Create commit</strong>:<pre><code class=\"bash\"># Stage changes\ngit add file1.txt file2.txt\n\n# Commit\ngit commit -m &quot;Add new features&quot;\n# Creates new commit object &#40;immutable!&#41;\n</code></pre></p><p><strong>Key insight</strong>: Commits are <strong>immutable</strong>. You can't change history (only add to it).</p><p><strong>Plant lens</strong>: <strong>\"Commits are growth rings—permanent record of the tree's history, each ring immutable.\"</strong><h2></h2></p><h2>Branches: Parallel Timelines</h2><p><strong>Branches</strong> are just <strong>pointers to commits</strong>:</p><pre><code>main:     A → B → C → D\n                  ↓\nfeature:          E → F\n\n# 'main' points to D\n# 'feature' points to F\n# Both share history A-B-C\n</code></pre><p><strong>Create branch</strong>:<pre><code class=\"bash\">git branch feature-x\ngit checkout feature-x\n# Or:\ngit checkout -b feature-x\n\n# Work, commit\ngit add ...\ngit commit -m &quot;Feature X&quot;\n</code></pre></p><p><strong>Merge branch</strong>:<pre><code class=\"bash\">git checkout main\ngit merge feature-x\n\n# Now main includes feature-x commits\n</code></pre></p><p><strong>Delete branch</strong> (pointer only, commits stay!):<pre><code class=\"bash\">git branch -d feature-x\n# Commits still exist &#40;reachable from main&#41;\n</code></pre></p><h2></h2><h2>The DAG (Directed Acyclic Graph)</h2><p><strong>Git history</strong> is a DAG:</p><pre><code>       A ← B ← C ← D ← F  &#40;main&#41;\n            ↖         ↗\n              E ──────   &#40;feature, merged&#41;\n\nDirection: Forward in time &#40;arrows point to parents&#41;\nAcyclic: No loops &#40;can't be your own ancestor&#41;\n</code></pre><p><strong>Why DAG matters</strong>:</p><ul><li><strong>Partial order</strong>: Some commits are unrelated (parallel branches)</li><li><strong>Merge commits</strong>: Two parents (combining branches)</li><li><strong>Reachability</strong>: Can find common ancestor (for merges, diffs)</li></ul><p><strong>This is graph theory</strong> (Essay 9540 - sets and types!).<h2></h2></p><h2>Why Git Won</h2><p><strong>Competitors</strong> (SVN, CVS, Mercurial, Perforce):</p><p><strong>Git advantages</strong>:</p><ol><li><strong>Distributed</strong>: Every clone is full repo (no central server needed)</li><li><strong>Fast</strong>: Local operations (commits, branches, diffs - no network!)</li><li><strong>Content-addressed</strong>: Efficient storage (deduplication via hashing)</li><li><strong>Branching</strong>: Cheap (just pointers), fast (instant)</li><li><strong>Offline</strong>: Work without network, sync later</li></ol><p><strong>SVN</strong> (centralized):</p><pre><code>Central Server &#40;required for all operations&#41;\n     ↓\nDeveloper checkouts &#40;partial copies&#41;\n\nProblem: Server down? Can't commit!\n</code></pre><p><strong>Git</strong> (distributed):</p><pre><code>Developer 1: &#91;Full repo&#93; ←→ GitHub ←→ &#91;Full repo&#93; Developer 2\n                                ↕\n                          &#91;Full repo&#93; CI Server\n\nNo single point of failure!\n</code></pre><p><strong>Git's philosophy</strong>: Every developer has full history (sovereignty!).<h2></h2></p><h2>Immutability in Git</h2><p><strong>Commits are immutable</strong> (like Clojure's persistent data structures!):</p><pre><code class=\"bash\"># Create commit\ngit commit -m &quot;Add feature&quot;\n# Creates: abc123 &#40;hash&#41;\n\n# &quot;Change&quot; commit?\ngit commit --amend -m &quot;Better message&quot;\n# Creates: def456 &#40;NEW commit, abc123 unchanged!&#41;\n\n# abc123 still exists &#40;orphaned, but there&#41;\ngit reflog  # Shows all commits, even orphaned\n</code></pre><p><strong>Rewriting history</strong> (rebase, amend) <strong>doesn't mutate</strong>—it creates new commits.</p><p><strong>Old commits</strong> stay forever (until garbage collected).</p><p><strong>This is functional programming</strong> for version control!<h2></h2></p><h2>Common Workflows</h2><h3>Solo Developer</h3><pre><code class=\"bash\"># Start project\ngit init\ngit add .\ngit commit -m &quot;Initial commit&quot;\n\n# Work\nvim file.txt\ngit add file.txt\ngit commit -m &quot;Update file&quot;\n\n# Backup to GitHub\ngit remote add origin https://github.com/user/repo.git\ngit push -u origin main\n</code></pre><h3>Collaborator</h3><pre><code class=\"bash\"># Clone repo\ngit clone https://github.com/user/repo.git\ncd repo\n\n# Create branch\ngit checkout -b feature-x\n\n# Work, commit\ngit add ...\ngit commit -m &quot;Add feature X&quot;\n\n# Push branch\ngit push origin feature-x\n\n# Create pull request on GitHub\n# &#40;Others review, merge&#41;\n</code></pre><h3>Syncing Changes</h3><pre><code class=\"bash\"># Fetch changes from remote\ngit fetch origin\n\n# Merge into current branch\ngit merge origin/main\n\n# Or &#40;fetch + merge&#41;:\ngit pull origin main\n</code></pre><h2></h2><h2>Git and the Grainhouse</h2><p><strong>Git enables sovereignty</strong>:</p><h3>Fork Everything</h3><pre><code class=\"bash\"># Fork nixpkgs &#40;your grainhouse!&#41;\ngit clone https://github.com/NixOS/nixpkgs.git\ncd nixpkgs\n\n# Create your fork\ngit remote add mine https://github.com/youruser/nixpkgs.git\n\n# Make changes\nvim pkgs/some-package/default.nix\ngit commit -m &quot;Patch for grainhouse&quot;\n\n# Push to YOUR fork\ngit push mine main\n\n# Now: You control this dependency forever\n</code></pre><p><strong>Upstream changes</strong>?<pre><code class=\"bash\"># Fetch upstream\ngit fetch origin\n\n# Merge selectively\ngit merge origin/main\n# &#40;Review, test, accept/reject&#41;\n</code></pre></p><p><strong>This is the grainhouse strategy</strong> (Essay 9960): Fork, maintain, control.</p><h3>Preserve Knowledge</h3><p><strong>Every commit</strong> is documentation:</p><pre><code class=\"bash\">git log --all --graph --oneline\n# Visual history of project\n\ngit show abc123\n# See exactly what changed in that commit\n\ngit blame file.txt\n# Who wrote each line &#40;and when, and why&#41;\n</code></pre><p><strong>Git is a knowledge repository</strong> (like House of Wisdom, Essay 9505!).<h2></h2></p><h2>Try This</h2><h3>Exercise 1: Git Basics</h3><pre><code class=\"bash\"># Create repo\nmkdir test-repo &amp;&amp; cd test-repo\ngit init\n\n# Create file\necho &quot;Valley content&quot; &gt; README.md\ngit add README.md\ngit commit -m &quot;Initial commit&quot;\n\n# Modify\necho &quot;More content&quot; &gt;&gt; README.md\ngit add README.md\ngit commit -m &quot;Add content&quot;\n\n# View history\ngit log\n\n# Go back\ngit checkout HEAD&#126;1\ncat README.md\n# &#40;Only &quot;Valley content&quot;, not &quot;More content&quot;&#41;\n\n# Return to present\ngit checkout main\n</code></pre><h2></h2><h3>Exercise 2: Branching</h3><pre><code class=\"bash\"># Create branch\ngit checkout -b experiment\n\n# Make changes\necho &quot;Experimental&quot; &gt; experiment.txt\ngit add experiment.txt\ngit commit -m &quot;Try experiment&quot;\n\n# Switch back to main\ngit checkout main\nls\n# experiment.txt doesn't exist here!\n\n# Merge experiment\ngit merge experiment\n\nls\n# Now experiment.txt exists!\n</code></pre><h2></h2><h3>Exercise 3: Content-Addressing</h3><pre><code class=\"bash\"># Create file, get hash\necho &quot;Test content&quot; | git hash-object --stdin\n# Output: a1b2c3d4e5f6...\n\n# Same content, same hash\necho &quot;Test content&quot; | git hash-object --stdin\n# Output: a1b2c3d4e5f6... &#40;IDENTICAL!&#41;\n\n# Different content, different hash\necho &quot;Different&quot; | git hash-object --stdin\n# Output: x9y8z7w6v5u4... &#40;DIFFERENT!&#41;\n</code></pre><p><strong>Observe</strong>: Content-addressing (hash = content).<h2></h2></p><h2>Going Deeper</h2><h3>Related Essays</h3><ul><li><strong><a href='/12025-10/9560-text-files-universal-format'>9560: Text Files</a></strong> - What Git versions</li><li><strong><a href='/12025-10/9595-package-managers-dependency-resolution'>9595: Package Managers</a></strong> - Nix content-addressing</li><li><strong><a href='/12025-10/9960-grainhouse-risc-v-synthesis'>9960: The Grainhouse</a></strong> - Fork strategy</li><li><strong><a href='/12025-10/9505-house-of-wisdom-knowledge-gardens'>9505: House of Wisdom</a></strong> - Preserving knowledge</li></ul><h3>External Resources</h3><ul><li><strong>\"Pro Git\" book</strong> - Comprehensive (free online)</li><li><strong><code>man git</code></strong> - Complete documentation</li><li><strong>GitHub Learning Lab</strong> - Interactive tutorials</li><li><strong>Git immersion</strong> - Hands-on course<h2></h2></li></ul><h2>Reflection Questions</h2><ol><li><strong>Why did distributed win over centralized?</strong> (SVN had network effects - but Git's benefits outweighed)</li><li><strong>Is immutability always good?</strong> (Git commits immutable - but what about secrets accidentally committed?)</li><li><strong>Could Git be simpler?</strong> (Complex UI - <code>git checkout</code> does multiple things - room for improvement)</li><li><strong>What if all software was in Git?</strong> (Nix uses Git for nixpkgs - source of truth!)</li><li><strong>How would Nock version control work?</strong> (Nouns as commits, all deterministic - interesting!)<h2></h2></li></ol><h2>Summary</h2><p><strong>Git Fundamentals</strong>:</p><p><strong>Content-Addressed Objects</strong>:</p><ul><li><strong>Blob</strong>: File contents (hashed)</li><li><strong>Tree</strong>: Directory structure</li><li><strong>Commit</strong>: Snapshot + metadata</li><li><strong>Tag</strong>: Named reference</li></ul><p><strong>Key Concepts</strong>:</p><ul><li><strong>Commits</strong>: Immutable snapshots</li><li><strong>Branches</strong>: Pointers to commits</li><li><strong>DAG</strong>: Directed acyclic graph (history structure)</li><li><strong>Distributed</strong>: Every clone = full repo</li></ul><p><strong>Common Operations</strong>:</p><ul><li><strong><code>git add</code></strong>: Stage changes</li><li><strong><code>git commit</code></strong>: Create snapshot</li><li><strong><code>git branch</code></strong>: Create pointer</li><li><strong><code>git merge</code></strong>: Combine branches</li><li><strong><code>git push/pull</code></strong>: Sync with remote</li></ul><p><strong>Why Git Won</strong>:</p><ul><li>Distributed (no single point of failure)</li><li>Fast (local operations)</li><li>Efficient (content-addressing)</li><li>Branching (cheap, instant)</li><li>Offline-capable (sync later)</li></ul><p><strong>Immutability</strong>:</p><ul><li>Commits never change (create new instead)</li><li>History preserved forever</li><li>Functional programming principles applied</li></ul><p><strong>In the Valley</strong>:</p><ul><li><strong>We version everything</strong> (code, config, docs, essays!)</li><li><strong>We fork upstream</strong> (grainhouse strategy)</li><li><strong>We preserve history</strong> (every commit is knowledge)</li><li><strong>We use immutability</strong> (never mutate, only add)</li></ul><p><strong>Plant lens</strong>: <strong>\"Git is the garden's logbook—every planting, every harvest, every season recorded. Time-travel through growth stages, learn from history.\"</strong><h2></h2></p><p><strong>Next</strong>: We'll explore <strong>testing</strong>—how to verify code works, different test types, and why tests are essential for long-term maintenance!<h2></h2></p><p><strong>Navigation</strong>:<br /> ← Previous: <a href='/12025-10/9596-package-managers-dependency-resolution'>9596 (package managers dependency resolution)</a> | <strong>Phase 1 Index</strong> | Next: <a href='/12025-10/9598-testing-verification-validation'>9598 (testing verification validation)</a></p><p><strong>Metadata</strong>:</p><ul><li><strong>Phase</strong>: 1 (Foundations)</li><li><strong>Week</strong>: 4</li><li><strong>Prerequisites</strong>: 9560, 9590, 9595</li><li><strong>Concepts</strong>: Version control, Git, commits, branches, DAG, content-addressing, immutability, distributed systems</li><li><strong>Next Concepts</strong>: Testing, unit tests, integration tests, property-based testing</li><li><strong>Plant Lens</strong>: Garden logbook (history), growth rings (commits), parallel gardens (branches), time-travel (checkout)</li></ul><h2></h2><p><div style=\"text-align: center; opacity: 0.6; font-size: 0.85em; margin-top: 3em; padding-top: 1em; border-top: 1px solid rgba(139, 116, 94, 0.2);\"></p><p><strong>Copyright © 2025 <a href='https://codeberg.org/kae3g/12025-10/'>kae3g</a></strong> | Dual-licensed under <a href='https://www.apache.org/licenses/LICENSE-2.0'>Apache-2.0</a> / <a href='https://opensource.org/licenses/MIT'>MIT</a><br /> Competitive technology in service of clarity and beauty</p><p></div></p><p><em><a href='/12025-10/hidden-docs-index.html'>View Hidden Docs Index</a></em> | <em><a href='/12025-10/'>Return to Main Index</a></em></p>",
  "hash" : "2025-10-22T15:17:39.429560179Z-12358"
}