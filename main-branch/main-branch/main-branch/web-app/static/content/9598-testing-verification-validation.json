{
  "slug" : "9598-testing-verification-validation",
  "meta" : {
    "slug" : "9598-testing-verification-validation",
    "title" : "kae3g 9597: Testing - Verification and Validation",
    "filename" : "9598-testing-verification-validation.md",
    "source-dir" : "hidden"
  },
  "html" : "<h1>kae3g 9597: Testing - Verification and Validation</h1><p><strong>Phase 1: Foundations & Philosophy</strong> | <strong>Week 4</strong> | <strong>Reading Time: 17 minutes</strong><h2></h2></p><h2>What You'll Learn</h2><ul><li>Why testing matters (catch bugs early, enable refactoring)</li><li>Unit tests vs integration tests vs end-to-end tests</li><li>Test-driven development (TDD)</li><li>Property-based testing (QuickCheck, test.check)</li><li>Why formal verification is better (but harder)</li><li>Coverage metrics and their limitations</li><li>Testing as observing your garden's health (plant lens)<h2></h2></li></ul><h2>Prerequisites</h2><ul><li><strong><a href='/12025-10/9520-functional-programming-basics'>9520: Functional Programming</a></strong> - Pure functions (easy to test!)</li><li><strong><a href='/12025-10/9504-what-is-clojure'>9504: What Is Clojure?</a></strong> - Clojure testing (test.check)</li><li><strong><a href='/12025-10/9503-what-is-nock'>9503: What Is Nock?</a></strong> - Formal verification (proof > testing)<h2></h2></li></ul><h2>Testing vs Verification</h2><p><strong>Testing</strong>: Check finite cases</p><p><strong>Verification</strong>: Prove for ALL cases</p><p><strong>Example</strong>:</p><p><strong>Testing</strong>:<pre><code class=\"clojure\">&#40;deftest test-addition\n  &#40;is &#40;= 4 &#40;+ 2 2&#41;&#41;&#41;    ; Check one case\n  &#40;is &#40;= 10 &#40;+ 5 5&#41;&#41;&#41;   ; Check another\n  &#40;is &#40;= 0 &#40;+ 0 0&#41;&#41;&#41;&#41;   ; Check edge case\n\n; Covers 3 cases, but what about 2+3? 100+200? -5+10?\n</code></pre></p><p><strong>Verification</strong> (mathematical proof):</p><pre><code>Theorem: ∀ a,b ∈ ℤ, a + b = b + a  &#40;commutative property&#41;\nProof: &#91;formal mathematical proof&#93;\n\nResult: Proven for ALL integers &#40;infinite cases!&#41;\n</code></pre><p><strong>Testing</strong> = practical, covers common cases<br /> <strong>Verification</strong> = rigorous, covers ALL cases</p><p><strong>For most code</strong>: Testing is good enough.<br /> <strong>For critical code</strong> (kernels, crypto, safety-critical): Verification needed (Essay 9503 - seL4!).<h2></h2></p><h2>The Testing Pyramid</h2><p><strong>Different levels</strong> of testing:</p><pre><code>         /\\\n        /  \\  E2E &#40;slow, few&#41;\n       /----\\\n      / Intg \\  Integration &#40;moderate&#41;\n     /--------\\\n    /   Unit   \\  Unit tests &#40;fast, many&#41;\n   /&#95;&#95;&#95;&#95;&#95;&#95;&#95;&#95;&#95;&#95;&#95;&#95;\\\n</code></pre><h3>Unit Tests (Base)</h3><p><strong>Test one function</strong> in isolation:</p><pre><code class=\"clojure\">&#40;defn add &#91;a b&#93;\n  &#40;+ a b&#41;&#41;\n\n&#40;deftest test-add\n  &#40;is &#40;= 4 &#40;add 2 2&#41;&#41;&#41;\n  &#40;is &#40;= 0 &#40;add 0 0&#41;&#41;&#41;\n  &#40;is &#40;= -5 &#40;add -10 5&#41;&#41;&#41;&#41;\n</code></pre><p><strong>Characteristics</strong>:</p><ul><li><strong>Fast</strong> (milliseconds)</li><li><strong>Isolated</strong> (no dependencies, databases, network)</li><li><strong>Many</strong> (hundreds or thousands)</li></ul><p><strong>Goal</strong>: Catch bugs in individual components.</p><h3>Integration Tests (Middle)</h3><p><strong>Test components together</strong>:</p><pre><code class=\"clojure\">&#40;deftest test-database-save-load\n  &#40;let &#91;db &#40;create-test-db&#41;&#93;\n    &#40;save-user db {:name &quot;Alice&quot;}&#41;\n    &#40;is &#40;= &quot;Alice&quot; &#40;:name &#40;load-user db 1&#41;&#41;&#41;&#41;&#41;&#41;\n</code></pre><p><strong>Characteristics</strong>:</p><ul><li><strong>Slower</strong> (seconds - real database, filesystem)</li><li><strong>Dependencies</strong> (DB, files, services)</li><li><strong>Fewer</strong> (dozens or hundreds)</li></ul><p><strong>Goal</strong>: Catch bugs in interactions between components.</p><h3>End-to-End (Top)</h3><p><strong>Test entire system</strong> (like a user):</p><pre><code class=\"javascript\">// Selenium/Playwright test\ntest&#40;'User can login', async &#40;&#41; =&gt; {\n  await page.goto&#40;'http://app.com/login'&#41;;\n  await page.fill&#40;'#username', 'alice'&#41;;\n  await page.fill&#40;'#password', 'secret'&#41;;\n  await page.click&#40;'#submit'&#41;;\n  await expect&#40;page&#41;.toHaveURL&#40;'/dashboard'&#41;;\n}&#41;;\n</code></pre><p><strong>Characteristics</strong>:</p><ul><li><strong>Slowest</strong> (minutes - full app, browser, network)</li><li><strong>Brittle</strong> (UI changes break tests)</li><li><strong>Few</strong> (a dozen critical paths)</li></ul><p><strong>Goal</strong>: Catch bugs in complete user workflows.<h2></h2></p><h2>Test-Driven Development (TDD)</h2><p><strong>Write tests BEFORE code</strong> (controversial but powerful):</p><p><strong>Red-Green-Refactor cycle</strong>:</p><pre><code>1. RED: Write test &#40;fails - code doesn't exist yet&#41;\n2. GREEN: Write minimal code to pass test\n3. REFACTOR: Improve code &#40;tests ensure it still works&#41;\n4. Repeat\n</code></pre><p><strong>Example</strong>:</p><pre><code class=\"clojure\">;; 1. RED: Write test first\n&#40;deftest test-factorial\n  &#40;is &#40;= 1 &#40;factorial 0&#41;&#41;&#41;\n  &#40;is &#40;= 1 &#40;factorial 1&#41;&#41;&#41;\n  &#40;is &#40;= 120 &#40;factorial 5&#41;&#41;&#41;&#41;\n\n;; Test fails &#40;factorial doesn't exist&#41;\n\n;; 2. GREEN: Minimal implementation\n&#40;defn factorial &#91;n&#93;\n  &#40;if &#40;&lt;= n 1&#41;\n    1\n    &#40;&#42; n &#40;factorial &#40;dec n&#41;&#41;&#41;&#41;&#41;\n\n;; Test passes!\n\n;; 3. REFACTOR: Improve &#40;tail-recursive&#41;\n&#40;defn factorial &#91;n&#93;\n  &#40;letfn &#91;&#40;fact-helper &#91;n acc&#93;\n            &#40;if &#40;&lt;= n 1&#41;\n              acc\n              &#40;recur &#40;dec n&#41; &#40;&#42; n acc&#41;&#41;&#41;&#41;&#93;\n    &#40;fact-helper n 1&#41;&#41;&#41;\n\n;; Test still passes &#40;verified by tests!&#41;\n</code></pre><p><strong>Benefits</strong>:</p><ul><li>Forces you to think about API before implementation</li><li>Ensures code is testable (modular, pure functions)</li><li>Prevents over-engineering (only write what tests need)</li></ul><p><strong>Drawbacks</strong>:</p><ul><li>Slower initial development (write test first)</li><li>Can lead to myopic design (optimize for tests, not overall architecture)<h2></h2></li></ul><h2>Property-Based Testing</h2><p><strong>Traditional testing</strong>: Specify inputs and expected outputs</p><p><strong>Property-based</strong>: Specify properties that should ALWAYS hold</p><p><strong>Example</strong>:</p><pre><code class=\"clojure\">;; Traditional\n&#40;deftest test-reverse\n  &#40;is &#40;= &#91;3 2 1&#93; &#40;reverse &#91;1 2 3&#93;&#41;&#41;&#41;\n  &#40;is &#40;= &#91;&#93; &#40;reverse &#91;&#93;&#41;&#41;&#41;&#41;\n\n;; Property-based\n&#40;require '&#91;clojure.test.check.generators :as gen&#93;\n         '&#91;clojure.test.check.properties :as prop&#93;&#41;\n\n&#40;def reverse-property\n  &#40;prop/for-all &#91;v &#40;gen/vector gen/int&#41;&#93;\n    ;; Property: reversing twice = original\n    &#40;= v &#40;reverse &#40;reverse v&#41;&#41;&#41;&#41;&#41;\n\n;; Test with 100 random vectors!\n&#40;quick-check 100 reverse-property&#41;\n</code></pre><p><strong>Benefits</strong>:</p><ul><li>Tests edge cases you didn't think of (fuzzing!)</li><li>Fewer tests cover more cases (properties > examples)</li><li>Finds bugs traditional tests miss</li></ul><p><strong>Clojure</strong>: <code>test.check</code> library (QuickCheck for Clojure).<h2></h2></p><h2>Coverage: The Incomplete Metric</h2><p><strong>Code coverage</strong>: What % of code is executed by tests?</p><pre><code class=\"bash\"># Run tests with coverage\npytest --cov=myapp tests/\n\n# Output:\n# myapp.py    85%  &#40;120 lines, 102 covered&#41;\n</code></pre><p><strong>Common mistake</strong>: \"100% coverage = no bugs!\"</p><p><strong>Reality</strong>: Coverage shows <strong>what was executed</strong>, not <strong>what was verified</strong>.</p><p><strong>Example</strong>:</p><pre><code class=\"python\">def dangerous&#95;function&#40;x&#41;:\n    if x &gt; 0:\n        return x &#42; 2\n    else:\n        launch&#95;missiles&#40;&#41;  # BUG!\n\ndef test&#95;dangerous&#40;&#41;:\n    assert dangerous&#95;function&#40;5&#41; == 10\n\n# Coverage: 50% &#40;only 'if x &gt; 0' branch tested&#41;\n# But worse: Didn't test negative case &#40;would launch missiles!&#41;\n</code></pre><p><strong>Coverage is useful</strong>, but <strong>not sufficient</strong> (need good assertions!).<h2></h2></p><h2>Testing Pure Functions</h2><p><strong>Pure functions</strong> (Essay 9520) are <strong>easy to test</strong>:</p><pre><code class=\"clojure\">;; Pure function &#40;no side effects, same input = same output&#41;\n&#40;defn double &#91;x&#93;\n  &#40;&#42; x 2&#41;&#41;\n\n;; Simple test\n&#40;deftest test-double\n  &#40;is &#40;= 4 &#40;double 2&#41;&#41;&#41;\n  &#40;is &#40;= 0 &#40;double 0&#41;&#41;&#41;\n  &#40;is &#40;= -10 &#40;double -5&#41;&#41;&#41;&#41;\n\n; Deterministic, no mocking, no setup/teardown\n</code></pre><p><strong>Impure functions</strong> (side effects) are <strong>hard to test</strong>:</p><pre><code class=\"python\">def save&#95;to&#95;database&#40;user&#41;:\n    db = connect&#95;database&#40;&#41;  # Side effect!\n    db.save&#40;user&#41;\n    send&#95;email&#40;user.email&#41;   # Side effect!\n    log&#40;&quot;Saved user&quot;&#41;        # Side effect!\n\n# Test requires: mock DB, mock email, mock logger\n# Complex!\n</code></pre><p><strong>Lesson</strong>: <strong>Pure functions are naturally testable</strong> (push side effects to boundaries).<h2></h2></p><h2>Formal Verification: Beyond Testing</h2><p><strong>Testing</strong>: Finite checks (can't test all inputs)</p><p><strong>Formal verification</strong>: Mathematical proof (ALL inputs guaranteed)</p><p><strong>seL4</strong> (Essay 9954, 9503):</p><ul><li>10,000 lines of C</li><li><strong>Proven</strong>: No crashes, no memory leaks, no security bugs</li><li>11 person-years to verify</li><li><strong>Zero exploits</strong> since 2009 (testing can't achieve this!)</li></ul><p><strong>Nock</strong> (Essay 9503):</p><ul><li>12 rules → verification tractable</li><li>Prove properties mathematically</li><li>Example: Prove scheduler is fair (not just test 1000 cases)</li></ul><p><strong>Trade-off</strong>: Verification = expensive, but <strong>absolute certainty</strong>.</p><p><strong>When worth it</strong>: Safety-critical (aerospace, medical, financial, OS kernels).<h2></h2></p><h2>Try This</h2><h3>Exercise 1: Write Unit Test</h3><pre><code class=\"clojure\">;; Function to test\n&#40;defn fibonacci &#91;n&#93;\n  &#40;cond\n    &#40;&lt;= n 0&#41; 0\n    &#40;= n 1&#41; 1\n    :else &#40;+ &#40;fibonacci &#40;- n 1&#41;&#41;\n             &#40;fibonacci &#40;- n 2&#41;&#41;&#41;&#41;&#41;\n\n;; Your test:\n&#40;deftest test-fibonacci\n  &#40;is &#40;= 0 &#40;fibonacci 0&#41;&#41;&#41;\n  &#40;is &#40;= 1 &#40;fibonacci 1&#41;&#41;&#41;\n  &#40;is &#40;= 1 &#40;fibonacci 2&#41;&#41;&#41;\n  &#40;is &#40;= 55 &#40;fibonacci 10&#41;&#41;&#41;&#41;\n</code></pre><p><strong>Run</strong>: <code>clojure -X:test</code> (or your test runner).<h2></h2></p><h3>Exercise 2: Find Bug via Testing</h3><pre><code class=\"python\">def divide&#40;a, b&#41;:\n    return a / b\n\n# Test\ndef test&#95;divide&#40;&#41;:\n    assert divide&#40;10, 2&#41; == 5\n    assert divide&#40;7, 2&#41; == 3.5\n    # Add this:\n    assert divide&#40;10, 0&#41; == ???  # What should this be?\n\n# Running reveals: ZeroDivisionError!\n# Fix:\ndef divide&#40;a, b&#41;:\n    if b == 0:\n        raise ValueError&#40;&quot;Cannot divide by zero&quot;&#41;\n    return a / b\n</code></pre><h2></h2><h3>Exercise 3: Property-Based Test</h3><pre><code class=\"clojure\">&#40;require '&#91;clojure.test.check :as tc&#93;\n         '&#91;clojure.test.check.generators :as gen&#93;\n         '&#91;clojure.test.check.properties :as prop&#93;&#41;\n\n;; Property: sorting is idempotent\n&#40;def sort-idempotent\n  &#40;prop/for-all &#91;v &#40;gen/vector gen/int&#41;&#93;\n    &#40;= &#40;sort v&#41; &#40;sort &#40;sort v&#41;&#41;&#41;&#41;&#41;\n\n;; Run with 100 random vectors\n&#40;tc/quick-check 100 sort-idempotent&#41;\n</code></pre><p><strong>Observe</strong>: Generates random inputs, checks property holds.<h2></h2></p><h2>Going Deeper</h2><h3>Related Essays</h3><ul><li><strong><a href='/12025-10/9520-functional-programming-basics'>9520: Functional Programming</a></strong> - Pure functions (testable!)</li><li><strong><a href='/12025-10/9504-what-is-clojure'>9504: What Is Clojure?</a></strong> - test.check library</li><li><strong><a href='/12025-10/9503-what-is-nock'>9503: What Is Nock?</a></strong> - Formal verification</li><li><strong><a href='/12025-10/9954-sel4-verified-microkernel'>9954: seL4</a></strong> - Verification at scale</li></ul><h3>External Resources</h3><ul><li><strong>\"Growing Object-Oriented Software, Guided by Tests\"</strong> - TDD classic</li><li><strong>QuickCheck</strong> (Haskell) - Original property-based testing</li><li><strong>test.check</strong> (Clojure) - Property-based for Clojure</li><li><strong>Hypothesis</strong> (Python) - Property-based for Python<h2></h2></li></ul><h2>Reflection Questions</h2><ol><li><strong>How much testing is enough?</strong> (100% coverage? Critical paths only? When diminishing returns?)</li><li><strong>Should all code be test-driven?</strong> (TDD pros/cons - when appropriate?)</li><li><strong>Can tests replace documentation?</strong> (Some say tests ARE documentation - agree?)</li><li><strong>Is formal verification the future?</strong> (Or too expensive for most code?)</li><li><strong>How would Nock programs be tested?</strong> (Pure functions (noun → noun) - property-based ideal!)<h2></h2></li></ol><h2>Summary</h2><p><strong>Testing Fundamentals</strong>:</p><p><strong>Types of Tests</strong>:</p><ul><li><strong>Unit</strong>: One function, isolated, fast (many)</li><li><strong>Integration</strong>: Components together, slower (moderate)</li><li><strong>End-to-end</strong>: Full system, slowest (few)</li></ul><p><strong>Testing Approaches</strong>:</p><ul><li><strong>Example-based</strong>: Specific inputs → expected outputs</li><li><strong>Property-based</strong>: Random inputs, check properties hold</li><li><strong>Test-driven</strong>: Write tests first, code second</li></ul><p><strong>Key Concepts</strong>:</p><ul><li><strong>Red-Green-Refactor</strong>: TDD cycle</li><li><strong>Coverage</strong>: % code executed (incomplete metric!)</li><li><strong>Mocking</strong>: Fake dependencies for testing</li><li><strong>Assertion</strong>: Check expected = actual</li></ul><p><strong>Pure Functions Win</strong>:</p><ul><li>Deterministic (same input = same output)</li><li>No side effects (no setup/teardown)</li><li>Naturally testable (no mocking needed)</li></ul><p><strong>Verification > Testing</strong>:</p><ul><li>Testing: Finite cases (practical)</li><li>Verification: All cases (mathematical proof)</li><li>seL4: 11 person-years, zero exploits</li><li>Nock: 12 rules → verification tractable</li></ul><p><strong>In the Valley</strong>:</p><ul><li><strong>We test critical paths</strong> (not 100% coverage obsession)</li><li><strong>We use property-based</strong> when possible (more coverage, fewer tests)</li><li><strong>We prefer pure functions</strong> (testability is design!)</li><li><strong>We look toward verification</strong> (Nock-based systems, provable)</li></ul><p><strong>Plant lens</strong>: <strong>\"Testing is observing garden health—check soil (unit), water flow (integration), entire ecosystem (end-to-end). Healthy gardens show it.\"</strong><h2></h2></p><p><strong>Next</strong>: We'll explore <strong>documentation</strong>—how to write for humans, why good docs matter, and the art of explaining complex systems simply!<h2></h2></p><p><strong>Navigation</strong>:<br /> ← Previous: <a href='/12025-10/9597-version-control-git-foundations'>9597 (version control git foundations)</a> | <strong>Phase 1 Index</strong> | Next: <a href='/12025-10/9599-documentation-writing-for-humans'>9599 (documentation writing for humans)</a></p><p><strong>Metadata</strong>:</p><ul><li><strong>Phase</strong>: 1 (Foundations)</li><li><strong>Week</strong>: 4</li><li><strong>Prerequisites</strong>: 9520, 9504, 9503</li><li><strong>Concepts</strong>: Unit tests, integration tests, TDD, property-based testing, coverage, formal verification</li><li><strong>Next Concepts</strong>: Documentation, technical writing, teaching</li><li><strong>Plant Lens</strong>: Observing garden health, soil checks (unit), water flow (integration), ecosystem (e2e)</li></ul><h2></h2><p><div style=\"text-align: center; opacity: 0.6; font-size: 0.85em; margin-top: 3em; padding-top: 1em; border-top: 1px solid rgba(139, 116, 94, 0.2);\"></p><p><strong>Copyright © 2025 <a href='https://codeberg.org/kae3g/12025-10/'>kae3g</a></strong> | Dual-licensed under <a href='https://www.apache.org/licenses/LICENSE-2.0'>Apache-2.0</a> / <a href='https://opensource.org/licenses/MIT'>MIT</a><br /> Competitive technology in service of clarity and beauty</p><p></div></p><p><em><a href='/12025-10/hidden-docs-index.html'>View Hidden Docs Index</a></em> | <em><a href='/12025-10/'>Return to Main Index</a></em></p>",
  "hash" : "2025-10-22T15:17:39.429600161Z-12490"
}