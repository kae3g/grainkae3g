{
  "slug" : "9560-text-files-universal-format",
  "meta" : {
    "slug" : "9560-text-files-universal-format",
    "title" : "kae3g 9560: Text Files - The Universal Format That Survives",
    "filename" : "9560-text-files-universal-format.md",
    "source-dir" : "hidden"
  },
  "html" : "<h1>kae3g 9560: Text Files - The Universal Format That Survives</h1><p><strong>Phase 1: Foundations & Philosophy</strong> | <strong>Week 3</strong> | <strong>Reading Time: 14 minutes</strong><h2></h2></p><h2>What You'll Learn</h2><ul><li>Why plain text outlasts all proprietary formats</li><li>How text files enable the Unix philosophy</li><li>Text vs binary: trade-offs and when each matters</li><li>Markup languages: Markdown, HTML, LaTeX, EDN</li><li>Why configuration as text is powerful</li><li>The longevity argument: Will your files be readable in 50 years?</li><li>How the House of Wisdom preserved knowledge through text<h2></h2></li></ul><h2>Prerequisites</h2><ul><li><strong><a href='/12025-10/9510-unix-philosophy-do-one-thing-well'>9510: Unix Philosophy</a></strong> - Text as universal interface</li><li><strong><a href='/12025-10/9550-command-line-your-primary-interface'>9550: The Command Line</a></strong> - Working with text<h2></h2></li></ul><h2>The Universal Format</h2><p><strong>Text files are</strong>:</p><ul><li>Human-readable (open with any editor)</li><li>Platform-independent (same on Linux, macOS, Windows)</li><li>Tool-agnostic (grep, sed, awk, cat all work)</li><li>Future-proof (readable in decades)</li><li>Version-controllable (Git diffs show what changed)</li><li>Composable (Unix pipes work on text)</li></ul><p><strong>This is why</strong> configuration files, source code, documentation, logs, and data formats all default to <strong>text</strong>.</p><p><strong>Example</strong>:</p><p><strong>Text file</strong> (<code>.txt</code>, <code>.md</code>, <code>.json</code>, <code>.xml</code>):</p><pre><code>You can read this!\nOpen it with any program.\nIt will still be readable in 2075.\n</code></pre><p><strong>Binary file</strong> (<code>.docx</code>, <code>.pdf</code>, <code>.xlsx</code>, <code>.psd</code>):</p><pre><code>ÐÏࡱá&gt;þÿ þÿÿÿ ÿÿÿÿÿÿÿÿÿÿ...\n&#40;Requires specific software to decode&#41;\n&#40;Might not be readable in 2075&#41;\n</code></pre><h2></h2><h2>Text vs Binary</h2><h3>When Text Wins</h3><p><strong>Use text for</strong>:</p><ul><li><strong>Configuration</strong> (<code>.json</code>, <code>.yaml</code>, <code>.toml</code>, <code>.edn</code>)</li><li><strong>Source code</strong> (<code>.clj</code>, <code>.py</code>, <code>.rs</code>, <code>.nix</code>)</li><li><strong>Documentation</strong> (<code>.md</code>, <code>.txt</code>, <code>.org</code>)</li><li><strong>Data exchange</strong> (JSON, CSV, EDN)</li><li><strong>Logs</strong> (application logs, system logs)</li></ul><p><strong>Why</strong>:</p><ul><li>Human-editable (no special tools)</li><li>Searchable (<code>grep &quot;error&quot; log.txt</code>)</li><li>Diffable (<code>git diff</code> shows changes)</li><li>Debuggable (read the file, understand what's wrong)</li></ul><h3>When Binary Wins</h3><p><strong>Use binary for</strong>:</p><ul><li><strong>Images</strong> (<code>.png</code>, <code>.jpg</code> - pixels are binary data)</li><li><strong>Video/Audio</strong> (<code>.mp4</code>, <code>.mp3</code> - waveforms are binary)</li><li><strong>Compiled code</strong> (<code>.exe</code>, <code>.so</code> - machine instructions)</li><li><strong>Databases</strong> (SQLite, Postgres - optimized binary formats)</li><li><strong>Large datasets</strong> (Parquet, HDF5 - compression + fast access)</li></ul><p><strong>Why</strong>:</p><ul><li><strong>Compact</strong> (images/video/audio are huge as text)</li><li><strong>Fast</strong> (binary parsing is faster than text parsing)</li><li><strong>Specialized</strong> (structured for specific use case)</li></ul><p><strong>Trade-off</strong>: Binary is <strong>efficient</strong>, text is <strong>durable</strong>.<h2></h2></p><h2>The Longevity Argument</h2><p><strong>Question</strong>: Will your files be readable in 50 years?</p><h3>Text Files: High Probability</h3><p><strong>ASCII</strong> (1963) is <strong>still readable</strong> today (62 years later).</p><p><strong>UTF-8</strong> (1993) is <strong>backward-compatible</strong> with ASCII (32 years and counting).</p><p><strong>Markdown</strong> (2004) is still the dominant lightweight markup (21 years).</p><p><strong>Prediction</strong>: Plain text in UTF-8 will be readable in <strong>2075</strong> (50 years from now).</p><p><strong>Why</strong>: Text is <strong>simple</strong> (just character sequences). No complex spec to change.</p><h3>Binary Files: Low Probability</h3><p><strong>Microsoft Word <code>.doc</code> format</strong> (1983-2003):</p><ul><li><strong>Replaced</strong> by <code>.docx</code> (2007, incompatible format!)</li><li>Old <code>.doc</code> files <strong>require</strong> old software (or imperfect converters)</li><li>In 2075? Good luck finding a <code>.doc</code> reader.</li></ul><p><strong>Adobe Photoshop <code>.psd</code></strong> (1990):</p><ul><li>Proprietary format (Adobe doesn't fully document it)</li><li>Requires Photoshop (or GIMP with imperfect PSD support)</li><li>In 2075? Maybe Adobe still exists. Maybe not.</li></ul><p><strong>PDF</strong> (1993):</p><ul><li>Better (open spec since 2008)</li><li>But: Complex (ISO 32000, 700+ page spec)</li><li>Features break (embedded fonts, JavaScript, DRM)</li><li>In 2075? Probably readable, but some features lost.</li></ul><p><strong>Plant lens</strong>: <strong>\"Seeds (text) survive centuries in the seed bank. Fruit (binary) rots quickly.\"</strong><h2></h2></p><h2>Markup Languages: Text with Structure</h2><p><strong>Plain text is great</strong>, but sometimes you need <strong>structure</strong> (headings, lists, links).</p><p><strong>Markup languages</strong> add structure <strong>while remaining text</strong>.</p><h3>Markdown (2004, John Gruber)</h3><p><strong>Designed for</strong>: Human-readable documents that convert to HTML.</p><pre><code class=\"markdown\"><pre><code class=\"clojure\">&#40;defn example &#91;&#93; &quot;Code block&quot;&#41;\n</code></pre><pre><code><pre><code class=\"html\">&lt;h1&gt;Heading&lt;/h1&gt;\n&lt;p&gt;This is a &lt;strong&gt;paragraph&lt;/strong&gt; with &lt;em&gt;emphasis&lt;/em&gt;.&lt;/p&gt;\n&lt;ul&gt;\n  &lt;li&gt;List item&lt;/li&gt;\n&lt;/ul&gt;\n</code></pre><p><strong>More verbose than Markdown</strong>, but more <strong>powerful</strong> (CSS, JavaScript, semantic tags).</p><p><strong>Still text!</strong> (Can edit with any editor.)</p><h3>LaTeX (1984, Leslie Lamport)</h3><p><strong>For academic papers, mathematics</strong>:</p><pre><code class=\"latex\">\\documentclass{article}\n\\begin{document}\n\n\\section{Introduction}\nEinstein's equation: $E = mc&#94;2$\n\n\\begin{equation}\n\\int&#95;{0}&#94;{\\infty} e&#94;{-x&#94;2} dx = \\frac{\\sqrt{\\pi}}{2}\n\\end{equation}\n\n\\end{document}\n</code></pre><p><strong>Complex</strong>, but produces <strong>beautiful PDFs</strong> (especially for math).</p><p><strong>Still text</strong> (version-controllable, diff-able).</p><h3>EDN (Extensible Data Notation, Clojure)</h3><p><strong>For data</strong> (not documents):</p><pre><code class=\"clojure\">{:user {:name &quot;Alice&quot;\n        :age 30\n        :roles #{:admin :developer}}\n :timestamp #inst &quot;2025-10-10T23:00:00Z&quot;\n :config {:theme :dark\n          :font-size 14}}\n</code></pre><p><strong>Human-readable Clojure data</strong>.</p><p><strong>Why EDN</strong> (vs JSON):</p><ul><li><strong>Richer types</strong> (sets, keywords, instants, symbols)</li><li><strong>Comments</strong> (JSON doesn't allow!)</li><li><strong>Code is data</strong> (homoiconicity—can eval if needed)</li></ul><p><strong>We use EDN</strong> in our build pipeline (see <code>scripts/writings&#95;build.clj</code>).<h2></h2></p><h2>Configuration as Text: The Unix Way</h2><p><strong>Bad</strong> (binary config):</p><ul><li>Windows Registry (binary database, opaque, hard to edit/backup)</li><li>Some apps: SQLite for config (overkill, not human-editable)</li></ul><p><strong>Good</strong> (text config):</p><ul><li>Unix: <code>/etc/</code> full of text files (<code>/etc/hosts</code>, <code>/etc/ssh/sshd&#95;config</code>)</li><li>Apps: <code>.json</code>, <code>.yaml</code>, <code>.toml</code> in <code>&#126;/.config/</code></li></ul><p><strong>Why text config wins</strong>:</p><h3>1. Version Control</h3><pre><code class=\"bash\"># Track config changes\ngit init &#126;/.config/my-app\ncd &#126;/.config/my-app\ngit add config.yaml\ngit commit -m &quot;Initial config&quot;\n\n# Change something\nvim config.yaml\ngit diff  # See EXACTLY what changed\n\ngit commit -m &quot;Increase font size&quot;\n\n# Broke something? Revert!\ngit revert HEAD\n</code></pre><p><strong>Can't do this</strong> with binary config (Registry, binary plists).</p><h3>2. Human Editable</h3><pre><code class=\"yaml\"># config.yaml - I can READ this!\ntheme: dark\nfont-size: 14\nkeybindings:\n  save: Ctrl-S\n  quit: Ctrl-Q\n</code></pre><p><strong>No special tool needed.</strong> Any editor works.</p><h3>3. Portable</h3><p><strong>Text config</strong> (copy file → works on new machine):<pre><code class=\"bash\">scp &#126;/.config/app/config.yaml newmachine:&#126;/.config/app/\n# Done! Config transferred.\n</code></pre></p><p><strong>Binary config</strong>: Export, import, hope formats match, pray nothing breaks.<h2></h2></p><h2>The Preservation Argument</h2><p><strong>House of Wisdom scholars</strong> (Essay 9505) preserved Greek knowledge by <strong>copying manuscripts</strong> (text).</p><p><strong>We preserve computational knowledge</strong> through <strong>text files</strong>:</p><h3>Example: Source Code</h3><p><strong>1970s</strong>: Unix source code (text files, C language)<br /> <strong>2025</strong>: <strong>Still readable!</strong> (You can compile 1970s Unix today.)</p><p><strong>1980s</strong>: Lisp source code (MIT AI Lab)<br /> <strong>2025</strong>: <strong>Still readable!</strong> (You can run 1980s Lisp today.)</p><p><strong>Contrast</strong>:</p><p><strong>1990s</strong>: Visual Basic <code>.frm</code> files (binary forms)<br /> <strong>2025</strong>: <strong>Mostly unreadable</strong> (tools gone, formats forgotten).</p><p><strong>2000s</strong>: Flash <code>.fla</code> files (proprietary)<br /> <strong>2025</strong>: <strong>Dead</strong> (Adobe killed Flash, files orphaned).</p><p><strong>Text survives. Binary rots.</strong></p><p><strong>Plant lens</strong>: <strong>\"Text is the seed (preserves genetic information). Binary is the fruit (delicious now, rots quickly).\"</strong><h2></h2></p><h2>Practical Text Mastery</h2><h3>Format Recommendations</h3><p><strong>For documentation</strong>: <strong>Markdown</strong> (<code>.md</code>)</p><ul><li>Simple, readable, convertible</li><li>GitHub renders it automatically</li><li>This entire valley uses it!</li></ul><p><strong>For configuration</strong>: <strong>YAML</strong> or <strong>TOML</strong> or <strong>EDN</strong></p><ul><li>YAML: Human-friendly (Python, Ruby communities)</li><li>TOML: Simple, explicit (Rust community - <code>Cargo.toml</code>)</li><li>EDN: Clojure data (our choice - homoiconic!)</li></ul><p><strong>For data exchange</strong>: <strong>JSON</strong> or <strong>EDN</strong> or <strong>CSV</strong></p><ul><li>JSON: Universal (every language parses it)</li><li>EDN: Richer (if Clojure is your ecosystem)</li><li>CSV: Simple (spreadsheets, data analysis)</li></ul><p><strong>For academic writing</strong>: <strong>LaTeX</strong> or <strong>Markdown</strong> → PDF</p><ul><li>LaTeX: Maximum control (beautiful math)</li><li>Markdown + Pandoc: Simpler (good enough for most)</li></ul><p><strong>For code</strong>: Whatever your language uses (<code>.clj</code>, <code>.py</code>, <code>.rs</code>, etc.)</p><ul><li>Always text!</li><li>Even \"compiled\" languages start with text source<h2></h2></li></ul><h2>Try This</h2><h3>Exercise 1: Text File Archaeology</h3><p><strong>Find old text files</strong> on your computer:<pre><code class=\"bash\"># Find .txt files modified &gt; 5 years ago\nfind &#126; -name &quot;&#42;.txt&quot; -mtime +1825\n\n# Can you still read them? &#40;Probably yes!&#41;\n</code></pre></p><p><strong>Now find old Word docs</strong>:<pre><code class=\"bash\">find &#126; -name &quot;&#42;.doc&quot;  # Old Word format\n\n# Can you still open them? &#40;Maybe, with Word or converter&#41;\n# Will you be able to in 2050? &#40;Uncertain&#41;\n</code></pre></p><p><strong>Text wins for longevity.</strong><h2></h2></p><h3>Exercise 2: Convert to Text</h3><p><strong>Take a binary format</strong> you use (Word doc, Pages, Google Doc).</p><p><strong>Convert to Markdown</strong>:</p><ol><li>Copy text</li><li>Paste into plain text editor</li><li>Add Markdown formatting (# for headings, ** for bold)</li><li>Save as <code>.md</code></li></ol><p><strong>Now</strong>:</p><ul><li>Version control it (<code>git add essay.md</code>)</li><li>Edit with any tool (Vim, VS Code, Notepad)</li><li>Convert to HTML (<code>pandoc essay.md -o essay.html</code>)</li><li>Future-proof (still readable in 50 years)<h2></h2></li></ul><h3>Exercise 3: Explore Markup</h3><p><strong>Write the same content</strong> in three formats:</p><p><strong>Plain text</strong>:</p><pre><code>My Essay Title\n\nThis is the introduction.\n\nSection 1\n---------\nContent here.\n</code></pre><p><strong>Markdown</strong>:<pre><code class=\"markdown\"># My Essay Title\n\nThis is the introduction.\n\n## Section 1\nContent here.\n</code></pre></p><p><strong>HTML</strong>:<pre><code class=\"html\">&lt;h1&gt;My Essay Title&lt;/h1&gt;\n&lt;p&gt;This is the introduction.&lt;/p&gt;\n&lt;h2&gt;Section 1&lt;/h2&gt;\n&lt;p&gt;Content here.&lt;/p&gt;\n</code></pre></p><p><strong>Observe</strong>: All three are <strong>text</strong> (human-readable). Markdown is the sweet spot (simple + structured).<h2></h2></p><h2>Going Deeper</h2><h3>Related Essays</h3><ul><li><strong><a href='/12025-10/9510-unix-philosophy-do-one-thing-well'>9510: Unix Philosophy</a></strong> - Text as universal interface</li><li><strong><a href='/12025-10/9550-command-line-your-primary-interface'>9550: Command Line</a></strong> - Tools for text processing</li><li><strong><a href='/12025-10/9505-house-of-wisdom-knowledge-gardens'>9505: House of Wisdom</a></strong> - Preserving knowledge through text</li><li><strong><a href='/12025-10/9570-processes-programs-in-motion'>9570: Processes</a></strong> - What runs when you edit text files</li></ul><h3>External Resources</h3><ul><li><strong>\"The Art of Unix Programming\"</strong> - Eric Raymond on text file philosophy</li><li><strong><a href='https://www.markdownguide.org/'>Markdown Guide</a></strong> - Comprehensive Markdown reference</li><li><strong>Pandoc</strong> - Universal document converter (Markdown → everything)</li><li><strong>Plain Text Project</strong> - Advocacy for text-based workflows<h2></h2></li></ul><h2>Reflection Questions</h2><ol><li><strong>Why do apps keep reinventing proprietary formats?</strong> (Lock-in? Performance? Ignorance of text?)</li><li><strong>Is there ANYTHING that shouldn't be text?</strong> (Images, video, audio—but metadata could be!)</li><li><strong>Will UTF-8 still be readable in 2100?</strong> (Probably—it's simple enough to be eternal)</li><li><strong>How much of your important data is in proprietary formats?</strong> (Photos? Documents? Should you convert some to open formats?)</li><li><strong>What's the oldest text file you've successfully opened?</strong> (Mine: 1990s .txt files, perfectly readable)<h2></h2></li></ol><h2>Summary</h2><p><strong>Text files are</strong>:</p><ul><li><strong>Human-readable</strong> (open with any editor)</li><li><strong>Platform-independent</strong> (work everywhere)</li><li><strong>Tool-agnostic</strong> (any program can process text)</li><li><strong>Future-proof</strong> (will outlast proprietary formats)</li><li><strong>Version-controllable</strong> (Git works perfectly with text)</li><li><strong>Composable</strong> (Unix philosophy in action)</li></ul><p><strong>Key Insights</strong>:</p><ul><li><strong>Text survives</strong> (50+ year old text files still readable)</li><li><strong>Binary rots</strong> (proprietary formats become unreadable)</li><li><strong>Markup adds structure</strong> (Markdown, HTML, LaTeX - still text!)</li><li><strong>Configuration as text</strong> enables version control, portability</li><li><strong>Simple formats last</strong> (ASCII, UTF-8 vs complex binary specs)</li></ul><p><strong>Markup Languages</strong>:</p><ul><li><strong>Markdown</strong>: Documents (simple, readable)</li><li><strong>HTML</strong>: Web pages (powerful, verbose)</li><li><strong>LaTeX</strong>: Academic papers (beautiful math)</li><li><strong>EDN</strong>: Data (Clojure homoiconic format)</li></ul><p><strong>In the Valley</strong>:</p><ul><li><strong>Everything is text</strong> (essays in Markdown, config in EDN, code in Clojure)</li><li><strong>Future-proofing</strong> (plain text survives format churn)</li><li><strong>Git for everything</strong> (version control requires text)</li><li><strong>Following Unix</strong> (text as universal interface)</li></ul><p><strong>Plant lens</strong>: <strong>\"Text is the seed—preserves the genetic code through winters. Binary is the fruit—nourishes now, but doesn't preserve long-term.\"</strong><h2></h2></p><p><strong>Next</strong>: We'll explore <strong>processes</strong>—programs in motion, the living manifestation of your text source code!<h2></h2></p><p><strong>Navigation</strong>:<br /> ← Previous: <a href='/12025-10/9550-command-line-your-primary-interface'>9550 (command line your primary interface)</a> | <strong>Phase 1 Index</strong> | Next: <a href='/12025-10/9570-processes-programs-in-motion'>9570 (processes programs in motion)</a></p><p><strong>Metadata</strong>:</p><ul><li><strong>Phase</strong>: 1 (Foundations)</li><li><strong>Week</strong>: 3</li><li><strong>Prerequisites</strong>: 9510, 9550</li><li><strong>Concepts</strong>: Text files, plain text, markup languages, binary vs text, longevity, version control</li><li><strong>Next Concepts</strong>: Processes, programs, execution, memory, CPU</li></ul><h2></h2><p><div style=\"text-align: center; opacity: 0.6; font-size: 0.85em; margin-top: 3em; padding-top: 1em; border-top: 1px solid rgba(139, 116, 94, 0.2);\"></p><p><strong>Copyright © 2025 <a href='https://codeberg.org/kae3g/12025-10/'>kae3g</a></strong> | Dual-licensed under <a href='https://www.apache.org/licenses/LICENSE-2.0'>Apache-2.0</a> / <a href='https://opensource.org/licenses/MIT'>MIT</a><br /> Competitive technology in service of clarity and beauty</p><p></div></p><p><em><a href='/12025-10/hidden-docs-index.html'>View Hidden Docs Index</a></em> | <em><a href='/12025-10/'>Return to Main Index</a></em></p>",
  "hash" : "2025-10-22T15:17:39.429227723Z-14029"
}