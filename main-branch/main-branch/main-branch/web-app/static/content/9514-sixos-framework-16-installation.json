{
  "slug" : "9514-sixos-framework-16-installation",
  "meta" : {
    "slug" : "9514-sixos-framework-16-installation",
    "title" : "kae3g 9514: SixOS on Framework 16 - The Gentle Gardener's Installation Guide",
    "filename" : "9514-sixos-framework-16-installation.md",
    "source-dir" : "hidden"
  },
  "html" : "<h1>kae3g 9514: SixOS on Framework 16 - The Gentle Gardener's Installation Guide</h1><p><strong>Phase 1: Foundations & Philosophy</strong> | <strong>Week 2</strong> | <strong>Deep Dive</strong> | <strong>Reading Time: 30 minutes</strong></p><p><strong>Optional Essay</strong>: This is a practical guide to building the Grainstore and installing SixOS on your Framework 16 laptop! Read <a href='/12025-10/9513-personal-sovereignty-framework-stack'>9513 (Personal Sovereignty)</a> first for context.<h2></h2></p><h2>What You'll Learn (Deep Dive)</h2><p><strong>This essay guides you through sovereign computing</strong>:</p><ul><li><strong>The Grainstore Strategy</strong> - Why we need sovereign dependencies</li><li><strong>Building the Grainstore</strong> - s6, runit, and eternal specifications</li><li><strong>Framework 16 hardware</strong> preparation (AMD Ryzen 7040 series)</li><li><strong>SixOS boot image</strong> creation and installation</li><li><strong>s6 supervision system</strong> setup (replacing systemd)</li><li><strong>Wayland + Hyprland</strong> compositor configuration</li><li><strong>Essential applications</strong> from the Grainstore</li><li><strong>Debugging</strong> common installation issues<h2></h2></li></ul><h2>Prerequisites</h2><ul><li><strong><a href='/12025-10/9513-personal-sovereignty-framework-stack'>9513: Personal Sovereignty Stack</a></strong> - Hardware context</li><li><strong><a href='/12025-10/9952-sixos-introduction'>9952: SixOS Introduction</a></strong> - SixOS concepts</li><li><strong><a href='/12025-10/9956-openrc-runit-mastery'>9956: OpenRC & runit Mastery</a></strong> - Init systems</li><li><strong><a href='/12025-10/9500-what-is-a-computer'>9500: What Is a Computer?</a></strong> - Hardware foundations</li><li><strong><a href='/12025-10/9503-what-is-nock'>9503: What Is Nock?</a></strong> - Specification language<h2></h2></li></ul><h2>Part 0: The Grainstore - Saving Seeds for Century-Scale Software</h2><p><strong>Before we install SixOS, we need to understand the Grainstore.</strong></p><h3>Why a Grainstore?</h3><blockquote><p> <strong>\"In permaculture, we save seeds from the best plants. We don't rely on buying new seeds every season from corporations that might disappear, might change terms, might lock us out. We maintain our own grainhouse—a storehouse of genetic diversity, resilience, independence.\"</strong> <br /> — SixOS, the Gentle Gardener (Essay 9960) </p></blockquote><p><strong>The Problem</strong>: When you install SixOS, you depend on:</p><ul><li><strong>s6</strong> (process supervision) - maintained upstream by skarnet</li><li><strong>runit</strong> (crash-only init) - maintained by Gerrit Pape</li><li><strong>musl-libc</strong> (C library) - maintained by musl project</li><li><strong>wayland</strong> (display protocol) - maintained by freedesktop.org</li></ul><p><strong>What if upstream breaks? What if maintainers disappear? What if breaking changes arrive?</strong></p><p><strong>The Solution</strong>: Build a <strong>Grainstore</strong> - our own verified, eternal versions.</p><h3>The Grainstore Architecture</h3><pre><code class=\"clojure\">{:grainstore-philosophy\n {:problem &quot;Upstream dependency fragility&quot;\n  :solution &quot;Vendor and verify critical dependencies&quot;\n  :method &quot;Nock specifications + formal proofs&quot;\n  :goal &quot;Century-scale software independence&quot;\n  \n  :layers\n  {:specifications &quot;Nock specs &#40;eternal, mathematical&#41;&quot;\n   :implementations &quot;Clojure/Rust/C &#40;practical, testable&#41;&quot;\n   :tests &quot;100% verified equivalence&quot;\n   :jets &quot;Optimized hot paths&quot;}}}\n</code></pre><p><strong>Every dependency in the Grainstore</strong>:</p><ol><li><strong>Has a Nock specification</strong> (mathematical essence, frozen forever)</li><li><strong>Has a Clojure implementation</strong> (practical, testable, fast development)</li><li><strong>Has a complete test suite</strong> (100% passing, equivalence proven)</li><li><strong>Has equivalence notes</strong> (formal proof Clojure ↔ Nock ↔ C)</li><li><strong>Can be optimized with jets</strong> (C/Rust for hot paths)</li></ol><h3>Understanding s6: The Minimalist Maestro</h3><p><strong>Before we check the Grainstore status, let's understand what s6 actually IS.</strong></p><h4>What is s6?</h4><p><strong>s6</strong> is a <strong>process supervision suite</strong> created by Laurent Bercot (skarnet). It's the spiritual successor to Dan Bernstein's daemontools, designed with one goal: <strong>do process supervision right</strong>.</p><p><strong>Key Facts</strong>:</p><ul><li><strong>Size</strong>: ~200KB (vs systemd's 1.5MB+)</li><li><strong>Age</strong>: First released 2011, mature and stable</li><li><strong>Philosophy</strong>: Unix philosophy - do one thing well</li><li><strong>Design</strong>: Crash-only semantics from the ground up</li></ul><h4>The s6 Suite (Six Tools, Six Purposes)</h4><p>s6 is actually a <strong>family of tools</strong>, each with a specific job:</p><ol><li><strong>s6</strong> - Core supervision (process monitoring)</li><li><strong>s6-rc</strong> - Service management (dependencies, bundles)</li><li><strong>s6-linux-init</strong> - Complete init system for Linux</li><li><strong>s6-portable-utils</strong> - Portable Unix utilities</li><li><strong>s6-networking</strong> - Network services and utilities</li><li><strong>execline</strong> - Non-interactive scripting language</li></ol><p><strong>For SixOS, we primarily use</strong>: s6 + s6-rc + s6-linux-init</p><h4>How s6 Works: The Mental Model</h4><p><strong>Think of s6 as a tree of watchers</strong>:</p><pre><code>s6-svscan &#40;root supervisor&#41;\n    ├─ s6-supervise → service1/run\n    ├─ s6-supervise → service2/run\n    ├─ s6-supervise → service3/run\n    └─ s6-supervise → logger/run\n</code></pre><p><strong>Each s6-supervise</strong>:</p><ul><li>Watches ONE service</li><li>Restarts it if it crashes</li><li>Logs its output</li><li>Reports its status</li></ul><p><strong>The s6-svscan</strong>:</p><ul><li>Scans the supervision tree</li><li>Starts s6-supervise for each service</li><li>Handles the overall supervision</li></ul><h4>Service Directories: Everything is a File</h4><p><strong>In s6, a service is just a directory</strong>:</p><pre><code>/etc/s6/sv/dbus/\n├── run            # How to start the service\n├── finish         # What to do when it stops &#40;optional&#41;\n├── notification-fd # How to signal readiness &#40;optional&#41;\n└── down           # Don't auto-start &#40;optional&#41;\n</code></pre><p><strong>The <code>run</code> script</strong> (example):<pre><code class=\"bash\">#!/bin/sh\nexec dbus-daemon --system --nofork\n</code></pre></p><p><strong>Key principles</strong>:</p><ul><li>Must run in <strong>foreground</strong> (no daemonizing!)</li><li>Must use <code>exec</code> (replace shell with service process)</li><li>Must handle <strong>signals</strong> properly (TERM for graceful, KILL for force)</li></ul><h4>Why s6 Over systemd?</h4><p><strong>s6 advantages</strong>:</p><ul><li>✅ <strong>Minimal</strong> - 200KB vs 1.5MB</li><li>✅ <strong>Simple</strong> - Service = directory with run script</li><li>✅ <strong>Auditable</strong> - Small codebase, clear design</li><li>✅ <strong>Crash-only</strong> - Embraces failure as normal</li><li>✅ <strong>No dependencies</strong> - Runs on any Unix</li><li>✅ <strong>Fast</strong> - Extremely fast startup</li><li>✅ <strong>Portable</strong> - Works on Linux, BSD, embedded</li></ul><p><strong>systemd tradeoffs</strong>:</p><ul><li>⚠️ <strong>Large</strong> - 1.5MB+ binary, huge codebase</li><li>⚠️ <strong>Complex</strong> - Many features = many edge cases</li><li>⚠️ <strong>Linux-only</strong> - Won't work on BSD</li><li>⚠️ <strong>Binary config</strong> - Not human-editable</li><li>⚠️ <strong>Tightly integrated</strong> - Hard to replace components</li></ul><p><strong>The s6 philosophy</strong>: \"If systemd is a Swiss Army knife, s6 is a scalpel.\"</p><h4>s6 in the Wild</h4><p><strong>Used by</strong>:</p><ul><li>Alpine Linux (minimal container distro)</li><li>Void Linux (runit is similar, some use s6)</li><li>Artix Linux (one of the init options)</li><li>SixOS (NixOS without systemd!)</li><li>Embedded systems (routers, IoT)</li><li>Container images (minimal supervision)</li></ul><p><strong>Real-world scenarios</strong>:</p><ul><li>Docker containers needing lightweight init</li><li>Embedded Linux on routers/devices</li><li>Servers that need simple, reliable supervision</li><li>Personal machines prioritizing simplicity</li></ul><h4>Learning s6: The Gentle Path</h4><p><strong>Start simple</strong>:</p><ol><li><strong>Read one service definition</strong> - See how <code>run</code> scripts work</li><li><strong>Create a test service</strong> - Make your own <code>run</code> script</li><li><strong>Watch it supervise</strong> - See automatic restarts</li><li><strong>Add dependencies</strong> - Learn s6-rc bundles</li><li><strong>Understand logging</strong> - s6-log for structured logs</li></ol><p><strong>The beauty</strong>: Once you understand <strong>one service directory</strong>, you understand <strong>all of them</strong>. No special syntax, no configuration language—just shell scripts and filesystem structure.</p><h4>s6 and Nock: Perfect Alignment</h4><p><strong>Why s6 matters for the Grainstore</strong>:</p><pre><code class=\"clojure\">{:s6-nock-alignment\n {:simplicity &quot;s6 has &#126;10 core operations, Nock has 12 rules&quot;\n  :purity &quot;s6 supervision is pure &#40;state → state&#41;&quot;\n  :verifiability &quot;Small codebase is auditable&quot;\n  :eternality &quot;Design won't change &#40;like Nock&#41;&quot;\n  :sovereignty &quot;We can fork, verify, maintain forever&quot;}}\n</code></pre><p><strong>s6 is to init systems what Nock is to computation</strong>:</p><ul><li>Small core (200KB vs 12 rules)</li><li>Simple operations (supervise, log, status)</li><li>Pure semantics (no hidden state)</li><li>Mathematically specifiable (we did it!)</li></ul><p><strong>This is why we chose s6 for the Grainstore.</strong><h2></h2></p><h2>Understanding s6: Process Supervision as Natural Vortices</h2><p>Before we dive into the Grainstore status, let's understand <strong>what s6 actually is</strong> and why it embodies the Coldriver Heal philosophy.</p><h3>What is s6?</h3><p><strong>s6</strong> is a suite of programs for process supervision and service management on Unix-like systems. Created by Laurent Bercot (skarnet.org), it's a lightweight alternative to monolithic init systems like systemd.</p><p><strong>Key Characteristics</strong>:</p><ul><li><strong>Small</strong>: ~200KB total (vs systemd's 1.5MB+)</li><li><strong>Secure</strong>: Least privilege by design, no SUID binaries</li><li><strong>Composable</strong>: ~30 small tools that follow Unix philosophy</li><li><strong>Crash-only</strong>: Services exit cleanly, supervisor restarts them</li><li><strong>Deterministic</strong>: No hidden state, predictable behavior</li></ul><p>In Coldriver Heal terms, s6 is <strong>precision flow engineering</strong>:</p><ul><li><strong>Cold</strong>: Small, auditable codebase (formal verification possible)</li><li><strong>Water</strong>: Process supervision as natural vortices (self-organizing)</li><li><strong>Heal</strong>: Crash-only design means continuous regeneration</li></ul><h3>The s6 Suite: Core Tools</h3><p>s6 isn't one program but a <strong>collection of composable tools</strong>. Here are the essential ones:</p><h4>1. s6-svscan (The Scanner)</h4><p>The root supervisor. It scans a directory (typically <code>/service</code>) for service folders and launches <code>s6-supervise</code> for each.</p><p><strong>Mental Model</strong>: Like a spring source in Schauberger's watershed—the origin point from which all process flows emerge.</p><pre><code class=\"bash\"># s6-svscan runs as PID 1 in minimal systems\ns6-svscan /service\n</code></pre><h4>2. s6-supervise (The Watcher)</h4><p>Monitors a single service. Runs the <code>run</code> script, restarts on exit, handles logging.</p><p><strong>Mental Model</strong>: Like a vortex that maintains organized flow—if a process \"evaporates\" (crashes), it \"condenses\" back (restarts).</p><pre><code class=\"bash\"># s6-supervise watches one service\ns6-supervise /service/myservice\n</code></pre><h4>3. s6-svc (The Controller)</h4><p>Command-line tool to manage services: start, stop, restart, signal.</p><p><strong>Mental Model</strong>: The precision valve—direct control over process flow with mathematical certainty.</p><pre><code class=\"bash\">s6-svc -u /service/nginx  # Start &#40;up&#41;\ns6-svc -d /service/nginx  # Stop &#40;down&#41;\ns6-svc -r /service/nginx  # Restart\ns6-svc -t /service/nginx  # Send TERM signal\n</code></pre><h4>4. s6-log (The Logger)</h4><p>Handles logging with rotation and filtering. Pipes output to log directories.</p><p><strong>Mental Model</strong>: Like sediment deposition in a river—logs accumulate naturally, organized by time and flow.</p><pre><code class=\"bash\"># Typical log run script\n#!/bin/execlineb -P\ns6-log n20 s1000000 /var/log/myservice\n# Keep 20 files, 1MB each\n</code></pre><h4>5. execline (The Scripting Helper)</h4><p>A non-interactive shell for <code>run</code> scripts. Avoids bash pitfalls, uses simple chaining.</p><p><strong>Mental Model</strong>: Like water flowing through precisely engineered channels—no turbulence, just clean flow.</p><pre><code class=\"bash\">#!/usr/bin/execlineb -S0\n# Chain commands with foreground\nforeground { mkdir -p /var/run/nginx }\nforeground { chown www-data /var/run/nginx }\nnginx -g &quot;daemon off;&quot;\n</code></pre><h3>Mental Model: The Supervision Tree as Natural Vortices</h3><p>Think of s6 as a <strong>watershed system</strong>:</p><pre><code>s6-svscan &#40;PID 1&#41; = Spring source\n    |\n    ├── s6-supervise &#40;service-1&#41; = Tributary 1\n    |       ├── run &#40;daemon process&#41; = Water flow\n    |       └── log &#40;s6-log&#41; = Sediment deposition\n    |\n    ├── s6-supervise &#40;service-2&#41; = Tributary 2\n    |       ├── run &#40;daemon process&#41;\n    |       └── log &#40;s6-log&#41;\n    |\n    └── s6-supervise &#40;service-3&#41; = Tributary 3\n            ├── run &#40;daemon process&#41;\n            └── log &#40;s6-log&#41;\n</code></pre><p><strong>Properties of this system</strong>:</p><ul><li><strong>Self-organizing</strong>: Services start/stop independently</li><li><strong>Resilient</strong>: Each vortex (service) maintains itself</li><li><strong>Observable</strong>: Logs flow naturally to designated channels</li><li><strong>Composable</strong>: Add/remove services by symlinking directories</li></ul><h3>Service Directories: Filesystem as Configuration</h3><p>s6 uses <strong>directories for configuration</strong>—simple, readable, no XML/INI bloat.</p><p><strong>Structure for service <code>myservice</code></strong>:</p><pre><code>/service/myservice/\n    ├── run           # Executable script launching daemon\n    ├── finish        # Optional cleanup on exit\n    ├── type          # &quot;longrun&quot; &#40;default&#41; or &quot;oneshot&quot;\n    ├── notification-fd  # FD for readiness notification\n    └── log/          # Logging configuration\n        └── run       # Script for s6-log\n</code></pre><p><strong>Example <code>run</code> script</strong>:<pre><code class=\"bash\">#!/usr/bin/execlineb -S0\n# Set up environment\nforeground { mkdir -p /var/run/myservice }\n# Change to unprivileged user\ns6-setuidgid myuser\n# Launch daemon &#40;must stay in foreground!&#41;\nexec /usr/bin/myservice --foreground\n</code></pre></p><p><strong>Example <code>log/run</code> script</strong>:<pre><code class=\"bash\">#!/usr/bin/execlineb -P\ns6-log n20 s1000000 /var/log/myservice\n# Keep 20 files, rotate at 1MB each\n</code></pre></p><p><strong>To activate a service</strong>:<pre><code class=\"bash\"># Create service directory\nmkdir -p /etc/s6/services/myservice\n# Write run script, make executable\n# Symlink to scan directory\nln -s /etc/s6/services/myservice /service/\n# s6-svscan automatically picks it up!\n</code></pre></p><h3>Why s6 Over systemd?</h3><p>This is about <strong>precision flow</strong> vs <strong>monolithic complexity</strong>:</p><table><thead><tr><th>Aspect</th><th>systemd</th><th>s6</th></tr></thead><tbody><tr><td><strong>Size</strong></td><td>1.5MB+</td><td>~200KB</td></tr><tr><td><strong>Dependencies</strong></td><td>Many</td><td>Minimal</td></tr><tr><td><strong>Logs</strong></td><td>Binary (journald)</td><td>Plain text</td></tr><tr><td><strong>Complexity</strong></td><td>Monolithic</td><td>Composable tools</td></tr><tr><td><strong>State</strong></td><td>Hidden caches</td><td>Explicit directories</td></tr><tr><td><strong>Philosophy</strong></td><td>Do everything</td><td>Do one thing well</td></tr><tr><td><strong>Sovereignty</strong></td><td>Complex to fork</td><td>Easy to understand/modify</td></tr></tbody></table><p><strong>In Coldriver Heal terms</strong>:</p><p><strong>systemd</strong> = Explosion engineering</p><ul><li>Push outward (scope creep: init + logs + network + time + ...)</li><li>Hidden state (binary logs, caches)</li><li>Centralized control</li></ul><p><strong>s6</strong> = Implosion engineering</p><ul><li>Pull inward (focused: just supervision)</li><li>Visible state (filesystem as database)</li><li>Distributed control (each service independent)</li></ul><h3>s6 in the Wild</h3><p>s6 is battle-tested:</p><ul><li><strong>Void Linux</strong>: Uses runit (s6's cousin) as default init</li><li><strong>Artix Linux</strong>: Offers s6 as systemd-free alternative</li><li><strong>Alpine Linux</strong>: Uses OpenRC, but s6 works great</li><li><strong>Embedded systems</strong>: Where size and simplicity matter</li></ul><p><strong>Community</strong>: skarnet.org has excellent documentation. Laurent Bercot's writing is precise—like Hilbert proofs applied to systems programming.</p><h3>Learning Path: 5 Steps for s6 Mastery</h3><ol><li><strong>Read the docs</strong>: Start with skarnet.org/software/s6/overview.html</li><li><strong>Install s6</strong>: On Void: <code>xbps-install s6</code>, or build from source</li><li><strong>Create simple service</strong>: One directory, one <code>run</code> script</li><li><strong>Add logging</strong>: Set up <code>log/run</code> with s6-log</li><li><strong>Explore s6-rc</strong>: For dependency management between services</li></ol><h3>s6 and Nock Alignment</h3><p>Remember our Grainstore philosophy? s6 <strong>is</strong> that philosophy:</p><p><strong>s6's 30 tools</strong> = Like Nock's 12 rules (minimal basis for complex behavior)<br /> <strong>Crash-only design</strong> = Like Nock reductions (deterministic, no undefined behavior)<br /> <strong>Filesystem configuration</strong> = Like Nock's noun trees (data as structure)<br /> <strong>Plain text logs</strong> = Like Nock's transparency (no hidden binary state)</p><p>In the Coldriver Heal vision:</p><ul><li>s6 provides the <strong>supervision vortices</strong> (Schauberger)</li><li>Each tool is <strong>formally specifiable</strong> (Hilbert)</li><li>The system <strong>regenerates</strong> from directory state (regenesis)</li></ul><p><strong>This is why we chose s6 for SixOS.</strong> It embodies precision flow—small, understandable, eternal.<h2></h2></p><h3>Current Grainstore Status (LIVE!)</h3><pre><code class=\"bash\"># Check what's in the Grainstore\nbb grainstore:status\n</code></pre><p><strong>Output</strong> (as of 2025-10-10):</p><pre><code>🌱 Grainstore Status:\n\nSpecifications:\n  ✓ runit.nock.md &#40;crash-only design&#41;\n  ✓ s6.nock.md &#40;process supervision&#41;\n\nImplementations:\n  ✓ s6.clj &#40;200+ lines, fully verified&#41;\n\nTests:\n  ✓ runit&#95;test.clj &#40;42 assertions, 100% passing!&#41;\n  ✓ s6&#95;test.clj &#40;65 assertions, 100% passing!&#41;\n\n✨ Grainstore is growing!\n</code></pre><p><strong>What This Means</strong>:</p><ul><li><strong>s6</strong> is <strong>fully implemented</strong> - Spec + Code + 65 tests! ✅</li><li><strong>runit</strong> is <strong>fully tested</strong> - Spec + 42 tests! ✅</li><li><strong>107 total assertions</strong> - All passing! ✅</li><li><strong>Both supervision systems</strong> - Mathematically verified! ✅</li></ul><p><strong>Try it yourself</strong>:<pre><code class=\"bash\"># Run all Grainstore tests\nbb grainstore:test\n\n# Expected output:\n# Testing grainstore.s6-test\n# Ran 11 tests containing 65 assertions.\n# 0 failures, 0 errors.\n</code></pre></p><p><strong>This is real, working, verified code!</strong></p><h3>Why This Matters for Your Installation</h3><p><strong>When you install SixOS from the Grainstore</strong>:</p><ul><li>✅ You control the specifications (Nock is eternal)</li><li>✅ You control the implementations (can rewrite in any language)</li><li>✅ You control the verification (tests prove equivalence)</li><li>✅ You control the supply chain (no upstream breakage)</li></ul><p><strong>This isn't just installing software—it's planting seeds that will last centuries.</strong></p><h3>The Regenesis Loop</h3><pre><code>Nock Spec → Clojure Impl → Tests → Jets → Feedback\n    ↑                                         ↓\n    └─────────────────────────────────────────┘\n         Continuous rebirth from eternal specs\n</code></pre><p><strong>Regenesis</strong> means we can always rebuild from specifications:</p><ul><li>If s6 upstream breaks → we have the Nock spec</li><li>If we need Rust version → implement from Nock spec</li><li>If we need optimizations → add jets with proof</li><li>If we need verification → tests prove equivalence</li></ul><p><strong>The specifications are eternal. The implementations are temporary.</strong></p><h3>Hands-On: Explore the Grainstore</h3><pre><code class=\"bash\"># Check Grainstore status &#40;shows specs, implementations, tests&#41;\nbb grainstore:status\n\n# List all Nock specifications\nbb grainstore:specs\n\n# Run ALL Grainstore tests &#40;watch 107 assertions pass!&#41;\nbb grainstore:test\n\n# Or test individual components:\nbb -e &quot;&#40;require '&#91;clojure.test :as t&#93; '&#91;grainstore.s6-test&#93;&#41; &#40;t/run-tests 'grainstore.s6-test&#41;&quot;\nbb -e &quot;&#40;require '&#91;clojure.test :as t&#93; '&#91;grainstore.runit-test&#93;&#41; &#40;t/run-tests 'grainstore.runit-test&#41;&quot;\n</code></pre><p><strong>Explore the actual code</strong>:</p><p><strong>Specifications</strong> (Mathematical, Eternal):</p><ul><li><code>grainstore/specs/s6.nock.md</code> - s6 process supervision (380 lines)</li><li><code>grainstore/specs/runit.nock.md</code> - runit crash-only design (411 lines)</li></ul><p><strong>Implementations</strong> (Practical, Verified):</p><ul><li><code>src/grainstore/s6.clj</code> - Working s6 in Clojure (200+ lines)</li></ul><p><strong>Tests</strong> (Proof of Correctness):</p><ul><li><code>test/grainstore/s6&#95;test.clj</code> - 11 suites, 65 assertions, 100% passing!</li><li><code>test/grainstore/runit&#95;test.clj</code> - 10 suites, 42 assertions, 100% passing!</li></ul><p><strong>Equivalence Proofs</strong>:</p><ul><li><code>grainstore/equivalence/s6-clj-nock.md</code> - Formal proof: Clojure ↔ Nock ↔ C</li></ul><p><strong>Try running the tests</strong> - seeing 107 assertions pass is magical! ✨</p><h3>The Path Forward</h3><p><strong>Today</strong>: We're building the Grainstore foundations (s6, runit)<br /> <strong>Next Week</strong>: We'll add wayland, musl-libc, dbus<br /> <strong>Next Month</strong>: Complete dependency isolation<br /> <strong>Next Year</strong>: Boot Framework 16 using ONLY Grainstore components</p><p><strong>Every seed we save today ensures our software survives tomorrow.</strong><h2></h2></p><h2>Part 1: SixOS Overview</h2><p><strong>Now that you understand the Grainstore, let's install SixOS.</strong></p><p><strong>After learning about personal sovereignty</strong> (Essay 9513), let's make it real on your Framework 16.</p><p><strong>What is SixOS?</strong></p><ul><li><strong>NixOS without systemd</strong> (announced at 38C3, January 2025)</li><li><strong>s6 supervision</strong> instead of systemd (200KB vs 1.5MB)</li><li><strong>\"Infusion\" paradigm</strong> - services managed like Nix packages</li><li><strong>Declarative configuration</strong> with atomic activation</li><li><strong>Owner-booted security</strong> (no unencrypted storage except EEPROM)</li></ul><p><strong>Why SixOS on Framework 16?</strong></p><ul><li><strong>AMD Ryzen 7040</strong> - open drivers, excellent Linux support</li><li><strong>Modular hardware</strong> - matches SixOS modular philosophy</li><li><strong>Repairable design</strong> - aligns with long-term thinking</li><li><strong>No vendor lock-in</strong> - complete control over your system<h2></h2></li></ul><h2>Part 1: Hardware Preparation</h2><h3>Framework 16 Specifications</h3><p><strong>Your kae3g Framework 16</strong> (from <code>&#126;/kae3g/kae3g-young-jupiter-landmark-cactus-nixos-config-personal</code>):</p><pre><code class=\"clojure\">{:framework-16-specs\n {:cpu &quot;AMD Ryzen 7 7840HS &#40;8 cores, 16 threads&#41;&quot;\n  :gpu &quot;AMD Radeon 780M &#40;RDNA 3&#41;&quot;\n  :ram &quot;32GB DDR5-5600&quot;\n  :storage &quot;1TB NVMe SSD&quot;\n  :display &quot;16\\&quot; 2560x1600 165Hz&quot;\n  :ports &quot;4x USB-C &#40;with expansion cards&#41;&quot;\n  :wireless &quot;WiFi 6E + Bluetooth 5.3&quot;\n  :battery &quot;85Wh&quot;}}\n</code></pre><p><strong>Why this hardware is perfect for SixOS:</strong></p><ul><li><strong>AMD open drivers</strong> - <code>amdgpu</code> kernel driver (mainlined!)</li><li><strong>No proprietary blobs</strong> - fully open source graphics</li><li><strong>Excellent Wayland support</strong> - no Nvidia Wayland issues</li><li><strong>Plenty of RAM</strong> - 32GB for development work</li><li><strong>Fast storage</strong> - NVMe for quick boots</li></ul><h3>Pre-Installation Checklist</h3><p><strong>Before we begin:</strong></p><ol><li><strong>Backup your data</strong> (if migrating from existing OS)</li><li><strong>USB drive</strong> (16GB+ recommended, will be erased!)</li><li><strong>Disable Secure Boot</strong> (temporarily, for installation)</li><li><strong>Enable AMD-V</strong> (for virtualization if needed)</li><li><strong>Internet connection</strong> (for downloading packages)</li></ol><h3>Building the SixOS ISO with Babashka</h3><p><strong>We can build the ISO using our Babashka tooling!</strong></p><pre><code class=\"bash\"># Generate SixOS ISO &#40;custom build script&#41;\nbb sixos:build-iso\n\n# Or manually with Nix:\nnix build .#nixosConfigurations.sixos-installer.config.system.build.isoImage\n</code></pre><p><strong>Our custom builder</strong> (<code>scripts/sixos-build-iso.bb</code>):<pre><code class=\"clojure\">#!/usr/bin/env bb\n;; Build SixOS installer ISO with s6 instead of systemd\n\n&#40;ns sixos-build-iso\n  &#40;:require &#91;babashka.process :refer &#91;shell&#93;&#93;\n            &#91;babashka.fs :as fs&#93;&#41;&#41;\n\n&#40;defn build-iso &#91;&#93;\n  &#40;println &quot;🔧 Building SixOS Installer ISO...&quot;&#41;\n  &#40;println &quot;   &#40;NixOS without systemd, s6 supervision&#41;&quot;&#41;\n  \n  ;; Build ISO using Nix\n  &#40;shell &quot;nix&quot; &quot;build&quot; \n         &quot;.#nixosConfigurations.sixos-installer.config.system.build.isoImage&quot;\n         &quot;-o&quot; &quot;result-iso&quot;&#41;\n  \n  ;; Find the ISO\n  &#40;let &#91;iso-path &#40;first &#40;fs/glob &quot;result-iso&quot; &quot;&#42;.iso&quot;&#41;&#41;&#93;\n    &#40;println &quot;\\n✅ ISO built successfully!&quot;&#41;\n    &#40;println &#40;str &quot;   Location: &quot; iso-path&#41;&#41;\n    &#40;println &quot;\\n📝 Next steps:&quot;&#41;\n    &#40;println &quot;   1. Flash to USB: bb sixos:flash-usb &lt;device&gt;&quot;&#41;\n    &#40;println &quot;   2. Boot from USB on Framework 16&quot;&#41;\n    &#40;println &quot;   3. Follow installation guide&quot;&#41;&#41;&#41;\n\n&#40;build-iso&#41;\n</code></pre></p><h3>Flashing to USB Drive</h3><p><strong>Option 1: Using our Babashka script (Recommended)</strong></p><pre><code class=\"bash\"># List available drives\nbb sixos:list-drives\n\n# Flash ISO to USB &#40;will erase drive!&#41;\nbb sixos:flash-usb /dev/disk4  # macOS\nbb sixos:flash-usb /dev/sdb    # Linux\n</code></pre><p><strong>Option 2: Manual flashing</strong></p><p><strong>On macOS:</strong><pre><code class=\"bash\"># List drives\ndiskutil list\n\n# Unmount the drive &#40;e.g., /dev/disk4&#41;\ndiskutil unmountDisk /dev/disk4\n\n# Flash ISO &#40;use the actual path from build output&#41;\nsudo dd if=result-iso/nixos-&#42;.iso of=/dev/rdisk4 bs=4m status=progress\n\n# Eject when done\ndiskutil eject /dev/disk4\n</code></pre></p><p><strong>On Linux:</strong><pre><code class=\"bash\"># List drives\nlsblk\n\n# Unmount partitions &#40;if mounted&#41;\nsudo umount /dev/sdb&#42;\n\n# Flash ISO\nsudo dd if=result-iso/nixos-&#42;.iso of=/dev/sdb bs=4M status=progress\n\n# Sync to ensure write completes\nsync\n</code></pre></p><p><strong>Safety checks:</strong></p><ul><li>⚠️ <strong>Double-check device path!</strong> Wrong device = data loss</li><li>⚠️ <strong>Backup important data first</strong></li><li>⚠️ <strong>Use <code>rdisk</code> on macOS for speed</strong> (e.g., <code>/dev/rdisk4</code>)</li><li>✅ <strong>Verify ISO integrity</strong> before flashing<h2></h2></li></ul><h2>Part 2: Building Your SixOS ISO</h2><h3>The Regenesis Approach: Build from Source</h3><p><strong>Rather than downloading a pre-built ISO, we BUILD our own!</strong></p><p><strong>Why build from source?</strong></p><ul><li>✅ <strong>Complete sovereignty</strong> - You verify every component</li><li>✅ <strong>Grainstore integration</strong> - Use our verified dependencies</li><li>✅ <strong>Customization</strong> - Include only what you need</li><li>✅ <strong>Verification</strong> - Build process proves reproducibility</li><li>✅ <strong>Learning</strong> - Understand every layer of the stack</li></ul><h3>Step 1: Build the SixOS ISO</h3><p><strong>Using our Babashka tooling</strong>:</p><pre><code class=\"bash\"># Build SixOS installer ISO &#40;takes 10-30 minutes&#41;\nbb sixos:build-iso\n</code></pre><p><strong>What this does</strong>:</p><ol><li>Reads your <code>.config.edn</code> (site configuration)</li><li>Builds custom NixOS ISO with s6 (no systemd!)</li><li>Includes Framework 16 drivers (AMD amdgpu)</li><li>Adds Grainstore dependencies (verified s6!)</li><li>Outputs to <code>result-iso/nixos-&#42;.iso</code></li></ol><p><strong>Under the hood</strong> (<code>scripts/sixos-build-iso.bb</code>):<pre><code class=\"clojure\">&#40;defn build-iso &#91;&#93;\n  &#40;println &quot;🔧 Building SixOS Installer ISO...&quot;&#41;\n  &#40;println &quot;   &#40;NixOS without systemd, s6 supervision&#41;&quot;&#41;\n  \n  ;; Build ISO using Nix\n  &#40;shell &quot;nix&quot; &quot;build&quot; \n         &quot;.#nixosConfigurations.sixos-installer.config.system.build.isoImage&quot;\n         &quot;-o&quot; &quot;result-iso&quot;&#41;\n  \n  ;; Report success\n  &#40;let &#91;iso-path &#40;first &#40;fs/glob &quot;result-iso&quot; &quot;&#42;.iso&quot;&#41;&#41;&#93;\n    &#40;println &quot;\\n✅ ISO built successfully!&quot;&#41;\n    &#40;println &#40;str &quot;   Location: &quot; iso-path&#41;&#41;\n    &#40;println &#40;str &quot;   Size: &quot; &#40;quot &#40;.length &#40;fs/file iso-path&#41;&#41; &#40;&#42; 1024 1024&#41;&#41; &quot; MB&quot;&#41;&#41;&#41;&#41;\n</code></pre></p><h3>Step 2: Flash to USB Drive</h3><p><strong>First, find your USB drive</strong>:</p><pre><code class=\"bash\"># List available drives\nbb sixos:list-drives\n\n# macOS output:\n# /dev/disk0 &#40;internal&#41;\n# /dev/disk4 &#40;external&#41; ← Your USB drive\n\n# Linux output:\n# sda &#40;internal&#41;\n# sdb &#40;external&#41; ← Your USB drive\n</code></pre><p><strong>Flash the ISO</strong> (will erase USB drive!):</p><pre><code class=\"bash\"># macOS\nbb sixos:flash-usb /dev/disk4\n\n# Linux\nbb sixos:flash-usb /dev/sdb\n</code></pre><p><strong>The script will</strong>:</p><ol><li>Ask for confirmation (type 'yes')</li><li>Show device and ISO info</li><li>Unmount the drive</li><li>Flash using dd (with progress!)</li><li>Sync and eject safely</li></ol><p><strong>Safety features</strong>:</p><ul><li>⚠️ Requires explicit 'yes' confirmation</li><li>⚠️ Shows what will be erased</li><li>⚠️ Uses rdisk on macOS (3-4x faster)</li><li>⚠️ Verifies ISO exists before starting</li><li>✅ Syncs to ensure complete write</li><li>✅ Auto-ejects on macOS</li></ul><p><strong>Manual method</strong> (if you prefer):</p><p><strong>On macOS</strong>:<pre><code class=\"bash\"># Unmount\ndiskutil unmountDisk /dev/disk4\n\n# Flash &#40;use rdisk for speed!&#41;\nsudo dd if=result-iso/nixos-&#42;.iso of=/dev/rdisk4 bs=4m status=progress\n\n# Eject\ndiskutil eject /dev/disk4\n</code></pre></p><p><strong>On Linux</strong>:<pre><code class=\"bash\"># Unmount\nsudo umount /dev/sdb&#42;\n\n# Flash\nsudo dd if=result-iso/nixos-&#42;.iso of=/dev/sdb bs=4M status=progress\n\n# Sync\nsync\n</code></pre></p><h3>Step 3: Boot from USB on Framework 16</h3><p><strong>Insert USB and reboot</strong>:</p><ol><li><strong>Shutdown</strong> Framework 16 completely</li><li><strong>Insert USB drive</strong> into one of the 4 USB-C ports</li><li><strong>Power on</strong> while holding <strong>F12</strong> (boot menu)</li><li><strong>Select</strong> \"USB Drive\" or \"UEFI: <your USB device>\"</li><li><strong>Press Enter</strong> to boot</li></ol><p><strong>Initial boot screen should show</strong>:</p><ul><li>SixOS bootloader (GRUB)</li><li>Linux kernel loading</li><li><strong>s6-svscan starting</strong> (you'll see this!)</li><li>s6 services initializing</li><li>Minimal desktop environment (if included)</li></ul><p><strong>Watch for</strong>:</p><pre><code>s6-svscan: starting\ns6-supervise: dbus\ns6-supervise: networking\ns6-supervise: udev\n...\n✅ All services up!\n</code></pre><p><strong>This is s6 in action</strong> - each service supervised, auto-restarting on failure!<h2></h2></p><h2>Part 3: SixOS Installation to Disk</h2><p><strong>Now that you're booted from USB, let's install SixOS to your Framework 16's NVMe drive.</strong></p><h3>Step 1: Disk Preparation</h3><p><strong>First, identify your disk</strong>:</p><pre><code class=\"bash\"># List all disks\nlsblk\n\n# Expected output:\n# NAME        MAJ:MIN RM   SIZE RO TYPE MOUNTPOINTS\n# nvme0n1     259:0    0   1TB  0 disk    ← Your Framework 16 NVMe SSD\n# ├─nvme0n1p1 259:1    0  512M  0 part  \n# └─nvme0n1p2 259:2    0  rest  0 part\n</code></pre><p><strong>⚠️ WARNING: The following steps will ERASE all data on /dev/nvme0n1!</strong></p><p><strong>Backup any important data before proceeding!</strong></p><h3>Step 2: Disk Partitioning with fdisk</h3><p><strong>We'll use fdisk for a clean GPT partition table:</strong></p><pre><code class=\"bash\"># Start fdisk &#40;as root or with sudo&#41;\nsudo fdisk /dev/nvme0n1\n\n# Inside fdisk:\n# 1. Press 'g' to create a new GPT partition table\n# 2. Press 'n' to create new partition &#40;EFI&#41;\n#    - Partition number: 1\n#    - First sector: &#40;default&#41;\n#    - Last sector: +512M\n# 3. Press 't' to change type\n#    - Type: 1 &#40;EFI System&#41;\n# 4. Press 'n' to create new partition &#40;Boot&#41;\n#    - Partition number: 2\n#    - First sector: &#40;default&#41;\n#    - Last sector: +1G\n# 5. Press 'n' to create new partition &#40;Root&#41;\n#    - Partition number: 3\n#    - First sector: &#40;default&#41;\n#    - Last sector: &#40;default, use remaining space&#41;\n# 6. Press 'w' to write changes and exit\n</code></pre><p><strong>Resulting partition layout:</strong></p><pre><code class=\"bash\">/dev/nvme0n1p1  # 512MB   - EFI System Partition &#40;FAT32&#41;\n/dev/nvme0n1p2  # 1GB     - Boot partition &#40;ext4&#41;\n/dev/nvme0n1p3  # &#126;998GB  - Root partition &#40;btrfs with subvolumes&#41;\n</code></pre><p><strong>Why this layout:</strong></p><ul><li>✅ <strong>EFI partition (512MB)</strong> - UEFI firmware boot</li><li>✅ <strong>Separate boot (1GB)</strong> - Kernel, initrd, GRUB config</li><li>✅ <strong>Btrfs root (rest)</strong> - Snapshots, compression, subvolumes</li><li>✅ <strong>No swap partition</strong> - 32GB RAM is plenty (can add swapfile later)</li></ul><h3>Step 3: Format Partitions</h3><p><strong>Format each partition with the appropriate filesystem:</strong></p><pre><code class=\"bash\"># Format EFI partition &#40;FAT32&#41;\nsudo mkfs.fat -F 32 /dev/nvme0n1p1\n\n# Format boot partition &#40;ext4&#41;\nsudo mkfs.ext4 -L boot /dev/nvme0n1p2\n\n# Format root partition &#40;btrfs with compression&#41;\nsudo mkfs.btrfs -L nixos /dev/nvme0n1p3\n</code></pre><p><strong>Why these filesystems:</strong></p><ul><li><strong>FAT32</strong> - Required for UEFI</li><li><strong>ext4</strong> - Simple, reliable for /boot</li><li><strong>btrfs</strong> - Modern, snapshots, compression, CoW (copy-on-write)</li></ul><h3>Step 4: Create Btrfs Subvolumes</h3><p><strong>Btrfs subvolumes enable atomic snapshots and flexible layouts:</strong></p><pre><code class=\"bash\"># Mount root partition temporarily\nsudo mount /dev/nvme0n1p3 /mnt\n\n# Create subvolumes\nsudo btrfs subvolume create /mnt/@       # Root subvolume\nsudo btrfs subvolume create /mnt/@home   # Home subvolume\nsudo btrfs subvolume create /mnt/@nix    # Nix store subvolume\nsudo btrfs subvolume create /mnt/@var    # Var subvolume\n\n# Unmount\nsudo umount /mnt\n</code></pre><p><strong>Why subvolumes:</strong></p><ul><li>✅ <strong>Atomic snapshots</strong> - Rollback entire system or just /home</li><li>✅ <strong>Independent compression</strong> - Different settings per subvolume</li><li>✅ <strong>Flexible backup</strong> - Snapshot /home without /nix store</li><li>✅ <strong>Efficient storage</strong> - CoW deduplication</li></ul><h3>Step 5: Mount Filesystem Hierarchy</h3><p><strong>Mount subvolumes with optimal flags:</strong></p><pre><code class=\"bash\"># Mount root subvolume\nsudo mount -o compress=zstd,subvol=@ /dev/nvme0n1p3 /mnt\n\n# Create mount points\nsudo mkdir -p /mnt/{boot,home,nix,var}\n\n# Mount boot partition\nsudo mount /dev/nvme0n1p2 /mnt/boot\n\n# Create EFI mount point\nsudo mkdir -p /mnt/boot/efi\nsudo mount /dev/nvme0n1p1 /mnt/boot/efi\n\n# Mount other subvolumes\nsudo mount -o compress=zstd,subvol=@home /dev/nvme0n1p3 /mnt/home\nsudo mount -o compress=zstd,noatime,subvol=@nix /dev/nvme0n1p3 /mnt/nix\nsudo mount -o compress=zstd,subvol=@var /dev/nvme0n1p3 /mnt/var\n</code></pre><p><strong>Mount options explained:</strong></p><ul><li><strong>compress=zstd</strong> - Fast compression (saves ~30% space!)</li><li><strong>noatime</strong> - Don't update access times (faster, less wear)</li><li><strong>subvol=@</strong> - Specify which subvolume to mount</li></ul><p><strong>Verify mounts:</strong><pre><code class=\"bash\">mount | grep nvme\n\n# Expected output:\n# /dev/nvme0n1p3 on /mnt type btrfs &#40;rw,compress=zstd,subvol=/@&#41;\n# /dev/nvme0n1p2 on /mnt/boot type ext4 &#40;rw&#41;\n# /dev/nvme0n1p1 on /mnt/boot/efi type vfat &#40;rw&#41;\n# /dev/nvme0n1p3 on /mnt/home type btrfs &#40;rw,compress=zstd,subvol=/@home&#41;\n# ...\n</code></pre></p><h3>Step 6: Generate NixOS Configuration</h3><p><strong>NixOS can auto-generate hardware configuration:</strong></p><pre><code class=\"bash\"># Generate hardware config &#40;detects partitions, modules, etc.&#41;\nsudo nixos-generate-config --root /mnt\n\n# This creates:\n# /mnt/etc/nixos/configuration.nix - Main config &#40;edit this!&#41;\n# /mnt/etc/nixos/hardware-configuration.nix - Auto-generated &#40;don't edit!&#41;\n</code></pre><p><strong>The generated hardware-configuration.nix will include:</strong></p><ul><li>Your partition UUIDs (immutable references!)</li><li>Detected hardware modules (amdgpu, nvme, etc.)</li><li>Boot options for your specific hardware</li></ul><h3>Step 7: Edit SixOS Configuration</h3><p><strong>Now customize the main configuration for SixOS + s6:</strong></p><pre><code class=\"bash\"># Edit configuration\nsudo nano /mnt/etc/nixos/configuration.nix\n</code></pre><p><strong>Replace the default config with this SixOS configuration:</strong></p><pre><code class=\"nix\">{ config, pkgs, ... }:\n\n{\n  # Import hardware config &#40;auto-generated&#41;\n  imports = &#91;\n    ./hardware-configuration.nix\n  &#93;;\n\n  # Boot configuration &#40;GRUB + UEFI&#41;\n  boot.loader = {\n    efi.canTouchEfiVariables = true;\n    grub = {\n      enable = true;\n      device = &quot;nodev&quot;;  # UEFI &#40;not legacy BIOS&#41;\n      efiSupport = true;\n      useOSProber = false;  # Only NixOS\n    };\n  };\n\n  # Networking\n  networking = {\n    hostName = &quot;framework-sixos&quot;;  # Change this!\n    networkmanager.enable = true;\n  };\n\n  # Time zone\n  time.timeZone = &quot;America/Los&#95;Angeles&quot;;  # Change this!\n\n  # Locale\n  i18n.defaultLocale = &quot;en&#95;US.UTF-8&quot;;\n\n  # User account\n  users.users.kae3g = {  # Change username!\n    isNormalUser = true;\n    extraGroups = &#91; &quot;wheel&quot; &quot;networkmanager&quot; &quot;video&quot; &quot;audio&quot; &quot;input&quot; &#93;;\n    initialPassword = &quot;changeme&quot;;  # Change on first login!\n  };\n\n  # Essential packages\n  environment.systemPackages = with pkgs; &#91;\n    vim\n    git\n    curl\n    wget\n    htop\n  &#93;;\n\n  # AMD GPU support &#40;Framework 16&#41;\n  hardware = {\n    opengl.enable = true;\n    opengl.driSupport = true;\n    opengl.driSupport32Bit = true;\n  };\n  services.xserver.videoDrivers = &#91; &quot;amdgpu&quot; &#93;;\n\n  # Enable s6 supervision &#40;SixOS!&#41;\n  # NOTE: This is conceptual - actual SixOS integration pending!\n  # For now, this is standard NixOS with plans to migrate to s6\n  systemd.services.s6-svscan = {\n    description = &quot;s6 supervision tree&quot;;\n    wantedBy = &#91; &quot;multi-user.target&quot; &#93;;\n    serviceConfig = {\n      Type = &quot;simple&quot;;\n      ExecStart = &quot;${pkgs.s6}/bin/s6-svscan /etc/s6/sv&quot;;\n      Restart = &quot;always&quot;;\n    };\n  };\n\n  # System state version &#40;don't change!&#41;\n  system.stateVersion = &quot;24.05&quot;;  # Or current version\n}\n</code></pre><p><strong>Important configuration notes:</strong></p><ul><li><strong>Change <code>hostName</code></strong> to your preferred hostname</li><li><strong>Change <code>timeZone</code></strong> to your timezone</li><li><strong>Change <code>users.users.kae3g</code></strong> to your username!</li><li><strong>Change <code>initialPassword</code></strong> on first login (use <code>passwd</code>)</li></ul><h3>Step 8: Install NixOS</h3><p><strong>Now install NixOS to disk:</strong></p><pre><code class=\"bash\"># Install NixOS &#40;takes 10-30 minutes depending on internet speed&#41;\nsudo nixos-install\n\n# This will:\n# 1. Download all packages from cache.nixos.org\n# 2. Build the system closure\n# 3. Install GRUB to /boot/efi\n# 4. Set up the Nix store\n# 5. Prompt for root password &#40;set this!&#41;\n</code></pre><p><strong>During installation you'll see:</strong></p><pre><code>copying path '/nix/store/...' from 'https://cache.nixos.org'...\nbuilding '/nix/store/...-grub-install.drv'...\ninstalling GRUB to /boot/efi...\nsetting up /etc...\nsetting root password...\nEnter new UNIX password:  ← Set root password here!\n</code></pre><p><strong>Installation complete!</strong></p><pre><code class=\"bash\"># Unmount everything\nsudo umount -R /mnt\n\n# Reboot\nsudo reboot\n</code></pre><p><strong>Remove USB drive during reboot!</strong></p><h3>Step 9: First Boot</h3><p><strong>After reboot, you should see:</strong></p><ol><li><strong>GRUB boot menu</strong> - Select \"NixOS\"</li><li><strong>Kernel loading</strong> - Watch the boot messages</li><li><strong>s6-svscan starting</strong> - (if configured!)</li><li><strong>Login prompt</strong> - Login as your user<pre><code class=\"bash\"># Login\nframework-sixos login: kae3g\nPassword: changeme\n\n# Change password immediately!\npasswd\n\n# Check system\nneofetch\nuname -a\n</code></pre></li></ol><p><strong>Congratulations! SixOS is installed!</strong> 🎉<h2></h2></p><h2>Part 4: Post-Installation Setup</h2><h3>Update System</h3><p><strong>First, update to latest packages:</strong></p><pre><code class=\"bash\"># Update channel\nsudo nix-channel --update\n\n# Rebuild system\nsudo nixos-rebuild switch\n\n# This applies any new updates from nixpkgs\n</code></pre><h3>Install Essential Tools</h3><p><strong>Add more packages to configuration.nix:</strong></p><pre><code class=\"nix\">environment.systemPackages = with pkgs; &#91;\n  # Terminal\n  wezterm\n  \n  # Development\n  babashka\n  clojure\n  git\n  \n  # Browsers\n  brave\n  firefox\n  \n  # Editors\n  cursor\n  helix\n  \n  # Utilities\n  ripgrep\n  fd\n  bat\n  exa\n  zoxide\n&#93;;\n</code></pre><p><strong>Then rebuild:</strong><pre><code class=\"bash\">sudo nixos-rebuild switch\n</code></pre></p><p><strong>SixOS-specific configuration</strong> (<code>/etc/sixos/config.edn</code>):</p><pre><code class=\"nix\">{ config, pkgs, ... }:\n\n{\n  # Enable SixOS &#40;s6 supervision instead of systemd&#41;\n  services.s6 = {\n    enable = true;\n    # s6 supervision tree\n    supervision = {\n      enable = true;\n      # Essential services\n      services = {\n        &quot;s6-svscan&quot; = {\n          enable = true;\n          type = &quot;longrun&quot;;\n        };\n        &quot;s6-log&quot; = {\n          enable = true;\n          type = &quot;longrun&quot;;\n        };\n      };\n    };\n  };\n\n  # Disable systemd &#40;SixOS core principle&#41;\n  systemd.enable = false;\n  \n  # Use s6 for service management\n  services.s6-svscan.enable = true;\n}\n</code></pre><h2></h2><h2>Part 3: s6 Supervision Setup</h2><h3>Understanding s6</h3><p><strong>s6 is the heart of SixOS</strong> (from Essay 9952):</p><pre><code class=\"clojure\">{:s6-principles\n {:philosophy &quot;Unix philosophy: do one thing well&quot;\n  :size &quot;200KB vs systemd's 1.5MB&quot;\n  :supervision &quot;Process supervision and service management&quot;\n  :logging &quot;s6-log for structured logging&quot;\n  :compatibility &quot;Works with any init system&quot;}}\n</code></pre><p><strong>Key s6 concepts:</strong></p><ul><li><strong>Service directories</strong> - each service gets its own directory</li><li><strong>Supervision tree</strong> - hierarchical process management</li><li><strong>Atomic operations</strong> - start/stop/restart services atomically</li><li><strong>Logging integration</strong> - s6-log handles all service logs</li></ul><h3>Essential s6 Services</h3><p><strong>Create service directories</strong> (<code>/etc/s6/sv/</code>):</p><pre><code class=\"bash\"># Create service directory structure\nmkdir -p /etc/s6/sv/{dbus,networking,sshd,wayland}\n\n# Example: D-Bus service\ncat &gt; /etc/s6/sv/dbus/run &lt;&lt; 'EOF'\n#!/bin/sh\nexec dbus-daemon --system --nofork\nEOF\n\nchmod +x /etc/s6/sv/dbus/run\n\n# Service control\ncat &gt; /etc/s6/sv/dbus/finish &lt;&lt; 'EOF'\n#!/bin/sh\nexec s6-svscanctl -t /etc/s6/sv/dbus\nEOF\n\nchmod +x /etc/s6/sv/dbus/finish\n</code></pre><p><strong>Service management commands:</strong><pre><code class=\"bash\"># Start service\ns6-svc -u /etc/s6/sv/dbus\n\n# Stop service  \ns6-svc -d /etc/s6/sv/dbus\n\n# Restart service\ns6-svc -r /etc/s6/sv/dbus\n\n# Check service status\ns6-svstat /etc/s6/sv/dbus\n</code></pre></p><h2></h2><h2>Part 4: Wayland + Hyprland Setup</h2><h3>Why Wayland?</h3><p><strong>Wayland advantages on Framework 16:</strong></p><ul><li><strong>Better security</strong> - no X11 security issues</li><li><strong>AMD GPU optimization</strong> - direct rendering</li><li><strong>Touchpad gestures</strong> - native support</li><li><strong>Multi-monitor</strong> - better handling</li><li><strong>Power efficiency</strong> - less overhead than X11</li></ul><h3>Hyprland Configuration</h3><p><strong>Install Hyprland</strong> (via Nix):</p><pre><code class=\"nix\"># Add to configuration.nix\nenvironment.systemPackages = with pkgs; &#91;\n  hyprland\n  waybar\n  rofi-wayland\n  wl-clipboard\n  grim\n  slurp\n&#93;;\n</code></pre><p><strong>Hyprland config</strong> (<code>&#126;/.config/hypr/hyprland.conf</code>):</p><pre><code class=\"bash\"># Monitor configuration &#40;Framework 16&#41;\nmonitor=,2560x1600@165,0x0,1\n\n# Input configuration\ninput {\n    kb&#95;layout = us\n    kb&#95;variant =\n    kb&#95;model =\n    kb&#95;options =\n    kb&#95;rules =\n\n    follow&#95;mouse = 1\n    touchpad {\n        natural&#95;scroll = yes\n    }\n}\n\n# Window rules\nwindowrule = float, &#94;&#40;rofi&#41;$\nwindowrule = center, &#94;&#40;rofi&#41;$\n\n# Key bindings\nbind = SUPER, Return, exec, wezterm\nbind = SUPER, Q, killactive,\nbind = SUPER, M, exit,\nbind = SUPER, E, exec, brave\nbind = SUPER, C, exec, cursor\n\n# Workspace switching\nbind = SUPER, 1, workspace, 1\nbind = SUPER, 2, workspace, 2\nbind = SUPER, 3, workspace, 3\n</code></pre><h2></h2><h2>Part 5: Essential Applications</h2><h3>Wezterm Terminal</h3><p><strong>Install Wezterm</strong> (via Nix):</p><pre><code class=\"nix\">environment.systemPackages = with pkgs; &#91;\n  wezterm\n&#93;;\n</code></pre><p><strong>Wezterm configuration</strong> (<code>&#126;/.config/wezterm/wezterm.lua</code>):</p><pre><code class=\"lua\">local wezterm = require 'wezterm'\n\nreturn {\n  -- Font configuration\n  font = wezterm.font 'JetBrains Mono',\n  font&#95;size = 14.0,\n  \n  -- Color scheme &#40;dark theme&#41;\n  color&#95;scheme = 'Catppuccin Mocha',\n  \n  -- Window configuration\n  window&#95;background&#95;opacity = 0.95,\n  window&#95;decorations = 'RESIZE',\n  \n  -- Tab bar\n  use&#95;fancy&#95;tab&#95;bar = false,\n  tab&#95;bar&#95;at&#95;bottom = true,\n  \n  -- Key bindings\n  keys = {\n    { key = 't', mods = 'CTRL|SHIFT', action = wezterm.action { SpawnTab = 'CurrentPaneDomain' } },\n    { key = 'w', mods = 'CTRL|SHIFT', action = wezterm.action { CloseCurrentTab = { confirm = false } } },\n  },\n}\n</code></pre><h3>Brave Browser</h3><p><strong>Install Brave</strong> (via Nix):</p><pre><code class=\"nix\">environment.systemPackages = with pkgs; &#91;\n  brave\n&#93;;\n</code></pre><p><strong>Brave configuration:</strong></p><ul><li><strong>Privacy settings</strong> - enable all privacy features</li><li><strong>Extensions</strong> - uBlock Origin, Bitwarden</li><li><strong>Sync</strong> - if you use Brave sync</li><li><strong>Wayland support</strong> - should work out of the box</li></ul><h3>Cursor Editor</h3><p><strong>Install Cursor</strong> (via Nix):</p><pre><code class=\"nix\">environment.systemPackages = with pkgs; &#91;\n  cursor\n&#93;;\n</code></pre><p><strong>Cursor configuration:</strong></p><ul><li><strong>AI features</strong> - enable Cursor Tab and Cursor Chat</li><li><strong>Extensions</strong> - Clojure, Rust, Nix language support</li><li><strong>Wayland support</strong> - should work with Wayland backend<h2></h2></li></ul><h2>Part 6: Debugging Common Issues</h2><h3>Boot Issues</h3><p><strong>If SixOS won't boot:</strong></p><pre><code class=\"bash\"># Check boot logs\njournalctl -b\n\n# Check s6 supervision\ns6-svstat /etc/s6/sv/&#42;\n\n# Check hardware detection\nlspci -k\nlsusb\n</code></pre><p><strong>Common fixes:</strong></p><ul><li><strong>AMD GPU issues</strong> - ensure <code>amdgpu</code> driver is loaded</li><li><strong>WiFi not working</strong> - check firmware installation</li><li><strong>Audio issues</strong> - check ALSA/PulseAudio configuration</li></ul><h3>Wayland Issues</h3><p><strong>If Wayland won't start:</strong></p><pre><code class=\"bash\"># Check Wayland session\necho $XDG&#95;SESSION&#95;TYPE\n\n# Check Hyprland logs\nhyprctl logs\n\n# Fallback to X11 if needed\nstartx\n</code></pre><p><strong>Common fixes:</strong></p><ul><li><strong>Missing Wayland packages</strong> - install <code>wayland</code> and <code>wayland-protocols</code></li><li><strong>Permission issues</strong> - check user groups (<code>video</code>, <code>audio</code>, <code>input</code>)</li><li><strong>Display issues</strong> - check monitor configuration</li></ul><h3>Service Issues</h3><p><strong>If s6 services won't start:</strong></p><pre><code class=\"bash\"># Check service status\ns6-svstat /etc/s6/sv/service-name\n\n# Check service logs\ns6-log /etc/s6/sv/service-name\n\n# Restart supervision\ns6-svscanctl -t /etc/s6/sv\n</code></pre><h2></h2><h2>Part 7: Building Your Sovereignty Stack</h2><h3>Phase 2 Implementation (2026-2028)</h3><p><strong>Following Essay 9513's roadmap:</strong></p><pre><code class=\"clojure\">{:phase-2-stack\n {:hardware &quot;Framework 16 &#40;AMD Ryzen 7040&#41;&quot;\n  :os &quot;SixOS &#40;NixOS without systemd&#41;&quot;\n  :init &quot;s6 supervision &#40;200KB&#41;&quot;\n  :userspace &quot;Verified utilities &#40;formal proofs&#41;&quot;\n  :specification &quot;Nock specs for common workflows&quot;}}\n</code></pre><p><strong>Next steps:</strong></p><ol><li><strong>Learn s6 deeply</strong> - master the supervision system</li><li><strong>Build verified utilities</strong> - formal proofs for critical tools</li><li><strong>Create Nock specifications</strong> - formal specs for workflows</li><li><strong>Contribute to SixOS</strong> - help develop the ecosystem</li></ol><h3>Daily Workflow</h3><p><strong>Your new SixOS workflow:</strong></p><pre><code class=\"bash\"># Morning startup\ns6-svc -u /etc/s6/sv/wayland  # Start Wayland\nhyprland &amp;                    # Start compositor\nwezterm &amp;                     # Start terminal\nbrave &amp;                       # Start browser\ncursor &amp;                      # Start editor\n\n# Development work\ncd &#126;/projects/valley\nbb regenesis                  # Run valley regeneration\nbb content:build              # Build content\nbb test:all                   # Run tests\n\n# Evening shutdown\ns6-svc -d /etc/s6/sv/wayland  # Stop Wayland\nshutdown now                  # Shutdown system\n</code></pre><h2></h2><h2>Summary</h2><p><strong>SixOS on Framework 16 gives you:</strong></p><ul><li><strong>Complete hardware control</strong> - AMD open drivers</li><li><strong>Minimal supervision</strong> - s6 instead of systemd</li><li><strong>Declarative configuration</strong> - NixOS power without systemd</li><li><strong>Modern desktop</strong> - Wayland + Hyprland</li><li><strong>Essential tools</strong> - Wezterm, Brave, Cursor</li><li><strong>Personal sovereignty</strong> - no vendor lock-in</li></ul><p><strong>The Gentle Gardener's wisdom:</strong></p><ul><li><strong>Simplicity</strong> - 200KB supervision vs 1.5MB systemd</li><li><strong>Modularity</strong> - each service in its own directory</li><li><strong>Atomicity</strong> - clean start/stop/restart operations</li><li><strong>Transparency</strong> - no hidden complexity</li></ul><p><strong>In the Valley:</strong></p><ul><li>We understand <strong>hardware</strong> (Framework 16)</li><li>We choose <strong>consciously</strong> (SixOS over systemd)</li><li>We apply <strong>Unix principles</strong> (s6 supervision)</li><li>We build <strong>for the long term</strong> (repairable, open)</li></ul><p><strong>Plant lens</strong>: \"SixOS is like no-till farming - we work with the ecosystem instead of plowing it under. s6 supervision is like living mulch - it protects and nourishes our services without disrupting the soil.\"<h2></h2></p><p><strong>Next</strong>: Continue to <strong>functional programming</strong> (Essay 9520), or explore the deep dives!</p><p><strong>Optional Deep Dives</strong> (can skip or read later):</p><ul><li><strong><a href='/12025-10/9517-regenesis-demo-make-it-tactile'>9517: Regenesis Demo</a></strong> - One-button stack demonstration!</li><li><strong><a href='/12025-10/9517-complete-stack-in-action'>9517: Complete Stack in Action</a></strong> - Nostr + Urbit + ClojureScript integration!<h2></h2></li></ul><p><strong>Navigation</strong>:<br /> ← Previous: <a href='/12025-10/9513-personal-sovereignty-framework-stack'>9513 (Personal Sovereignty)</a> | <strong>Phase 1 Index</strong> | Next: <a href='/12025-10/9515-regenesis-demo-make-it-tactile'>9515 (Regenesis)</a></p><p><strong>Or Skip to Main Path</strong>: <a href='/12025-10/9520-functional-programming-basics'>9520 (Functional Programming)</a></p><p><strong>Deep Dives</strong>: <a href='/12025-10/9515-regenesis-demo-make-it-tactile'>9515 (Regenesis)</a> | <a href='/12025-10/9516-complete-stack-in-action'>9516 (Complete Stack)</a></p><p><strong>Metadata</strong>:</p><ul><li><strong>Phase</strong>: 1 (Foundations)</li><li><strong>Week</strong>: 2</li><li><strong>Prerequisites</strong>: 9513, 9952, 9956, 9500, 9503</li><li><strong>Concepts</strong>: SixOS, s6 supervision, Wayland, Hyprland, Framework 16, personal sovereignty</li><li><strong>Next</strong>: Functional programming (9520), or optional deep dives (9515, 9516)</li><li><strong>Reading Time</strong>: 25 minutes (practical installation guide!)</li></ul><h2></h2><p><div style=\"text-align: center; opacity: 0.6; font-size: 0.85em; margin-top: 3em; padding-top: 1em; border-top: 1px solid rgba(139, 116, 94, 0.2);\"></p><p><strong>Copyright © 2025 <a href='https://codeberg.org/kae3g/12025-10/'>kae3g</a></strong> | Dual-licensed under <a href='https://www.apache.org/licenses/LICENSE-2.0'>Apache-2.0</a> / <a href='https://opensource.org/licenses/MIT'>MIT</a><br /> Competitive technology in service of clarity and beauty</p><p></div></p><p><em><a href='/12025-10/hidden-docs-index.html'>View Hidden Docs Index</a></em> | <em><a href='/12025-10/'>Return to Main Index</a></em></p>",
  "hash" : "2025-10-22T15:17:39.4288578Z-44694"
}