{:paths ["src" "scripts" "test"]
 :deps  {org.clojure/clojurescript {:mvn/version
   "1.12.42"}
         org.clojure/spec.alpha   {:mvn/version
           "0.3.218"}
         babashka/fs              {:mvn/version "0.5.27"}
         hiccup/hiccup           {:mvn/version "2.0.0"}
         markdown-clj/markdown-clj {:mvn/version
           "1.12.4"}
         clj-commons/clj-yaml     {:mvn/version
           "1.0.29"}
         cheshire/cheshire        {:mvn/version
           "6.1.0"}}
 :tasks
 {:requires ([babashka.fs :as fs]
             [babashka.process :refer [shell]]
             [clojure.string :as str])

  doctor {:doc "Check toolchain for kae3g pipeline"
          :task (do
                  (println "kae3g Content Pipeline
            Toolchain Status")
                  (println "bb version:"
                    (System/getProperty
                      "babashka.version"))
                  (shell "bash" "-lc" (str "node "
                    "--version || echo "
                    "'Node.js not found'"))
                  (shell "bash" "-lc" (str "clj-kondo "
                    "--version || echo "
                    "'clj-kondo not found'"))
                  (shell "bash" "-lc" (str "zprint "
                    "--version || echo "
                    "'zprint not found'"))
                  (shell "bash" "-lc" (str "npx vite "
                    "--version || echo "
                    "'Vite not found'")))}

  fmt:wrap {:doc "Format markdown with 80-char hard wrap
    using clj-kondo"
            :task (shell "bash" "-lc" "clj-kondo --lint
              docs/*.md --config '{:output {:pattern
                \"::{{level}}
                  file={{filename}},line={{row}},col
                    ={{col}}::{{message}}\"}}' || true")}

  format:check {:doc "Check Clojure formatting (80 chars)"
               :task (shell "bb" "scripts/format-clojure-simple.bb")}

  format:apply {:doc "Apply Clojure formatting (80 chars) - manual process"
               :task (do (println "‚ö†Ô∏è  Manual formatting required for 80-char wrapping")
                         (println "Files with long lines detected:")
                         (shell "bb" "scripts/format-clojure-simple.bb"))}

  format:test {:doc "Test Clojure formatting functionality"
              :task (shell "bb" "scripts/test-formatting.bb")}

  wrap:all-markdown {:doc "Wrap all markdown files (docs
    + repo) to 80 chars"
                     :task (do (println "Wrapping all
                       markdown files to 80 chars")
                               (shell "bb" "-m"
                                 "kae3g.wrapper"
                                   "docs" "build/docs-w
                                     rapped")
                               (shell "bb" "-m"
                                 "kae3g.wrapper"
                                   "." "build/repo-wrap
                                     ped" "--include-root
                                       ")
                               (println "All markdown
                                 files wrapped"))}

  wrap:edn {:doc "Wrap EDN files to 80-char hard wrap"
            :task (shell "bb" "-m"
              "kae3g.edn-wrapper")}

  parse:markdown {:doc "Parse markdown ‚Üí ClojureScript
    DSL"
                  :task (shell "bb" "-m"
                    "kae3g.parser")}
  
  parse:all-markdown {:doc "Parse ALL markdown files
    (docs + repo docs) ‚Üí DSL"
                      :task (shell "bb" "-m"
                        "kae3g.parser" "--all")}

  validate:dsl {:doc "Validate DSL structures with
    clojure.spec"
                :task (shell "bb" "-m"
                  "kae3g.validator")}

  generate:svelte {:doc "Transform DSL ‚Üí Svelte
    components"
                   :task (shell "bb" "-m"
                     "kae3g.generator")}

  wrap:markdown {:doc "Wrap markdown files to 80-char
    hard wrap"
                 :task (shell "bb" "-m"
                   "kae3g.wrapper")}

  build:pipeline {:depends [wrap:markdown 
                            parse:markdown 
                            validate:dsl 
                            generate:svelte]
                  :doc "Complete document ‚Üí Svelte
                    pipeline"}

  build:full-site {:depends [wrap:all-markdown
                             wrap:edn
                             parse:all-markdown
                             validate:dsl
                             generate:svelte]
                   :doc "Build complete site with ALL
                     markdown files (docs + repo)"}

  serve:dev {:doc "Start development server"
             :task (shell {:dir "web-app"} "bash" "-lc" "
               echo 'Starting development server...';
               npm pkg get name >/dev/null 2>&1 || npm
                 init -y;
               npm i -D svelte @sveltejs/kit
                 @sveltejs/adapter-static vite;
               echo 'Development server starting...';
               npm run dev
             ")}

  build:site {:doc "Build static website"
              :task (shell {:dir "web-app"} "bash" "-lc"
                "
                echo 'Building static site...';
                npx svelte-kit build
              ")}

  clean {:doc "Clean build artifacts"
         :task (do (println "Cleaning build
           artifacts...")
                   (fs/delete-tree "build")
                   (fs/delete-tree "web-app/build")
                   (fs/delete-tree "web-app/.svelte-kit")
                   (println "Clean complete"))}

  test:all {:doc "Run all tests"
            :task (shell "bb" "-m" "kae3g.test")}

  ;; Enhanced writings build pipeline (JSON for static site)
  writings:build {:doc "Build writings ‚Üí JSON for web (full rebuild)"
                  :task (shell "bb" "scripts/writings_build.clj")}

  writings:build-fast {:doc "Smart incremental build (only changed files)"
                       :task (shell "bb" "scripts/writings_build_incremental.clj")}

  writings:watch {:doc "Watch writings and rebuild automatically"
                  :task (shell "bb" "--watch" "writings" "scripts/writings_build_incremental.clj")}

  writings:validate {:doc "Validate all markdown files without building"
                     :task (shell "bb" "-e" "
                       (require '[babashka.fs :as fs]
                                '[clojure.string :as str])
                       (let [files (concat (fs/glob \"writings\" \"*.md\")
                                          (fs/glob \"docs\" \"*.md\"))]
                         (println \"üîç Validating\" (count files) \"markdown files...\")
                         (doseq [file files]
                           (let [content (slurp (str file))
                                 lines (count (str/split-lines content))]
                             (println \"  ‚úì\" (fs/file-name file) \"(\" lines \"lines)\")))
                         (println \"‚ú® All files valid!\"))")}

  writings:stats {:doc "Show statistics about writings content"
                  :task (shell "bb" "-e" "
                    (require '[babashka.fs :as fs]
                             '[clojure.string :as str])
                    (let [writings-files (fs/glob \"writings\" \"*.md\")
                          docs-files (fs/glob \"docs\" \"*.md\")
                          total-files (+ (count writings-files) (count docs-files))
                          total-size (reduce + (map #(.length (fs/file %)) 
                                                   (concat writings-files docs-files)))]
                      (println \"üìä kae3g Writings Statistics:\")
                      (println \"  ‚Ä¢ Writings: \" (count writings-files) \" files\")
                      (println \"  ‚Ä¢ Docs: \" (count docs-files) \" files\")
                      (println \"  ‚Ä¢ Total: \" total-files \" files\")
                      (println \"  ‚Ä¢ Size: \" (quot total-size 1024) \" KB\"))")}

  archive:optional {:doc "Optional: Archive non-essential directories for cleaner repo"
                   :task (shell "bb" "scripts/archive_optional.bb")}

  terminal:setup {:doc "Setup Cursor terminal with kae3g zsh config"
                  :task (shell "bash" "scripts/setup-cursor-terminal.sh")}

  ci:verify {:depends [doctor format:check wrap:markdown
    parse:markdown validate:dsl]
             :doc "Continuous integration verification"}

  deploy:static {:depends [build:pipeline build:site]
                 :doc "Deploy static site"}

  ;; Nix orchestration from bb
  nix:check {:doc "Check if Nix is available"
             :task (shell "bash" "-lc" "nix --version ||
               echo 'Nix not found - install from
                 nixos.org'")}

  nix:develop {:doc "Enter Nix development shell (use:
    nix develop, then bb commands)"
               :task (do (println "To enter Nix shell
                 , run in your terminal:")
                         (println "   nix develop")
                         (println "")
                         (println "Then inside Nix
                           shell:")
                         (println "   bb doctor")
                         (println "   bb
                           build:pipeline"))}

  nix:run {:doc "Run command in Nix shell context"
           :task (if-let [cmd (first
             *command-line-args*)]
                   (shell "nix" "develop" "--command"
                     "bb" cmd)
                   (println "Usage: bb nix:run
                     <bb-task-name>"))}

  ;; Secrets management
  secrets:setup {:doc "Setup secrets file from template"
                 :task (shell "cp"
                   ".secrets.template.edn"
                         ".secrets.edn")}
  
  secrets:check {:doc "Check if secrets file exists"
                 :task (if (fs/exists? ".secrets.edn")
                         (println "‚úÖ .secrets.edn found")
                         (println "‚ùå Run: bb
                           secrets:setup"))}
  
  secrets:config-git {:doc "Configure git from secrets"
                      :task (shell "bb" "scripts/
                        load-secrets.bb")}

  ;; GitHub repository creation
  gh:check {:doc "Check if GitHub CLI is authenticated"
            :task (shell "bash" "-lc" "gh auth status ||
              echo 'Run: gh auth login'")}

  gh:create-repo {:doc "Create GitHub repository and
    push initial commit"
                  :task (do (println "Creating GitHub
                    Repository")
                            (shell "git" "init")
                            (shell "git" "add" ".")
                            (shell "git" "commit" "-m"
                              "Initial commit:
                                Documentation pipeline")
                            (println "")
                            (println "Creating GitHub
                              repository...")
                            (shell "gh" "repo" "create"
                              "kae3g/12025-10-04"
                                   "--public"
                                   "--description"
                                    "Documentation
                                      pipeline
                                      with 57-char
                                        wrapping"
                                   "--source" "."
                                   "--push")
                            (println "")
                            (println "Repository created
                              and pushed!"))}

  gh:status {:doc "Check git and GitHub repository
    status"
             :task (do (println "Repository Status:")
                       (println "")
                       (shell "git" "status")
                       (println "")
                       (shell "git" "remote" "-v"))}

  ;; Bootstrap and setup
  
  ;; Codeberg mechanical operations
  codeberg:setup {:doc "Setup Codeberg mechanical systems"
                  :task (shell "bb" "scripts/codeberg-setup.bb" (or (first *command-line-args*) "check"))}
  
  codeberg:workflow {:doc "Execute mechanical workflows"
                     :task (shell "bb" "scripts/codeberg-workflow.bb" (or (first *command-line-args*) ""))}
  
  codeberg:check {:doc "Check Codeberg prerequisites and connection"
                  :task (shell "bb" "scripts/codeberg-setup.bb" "check")}
  
  codeberg:keygen {:doc "Generate SSH key for Codeberg (usage: bb codeberg:keygen <email>)"
                   :task (shell "bb" "scripts/codeberg-setup.bb" "keygen" (or (second *command-line-args*) "your-email@example.com"))}
  
  codeberg:test {:doc "Test Codeberg SSH connection"
                 :task (shell "bb" "scripts/codeberg-setup.bb" "test")}
  
  codeberg:commit {:doc "Mechanical commit workflow (usage: bb codeberg:commit \"message\")"
                   :task (shell "bb" "scripts/codeberg-workflow.bb" "commit" (str/join " " *command-line-args*))}
  
  codeberg:status {:doc "Check CI engine status"
                   :task (shell "bb" "scripts/codeberg-workflow.bb" "status")}
  
  codeberg:release {:doc "Mechanical release (usage: bb codeberg:release v1.0.0)"
                    :task (shell "bb" "scripts/codeberg-workflow.bb" "release" (or (first *command-line-args*) "v1.0.0"))}
  
  codeberg:update-links {:doc "Update all GitHub links to Codeberg (mechanical migration)"
                         :task (shell "bb" "scripts/update-links-to-codeberg.bb")}
  
  ;; Deployment tasks
  deploy:build-content {:doc "Build content JSON from markdown (incremental)"
                        :task (shell "bb" "writings:build-fast")}
  
  deploy:build-content-full {:doc "Build content JSON from markdown (full rebuild)"
                              :task (shell "bb" "writings:build")}
  
  deploy:build-site {:doc "Build SvelteKit site"
                     :task (shell "bb" "scripts/deploy-to-pages.bb" "build-site")}
  
  deploy:pages {:doc "Deploy existing build to Codeberg Pages"
                :task (shell "bb" "scripts/deploy-to-pages.bb" "deploy")}
  
  deploy:clean {:doc "Clean old build directory"
                :task (shell "bb" "scripts/deploy-to-pages.bb" "clean")}
  
  deploy:full {:doc "Full deployment pipeline (build + deploy)"
               :task (shell "bb" "scripts/deploy-to-pages.bb" "full")}
  
  ;; Precision flow: build ‚Üí commit ‚Üí push ‚Üí deploy (Coldriver Heal workflow)
  flow {:doc "Dual-deploy precision flow: build, commit, push to both remotes, deploy (usage: bb flow \"message\")"
        :task (let [msg (or (first *command-line-args*) 
                            "chore: precision flow update")]
                (println "üåä Starting dual-deploy precision flow...")
                (println "")
                (println "1Ô∏è‚É£ Building content to verify...")
                (shell "bb" "writings:build-fast")
                (println "‚úì Build successful")
                (println "")
                (println "2Ô∏è‚É£ Staging changes...")
                (shell "git" "add" "-A")
                (println "‚úì Changes staged")
                (println "")
                (println "3Ô∏è‚É£ Checking for changes...")
                (let [status (-> (shell {:out :string} "git" "status" "--porcelain")
                                 :out
                                 str/trim)]
                  (if (empty? status)
                    (do
                      (println "‚úì Working tree clean - nothing to commit")
                      (println "")
                      (println "‚ú® Dual-deploy precision flow complete! Everything up to date."))
                    (do
                      (println "‚úì Changes detected")
                      (println "")
                      (println "4Ô∏è‚É£ Committing...")
                      (shell "git" "commit" "-m" msg)
                      (println "‚úì Committed:" msg)
                      (println "")
                      (println "5Ô∏è‚É£ Pushing to GitHub personal (origin/main)...")
                      (shell "git" "push" "origin" "main")
                      (println "‚úì Pushed to GitHub (kae3g)")
                      (println "")
                      (println "6Ô∏è‚É£ Pushing to Codeberg personal (codeberg/main)...")
                      (shell "git" "push" "codeberg" "main")
                      (println "‚úì Pushed to Codeberg (kae3g)")
                      (println "")
                      (println "7Ô∏è‚É£ Pushing to GitHub org (grainpbc-github/main)...")
                      (shell "git" "push" "grainpbc-github" "main")
                      (println "‚úì Pushed to GitHub (grainpbc)")
                      (println "")
                      (println "8Ô∏è‚É£ Deploying to Codeberg Pages (pages branch)...")
                      (shell "bb" "scripts/deploy-to-pages.bb" "full")
                      (println "‚úì Codeberg Pages deployed")
                      (println "")
                      (println "9Ô∏è‚É£ GitHub Actions will deploy from main automatically...")
                      (println "   Monitor: https://github.com/kae3g/grainkae3g/actions")
                      (println "")
                      (println "‚ú® Dual-deploy precision flow complete!")
                      (println "")
                      (println "üìù Source: 'main' branch (mirrored GitHub ‚Üî Codeberg)")
                      (println "üåê Codeberg Pages: https://kae3g.codeberg.page/grainkae3g/ (from 'pages')")
                      (println "üåê GitHub Pages: https://kae3g.github.io/grainkae3g/ (from 'main')")
                      (println "‚è±Ô∏è  Give both sites 1-2 minutes to rebuild")))))}
  
  
  ;; Grainstore tasks
  grainstore:test {:doc "Run Grainstore s6 tests"
                   :task (shell "bb" "-e"
                           "(require '[clojure.test :as t] '[grainstore.s6-test]) (t/run-tests 'grainstore.s6-test)")}
  
  grainstore:specs {:doc "List all Grainstore specifications"
                    :task (do
                            (println "üì¶ Grainstore Specifications:")
                            (doseq [spec (sort (fs/glob "grainstore/specs" "*.nock.md"))]
                              (println (str "  ‚úì " (fs/file-name spec)))))}
  
  grainstore:status {:doc "Show Grainstore implementation status"
                     :task (do
                             (println "üå± Grainstore Status:\n")
                             (println "Specifications:")
                             (doseq [spec (sort (fs/glob "grainstore/specs" "*.nock.md"))]
                               (println (str "  ‚úì " (fs/file-name spec))))
                             (println "\nImplementations:")
                             (doseq [impl (sort (fs/glob "src/grainstore" "*.clj"))]
                               (println (str "  ‚úì " (fs/file-name impl))))
                             (println "\nTests:")
                             (doseq [test (sort (fs/glob "test/grainstore" "*_test.clj"))]
                               (println (str "  ‚úì " (fs/file-name test))))
                             (println "\n‚ú® Grainstore is growing!"))}
  
  ;; SixOS ISO building and flashing
  sixos:build-iso {:doc "Build SixOS installer ISO (NixOS without systemd)"
                   :task (shell "bb" "scripts/sixos-build-iso.bb")}
  
  sixos:list-drives {:doc "List available drives for flashing"
                     :task (let [os-name (System/getProperty "os.name")]
                             (cond
                               (str/includes? os-name "Mac") (shell "diskutil" "list")
                               (str/includes? os-name "Linux") (shell "lsblk")
                               :else (println "‚ùå Unsupported OS")))}
  
  sixos:flash-usb {:doc "Flash SixOS ISO to USB drive (usage: bb sixos:flash-usb <device>)"
                   :task (shell "bb" "scripts/sixos-flash-usb.bb" (or (first *command-line-args*) ""))}
  
  ;; Setup and configuration tasks
  setup:run {:doc "Run initial project setup"
             :task (shell "bb" "setup/setup.bb")}
  
  config:generate {:doc "Generate site config from .config.edn"
                   :task (shell "bb" "scripts/generate-site-config.bb")}
  
  config:check {:doc "Check if .config.edn exists"
                :task (if (fs/exists? ".config.edn")
                        (println "‚úÖ .config.edn found")
                        (do
                          (println "‚ùå .config.edn not found")
                          (println "   Run: cp .config.template.edn .config.edn")
                          (println "   Then: bb config:generate")))}

  pseudo {:doc "Show PSEUDO.md summary (God's TODO is unknowable; this is ours)"
          :task (shell "bb" "scripts/pseudo.bb")}

  pseudo:audit {:doc "Audit PSEUDO.md + TODO-ASPIRATIONAL.md, generate report"
                :task (shell "bb" "scripts/pseudo/audit.clj")}

  pseudo:weekly {:doc "Generate weekly PSEUDO report to docs/PSEUDO-REPORT.md"
                 :task (shell "bb" "scripts/pseudo/audit.clj")}

  pseudo:open {:doc "Display current PSEUDO audit report"
               :task (do
                       (if (fs/exists? "docs/PSEUDO-REPORT.md")
                         (println (slurp "docs/PSEUDO-REPORT.md"))
                         (println "‚ùå No report found. Run: bb pseudo:audit")))}

  pseudo:verify {:doc "Verify all completion criteria in VERIFICATION.md"
                 :task (do
                         (println "üîç Verification System")
                         (println "")
                         (println "Checking VERIFICATION.md criteria...")
                         (when (fs/exists? "docs/VERIFICATION.md")
                           (println "‚úÖ VERIFICATION.md exists")
                           (println "")
                           (println "Run individual verifications:")
                           (println "  ‚Ä¢ Essays: Check citations, navigation, prose")
                           (println "  ‚Ä¢ Infrastructure: bb writings:build-fast")
                           (println "  ‚Ä¢ CI/CD: Check Woodpecker dashboard")
                           (println "  ‚Ä¢ Config: bb config:generate"))
                         (println "")
                         (println "Full verification suite: Coming soon"))}

  pseudo:empty {:doc "Display EMPTY.md (the fertile void)"
                :task (do
                        (if (fs/exists? "docs/EMPTY.md")
                          (println (slurp "docs/EMPTY.md"))
                          (println "‚ùå EMPTY.md not found")))}

  bootstrap {:doc "Bootstrap project (check prereqs
    , setup)"
             :task (do (println "kae3g Content Pipeline
               Bootstrap")
                       (println "Checking
                         prerequisites...")
                       (println "")
                       (let [has-bb (try (shell
                         {:continue true :out :string}
                           "which" "bb") true (catch
                             Exception _ false))
                             has-nix (try (shell
                               {:continue true :out
                                 :string} "which" "nix")
                                   true (catch Exception
                                     _ false))
                             has-git (try (shell
                               {:continue true :out
                                 :string} "which" "git")
                                   true (catch Exception
                                     _ false))
                             has-gh (try (shell
                               {:continue true :out
                                 :string} "which" "gh")
                                   true (catch Exception
                                     _ false))]
                         (println (if has-bb "‚úÖ" "‚ùå")
                           "Babashka")
                         (println (if has-nix "‚úÖ" "‚ùå")
                           "Nix")
                         (println (if has-git "‚úÖ" "‚ùå")
                           "Git")
                         (println (if has-gh "‚úÖ" "‚ö†Ô∏è ")
                           "GitHub CLI (optional)")
                         (println "")
                         (when-not has-nix
                           (println "‚ö†Ô∏è  Nix recommended
                             for reproducible builds"))
                         (println "Bootstrap
                           complete")))}}}

;; kae3g content pipeline: sacred writings + technical docs
;; Markdown ‚Üí ClojureScript DSL ‚Üí Svelte ‚Üí Static Site
;; Contemplative technology with 80-char wrapping
;; bb orchestrates Nix and manages entire development
  lifecycle