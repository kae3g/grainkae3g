{
  "slug" : "9997-framework-laptop-microkernel-dev",
  "meta" : {
    "slug" : "9997-framework-laptop-microkernel-dev",
    "title" : "kae3g 9997: Framework Laptop Microkernel Development — A Beginner's Guide to Simple, Beautiful Linux Workflows",
    "filename" : "9997-framework-laptop-microkernel-dev.md",
    "source-dir" : "hidden"
  },
  "html" : "<h1>kae3g 9997: Framework Laptop Microkernel Development — A Beginner's Guide to Simple, Beautiful Linux Workflows</h1><p><strong>Timestamp:</strong> 12025-10-10&ndash;rhizome-valley<br /> <strong>Series:</strong> Technical Writings (9999 → 0000)<br /> <strong>Category:</strong> Hardware, Linux, Development Environment, Microkernel Systems<br /> <strong>Reading Time:</strong> 60 minutes</p><h2>The Question</h2><p><em>How do I set up a Framework 13 or Framework 16 laptop with AMD CPU/GPU for experimental microkernel-level development using the principles of simplicity and beauty described in our learning path (9998)?</em></p><h2>Introduction: The Perfect Garden Tool</h2><blockquote><p> <strong>🔗 This essay connects theory to practice:</strong> <br /> From <a href='9999-nixpkgs-clojure'>9999: Clojure & Nix Ecosystem</a> you learned WHY init systems and package management matter. <br /> From <a href='9998-learning-path-init-systems'>9998: Learning Path</a> you learned HOW to master them. <br /> Now in 9997: Apply those concepts to REAL HARDWARE (Framework laptop). </p></blockquote><p>In Helen Atthowe's ecological farm, the choice of tools matters. A good spade feels right in your hands, cuts cleanly through soil without excessive force, and lasts for generations with proper care. The Framework laptop is the spade of modern computing—repairable, upgradeable, respectful of your ownership.</p><p>Combined with the right Linux distribution and workflow, it becomes the ideal instrument for exploring the microkernels, init systems, and infuse.nix paradigms we've studied. This essay guides beginners through the entire journey—from hardware choice to daily workflow.</p><pre><code class=\"clojure\">{:the-framework-philosophy\n &quot;Framework laptops embody:\n  - Modularity &#40;replaceable everything&#41;\n  - Ownership &#40;you control your hardware&#41;\n  - Sustainability &#40;repair instead of replace&#41;\n  - Transparency &#40;no planned obsolescence&#41;\n  \n  These values align perfectly with:\n  - Microkernel design &#40;modularity&#41;\n  - NixOS philosophy &#40;declarative control&#41;\n  - Open source ethos &#40;transparency&#41;\n  - Ecological farming &#40;sustainability&#41;&quot;}\n</code></pre><h2></h2><h1>Part I: Hardware Selection — Framework 13 vs Framework 16</h1><h2>For Apprentices: Understanding Your Tool</h2><h3>Framework 13 (13.5\" Display)</h3><pre><code class=\"clojure\">{:framework-13\n {:target-user\n  &quot;Solo developer, student, nomadic hacker&quot;\n  \n  :specifications\n  {:display &quot;13.5\\&quot; 2256×1504 &#40;3:2 aspect ratio&#41;&quot;\n   :weight &quot;&#126;1.3 kg &#40;2.87 lbs&#41;&quot;\n   :battery &quot;55 Wh&quot;\n   :ports &quot;4× expansion card slots &#40;USB-C, USB-A, HDMI, etc.&#41;&quot;\n   :cpu-options\n   &#91;&quot;AMD Ryzen 7 7840U &#40;8-core, 16-thread&#41;&quot;\n    &quot;AMD Ryzen 5 7640U &#40;6-core, 12-thread&#41;&quot;&#93;}\n  \n  :amd-advantages\n  &quot;- Integrated Radeon graphics &#40;no discrete GPU complexity&#41;\n   - Excellent Linux driver support &#40;open-source&#41;\n   - Lower power consumption vs Intel\n   - Better performance-per-watt\n   - Full support in mainline kernel&quot;\n  \n  :ideal-for\n  &#91;&quot;Learning microkernel development &#40;seL4, Redox OS&#41;&quot;\n   &quot;NixOS experimentation with infuse.nix&quot;\n   &quot;Terminal-heavy workflows &#40;s6, runit, OpenRC&#41;&quot;\n   &quot;Portable daily driver + dev machine&quot;\n   &quot;Budget-conscious learners&quot;&#93;\n  \n  :limitations\n  &#91;&quot;No discrete GPU &#40;graphics-intensive work limited&#41;&quot;\n   &quot;Smaller screen &#40;may want external monitor&#41;&quot;\n   &quot;Less RAM capacity &#40;max 64GB&#41;&quot;&#93;}\n</code></pre><h3>Framework 16 (16\" Display with Modular GPU)</h3><pre><code class=\"clojure\">{:framework-16\n {:target-user\n  &quot;Power user, graphics developer, multi-monitor setup enthusiast&quot;\n  \n  :specifications\n  {:display &quot;16\\&quot; 2560×1600 &#40;16:10 aspect ratio&#41;&quot;\n   :weight &quot;&#126;2.1 kg &#40;4.6 lbs&#41; without dGPU, &#126;2.4 kg with&quot;\n   :battery &quot;85 Wh&quot;\n   :ports &quot;6× expansion card slots&quot;\n   :cpu-options\n   &#91;&quot;AMD Ryzen 9 7940HS &#40;8-core, 16-thread&#41;&quot;\n    &quot;AMD Ryzen 7 7840HS &#40;8-core, 16-thread&#41;&quot;&#93;\n   :gpu-module\n   &quot;Optional AMD Radeon RX 7700S &#40;8GB GDDR6&#41; - REMOVABLE&quot;}\n  \n  :amd-advantages\n  &quot;- All AMD CPU benefits from Framework 13\n   - Modular GPU: add/remove as needed\n   - More expansion card flexibility\n   - Larger cooling system &#40;sustained performance&#41;\n   - Open-source GPU drivers &#40;amdgpu kernel module&#41;&quot;\n  \n  :ideal-for\n  &#91;&quot;Redox OS graphics development &#40;orbital display server&#41;&quot;\n   &quot;Testing GPU passthrough to VMs &#40;seL4 + graphics&#41;&quot;\n   &quot;Multi-monitor workflows &#40;3-4 external displays&#41;&quot;\n   &quot;Long-term investment &#40;more upgradeable&#41;&quot;\n   &quot;GPU compute experiments &#40;ML inference, rendering&#41;&quot;&#93;\n  \n  :limitations\n  &#91;&quot;Heavier &#40;less portable&#41;&quot;\n   &quot;More expensive&quot;\n   &quot;GPU module adds cost and complexity&quot;\n   &quot;Larger power brick needed with dGPU&quot;&#93;}\n</code></pre><h3>Decision Matrix for Beginners</h3><pre><code class=\"clojure\">{:choose-framework-13-if\n &#91;&quot;Budget: $1000-1500&quot;\n  &quot;Portability is priority&quot;\n  &quot;Primarily terminal/text-based development&quot;\n  &quot;Learning seL4, SixOS, infuse.nix concepts&quot;\n  &quot;Don't need GPU-intensive tasks&quot;\n  &quot;Want simplest, most elegant solution&quot;&#93;\n \n :choose-framework-16-if\n &#91;&quot;Budget: $2000-3000&quot;\n  &quot;Need graphics development &#40;Redox orbital&#41;&quot;\n  &quot;Want future-proof expandability&quot;\n  &quot;Run multiple VMs with GPU passthrough&quot;\n  &quot;Use 2-3 external monitors&quot;\n  &quot;Long-term investment mindset&quot;&#93;}\n</code></pre><p><strong>Beginner Recommendation:</strong> Start with Framework 13. It embodies the \"simple and beautiful\" philosophy. You can always upgrade later—that's the Framework promise.<h2></h2></p><h1>Part II: Linux Distribution Choice — Applying 9998 Principles</h1><h2>The Rich Hickey Question: \"What is Simple?\"</h2><p>From our 9998 learning path, Rich Hickey teaches: <strong>\"Simple is not easy. Simple is lack of interleaving.\"</strong></p><p>Let's evaluate distributions through this lens:</p><h3>Ubuntu/Pop!_OS (Not Simple, But Easy)</h3><pre><code class=\"clojure\">{:ubuntu-analysis\n {:what-it-is\n  &quot;General-purpose, user-friendly, heavily pre-configured&quot;\n  \n  :complected-aspects\n  &quot;- Snap packages interleaved with apt packages\n   - systemd deeply integrated &#40;can't easily swap&#41;\n   - Many pre-installed services you don't need\n   - Desktop environment tightly coupled\n   - Two parallel package systems &#40;snap + deb&#41;&quot;\n  \n  :rich-hickey-verdict\n  &quot;Easy &#40;familiar, GUI-driven&#41; but NOT simple &#40;many braided concerns&#41;.&quot;\n  \n  :use-case\n  &quot;First Linux experience for non-technical users. NOT ideal for learning microkernels.&quot;}\n</code></pre><h3>Arch Linux (Simple AND Hard, Initially)</h3><pre><code class=\"clojure\">{:arch-linux-analysis\n {:what-it-is\n  &quot;Minimalist, rolling-release, build-your-own-system philosophy&quot;\n  \n  :simple-aspects\n  &quot;- One package manager &#40;pacman&#41;, clear hierarchy\n   - No pre-installed bloat—you add what you need\n   - systemd by default BUT easy to replace &#40;see Artix&#41;\n   - Transparent: /etc is readable, nothing hidden\n   - AUR provides community packages without complexity&quot;\n  \n  :learning-curve\n  &quot;Steep initially &#40;manual installation&#41;, but teaches fundamentals.\n   Arch Wiki is legendary—best Linux documentation anywhere.&quot;\n  \n  :framework-laptop-support\n  &quot;Excellent. AMD drivers in mainline kernel, firmware in linux-firmware package.&quot;\n  \n  :rich-hickey-verdict\n  &quot;Simple &#40;minimal interleaving&#41; but hard &#40;requires understanding&#41;.\n   Perfect match for learning journey.&quot;\n  \n  :microkernel-development-fit\n  &quot;✓ Easy to install seL4 toolchain\n   ✓ Build Redox OS from source &#40;documented in Arch Wiki&#41;\n   ✓ Switch to Artix for runit/OpenRC experiments\n   ✓ Install Nix package manager alongside pacman&quot;}\n</code></pre><h3>NixOS (Simple Philosophy, Declarative Complexity)</h3><pre><code class=\"clojure\">{:nixos-analysis\n {:what-it-is\n  &quot;Declarative, reproducible, functional package management as OS&quot;\n  \n  :simple-in-theory\n  &quot;- Everything declared in configuration.nix\n   - Atomic upgrades, rollbacks &#40;generations&#41;\n   - No hidden state—/nix/store is explicit&quot;\n  \n  :complex-in-practice\n  &quot;- Nix language has learning curve\n   - systemd deeply integrated &#40;hence SixOS project&#41;\n   - Module system can be confusing\n   - Error messages cryptic for beginners&quot;\n  \n  :framework-laptop-support\n  &quot;Good, but requires manual hardware-configuration.nix setup.&quot;\n  \n  :rich-hickey-verdict\n  &quot;Simple philosophy, but implementation has interleaved concerns &#40;modules + systemd&#41;.&quot;\n  \n  :microkernel-development-fit\n  &quot;✓ Reproducible build environments\n   ✓ Perfect for learning infuse.nix paradigm\n   ✗ systemd lock-in &#40;until SixOS matures&#41;\n   &#126; Better as second distro after mastering basics&quot;}\n</code></pre><h3>Void Linux with runit (Simple AND Elegant)</h3><pre><code class=\"clojure\">{:void-linux-analysis\n {:what-it-is\n  &quot;Independent, rolling-release, runit-based, minimalist&quot;\n  \n  :simple-aspects\n  &quot;- runit for init &#40;studied in 9998 Phase 2&#41;\n   - xbps package manager &#40;fast, simple&#41;\n   - musl libc option &#40;even more minimal&#41;\n   - No systemd &#40;clean, uncomplicated boot&#41;\n   - Small, focused community&quot;\n  \n  :framework-laptop-support\n  &quot;Excellent. AMD drivers work out-of-box.&quot;\n  \n  :rich-hickey-verdict\n  &quot;Truly simple. One concern per layer:\n   - runit: supervise services\n   - xbps: manage packages\n   - No feature creep, no bloat&quot;\n  \n  :technical-depth-from-9999\n  &quot;🔗 Why runit's simplicity matters &#40;from 9999&#41;:\n   \n   System call overhead &#40;from &#91;9999: Buffering &amp; Batching&#93;&#40;9999-nixpkgs-clojure&#41;&#41;:\n   - Each system call: &#126;1000-10000 CPU cycles\n   - Context switch: user space ↔ kernel space\n   \n   systemd approach:\n   - Complex service activation &#40;many syscalls&#41;\n   - Binary logging &#40;journald requires parsing&#41;\n   - D-Bus IPC &#40;additional overhead&#41;\n   \n   runit approach:\n   - Simple fork/exec &#40;minimal syscalls&#41;\n   - Text logging &#40;direct write&#41;\n   - Unix pipes &#40;kernel-optimized&#41;\n   \n   Result: runit is FASTER because it minimizes system call overhead.\n   This is why it's perfect for learning—see the efficiency directly.&quot;\n  \n  :microkernel-development-fit\n  &quot;✓✓ PERFECT for learning runit &#40;default init&#41;\n   ✓ Lightweight, won't interfere with experiments\n   ✓ Easy to build seL4/Redox from source\n   ✓ Can install Nix package manager separately&quot;\n  \n  :deep-dive-xbps-src\n  &quot;Void's secret weapon: xbps-src template system\n   \n   xbps-src philosophy:\n   - Build packages from source templates\n   - Each template = shell script + metadata\n   - Reproducible builds in isolated containers\n   - Like Nix but simpler &#40;shell, not language&#41;\n   \n   Example template &#40;srcpkgs/myapp/template&#41;:\n   \n   # Template file\n   pkgname=myapp\n   version=1.0.0\n   revision=1\n   build&#95;style=gnu-configure\n   hostmakedepends=\\&quot;pkg-config\\&quot;\n   makedepends=\\&quot;openssl-devel\\&quot;\n   short&#95;desc=\\&quot;My application\\&quot;\n   maintainer=\\&quot;you &lt;you@example.com&gt;\\&quot;\n   license=\\&quot;MIT\\&quot;\n   homepage=\\&quot;https://example.com/myapp\\&quot;\n   distfiles=\\&quot;https://example.com/myapp-${version}.tar.gz\\&quot;\n   checksum=\\&quot;sha256...\\&quot;\n   \n   Build with:\n   $ ./xbps-src pkg myapp\n   \n   Install:\n   $ xi myapp\n   \n   Why this matters:\n   - You OWN your package definitions &#40;storehouse concept!&#41;\n   - Fork void-packages → your own 'grainhouse'\n   - Reproducible source builds\n   - musl compatibility tested per package&quot;\n  \n  :musl-vs-glibc-deep-dive\n  &quot;Void offers TWO C libraries:\n   \n   glibc &#40;default&#41;:\n   - Standard, widely compatible\n   - Larger binary size\n   - All software works\n   \n   musl &#40;optional, suffix: -musl&#41;:\n   - Minimal, clean codebase\n   - Smaller binaries\n   - Some compatibility issues &#40;rare&#41;\n   - Perfect for embedded/minimal systems\n   \n   For microkernel development:\n   Use musl variant! Teaches you:\n   - Minimal dependencies\n   - POSIX compliance &#40;what's actually standard&#41;\n   - Closer to seL4/Redox philosophy\n   \n   Install: void-linux-musl.iso instead of void-linux.iso\n   \n   🔗 Deep dive on system calls and libc:\n   See &#91;9999: System Call Efficiency&#93;&#40;9999-nixpkgs-clojure#educational-background-buffering-and-batching&#41;\n   - Why buffering matters &#40;reduces syscall overhead&#41;\n   - musl vs glibc performance implications\n   - How Alpine &#40;musl&#41; achieves 5MB base vs NixOS &#40;glibc&#41; 200MB&quot;\n  \n  :xbps-architecture\n  &quot;xbps package manager internals:\n   \n   Components:\n   - xbps-install: Install packages\n   - xbps-remove: Remove packages\n   - xbps-query: Query package database\n   - xbps-src: Build from source templates\n   - xbps-uchroot: Isolated build environment\n   \n   Storage:\n   /var/db/xbps/          # Package database\n   /etc/xbps.d/           # Repo configs\n   srcpkgs/&#42;/template     # Build templates &#40;your storehouse!&#41;\n   \n   Speed comparison:\n   - xbps-install: &#126;0.5 seconds to install small package\n   - apt-get: &#126;2-3 seconds &#40;slower metadata&#41;\n   - pacman: &#126;1 second &#40;comparable&#41;\n   - nix-env: &#126;5-10 seconds &#40;evaluation overhead&#41;\n   \n   xbps is FAST because: simple C implementation, minimal metadata&quot;\n  \n  :risc-v-readiness\n  &quot;Void Linux + RISC-V future:\n   \n   Current status &#40;2025&#41;:\n   - No official RISC-V port yet\n   - But xbps-src supports cross-compilation\n   - musl works on RISC-V &#40;Alpine has riscv64 port&#41;\n   \n   Migration path:\n   1. Use Void musl NOW &#40;Framework AMD&#41;\n   2. Fork void-packages → your-grainhouse\n   3. Add RISC-V cross-compile targets to templates\n   4. Test in QEMU riscv64\n   5. When hardware arrives, you're ready\n   \n   Why Void is ideal starting point:\n   - Simple templates &#40;easier to port than Nix expressions&#41;\n   - musl already RISC-V compatible\n   - runit compiles anywhere &#40;portable C&#41;\n   - Small community = easier to influence/fork&quot;}}\n</code></pre><h3>Artix Linux (Arch Without systemd)</h3><pre><code class=\"clojure\">{:artix-linux-analysis\n {:what-it-is\n  &quot;Arch Linux base with choice of init: OpenRC, runit, s6, or dinit&quot;\n  \n  :simple-aspects\n  &quot;- Arch package ecosystem &#40;AUR, pacman&#41;\n   - Freedom to choose init system &#40;studied in 9998&#41;\n   - All Arch Wiki knowledge applies\n   - systemd removed, clean separation&quot;\n  \n  :framework-laptop-support\n  &quot;Excellent &#40;inherits Arch's support&#41;.&quot;\n  \n  :rich-hickey-verdict\n  &quot;Simple AND flexible. Separates init concern from package management.&quot;\n  \n  :microkernel-development-fit\n  &quot;✓✓✓ IDEAL for 9998 learning path:\n   - Install with runit, experiment with OpenRC later\n   - Switch to s6-rc &#40;sixos connection&#41;\n   - All Arch tools + init system freedom\n   - Best of both worlds&quot;}\n</code></pre><h2>The Analytical Decision: Void vs Artix for Your Goals</h2><h3>Your Specific Goals Restated</h3><pre><code class=\"clojure\">{:your-objectives\n &#91;&quot;Build user-friendly, secure, portable OS&quot;\n  &quot;Rich Hickey + Helen Atthowe design principles&quot;\n  &quot;Framework laptop &#40;AMD CPU/GPU&#41;&quot;\n  &quot;Progress toward RISC-V CPU+GPU boards&quot;\n  &quot;Support Clojure/Babashka build workflow&quot;\n  &quot;Simple, beautiful, observable systems&quot;&#93;}\n</code></pre><h3>Deep Comparison: Void musl vs Artix runit</h3><pre><code class=\"clojure\">{:the-tradeoff-analysis\n {:void-linux-musl\n  {:strengths\n   &#91;&quot;✓✓ Simplest possible base &#40;runit + musl + xbps&#41;&quot;\n    &quot;✓✓ RISC-V migration path clearest &#40;musl already works on riscv64&#41;&quot;\n    &quot;✓✓ xbps-src templates = your 'grainhouse' &#40;fork and own&#41;&quot;\n    &quot;✓ Faster package operations &#40;0.5s vs 1-2s&#41;&quot;\n    &quot;✓ Smaller binaries &#40;musl vs glibc&#41;&quot;\n    &quot;✓ Forces POSIX compliance &#40;teaches standards&#41;&quot;\n    &quot;✓ Independent distro &#40;no corporate ties&#41;&quot;&#93;\n   \n   :challenges\n   &#91;&quot;✗ Smaller package repository &#40;&#126;13,000 vs Arch's 80,000+&#41;&quot;\n    &quot;✗ Some software doesn't compile on musl &#40;rare but exists&#41;&quot;\n    &quot;✗ Babashka/Clojure may have musl compatibility issues&quot;\n    &quot;✗ Smaller community &#40;less StackOverflow help&#41;&quot;\n    &quot;✗ Steeper learning &#40;must build more from source&#41;&quot;&#93;\n   \n   :clojure-workflow-reality\n   &quot;Babashka: Native binary, might work on musl &#40;need testing&#41;\n    Clojure JVM: Works but OpenJDK on musl has quirks\n    \n    Workaround:\n    - Use glibc Void variant for JVM work\n    - Or use Babashka exclusively &#40;faster anyway&#41;\n    - Or run Clojure in Nix dev shell on Void host&quot;}\n  \n  :artix-linux-runit\n  {:strengths\n   &#91;&quot;✓✓ Arch package ecosystem &#40;80,000+ packages + AUR&#41;&quot;\n    &quot;✓✓ Legendary documentation &#40;Arch Wiki&#41;&quot;\n    &quot;✓✓ Clojure/Babashka 'just works' &#40;glibc compatibility&#41;&quot;\n    &quot;✓ Same runit learning as Void&quot;\n    &quot;✓ Larger community&quot;\n    &quot;✓ Choice of init &#40;runit, OpenRC, s6&#41;&quot;&#93;\n   \n   :challenges\n   &#91;&quot;✗ glibc larger footprint &#40;vs musl&#41;&quot;\n    &quot;✗ RISC-V path less clear &#40;glibc porting harder&#41;&quot;\n    &quot;✗ Not as 'pure' &#40;Arch complexity seeps in&#41;&quot;\n    &quot;✗ More packages = more to manage&quot;&#93;\n   \n   :clojure-workflow-reality\n   &quot;Babashka: pacman -S babashka &#40;works perfectly&#41;\n    Clojure: pacman -S clojure &#40;OpenJDK included&#41;\n    \n    Your current bb.edn tasks work immediately.\n    No friction.&quot;}}\n \n :the-analytical-decision\n {:for-risc-v-future\n  &quot;Void musl wins:\n   - musl already on RISC-V\n   - Simpler stack to port\n   - xbps-src templates easier than Nix/Arch PKGBUILD\n   - Forces minimal dependency discipline&quot;\n  \n  :for-clojure-workflow-now\n  &quot;Artix wins:\n   - Babashka/Clojure work immediately\n   - Your bb.edn tasks unchanged\n   - Faster development &#40;less fighting tooling&#41;&quot;\n  \n  :for-learning-path-9998\n  &quot;Tie:\n   - Both teach runit equally well\n   - Both avoid systemd\n   - Both simple and observable&quot;\n  \n  :for-package-storehouse-concept\n  &quot;Void wins:\n   - xbps-src templates = your grainhouse\n   - Fork void-packages easily\n   - Shell-based &#40;simpler than Nix&#41;\n   - Source-based builds &#40;reproducible&#41;&quot;}}\n</code></pre><h2>The Recommendation: Dual Path Strategy</h2><p><strong>Don't choose one—use BOTH strategically.</strong></p><h3>Strategy: Void musl as Target, Artix as Development Host</h3><pre><code class=\"clojure\">{:the-hybrid-approach\n {:phase-1-now\n  &quot;Install Artix runit on Framework:\n   - Get productive immediately &#40;Clojure works&#41;\n   - Learn runit in daily use &#40;9998 Phase 2&#41;\n   - Build Redox OS, seL4 natively\n   - Use Nix dev shells for reproducibility&quot;\n  \n  :phase-2-parallel\n  &quot;Run Void musl in QEMU on Artix:\n   - Test musl compatibility for your projects\n   - Fork void-packages → your-grainhouse\n   - Build custom packages with xbps-src\n   - Prepare RISC-V cross-compile templates&quot;\n  \n  :phase-3-risc-v-prep\n  &quot;On Artix host:\n   - Install riscv64 cross toolchain\n   - Build QEMU system-riscv64\n   - Test Void musl in QEMU riscv64\n   - Port your critical packages to RISC-V&quot;\n  \n  :phase-4-hardware-transition\n  &quot;When RISC-V Framework board arrives:\n   - Boot Void musl riscv64 from USB\n   - Your grainhouse templates already ported\n   - Babashka might need recompile &#40;GraalVM on RISC-V&#41;\n   - Or use alternative: Janet, Fennel, or pure shell&quot;\n  \n  :from-rich-hickey\n  &quot;\\&quot;Don't layer new stuff on old stuff—understand the levels.\\&quot;\n   \n   Levels in this strategy:\n   Level 1: Artix &#40;comfortable, productive NOW&#41;\n   Level 2: Void musl &#40;minimal, portable FUTURE&#41;\n   Level 3: RISC-V &#40;long-term sovereignty&#41;\n   \n   Each level teaches the next.\n   No premature optimization.\n   No building RISC-V OS before you understand x86.&quot;\n  \n  :from-helen-atthowe\n  &quot;\\&quot;Start with soil health, then plant.\\&quot;\n   \n   Soil health = understanding your base system:\n   - Artix teaches you runit, package management, Linux\n   - Void teaches you musl, source builds, minimalism\n   - RISC-V teaches you architecture independence\n   \n   Plant &#40;your OS project&#41; only when soil &#40;understanding&#41; is ready.&quot;}\n</code></pre><p><strong>Concrete Recommendation for You:</strong></p><ol><li><strong>Install Artix runit on Framework 13/16</strong> (this week)</li><li><strong>Follow the Artix installation guide</strong> below (proven path)</li><li><strong>Set up Void musl in QEMU</strong> (next month, parallel learning)</li><li><strong>Fork void-packages</strong> → your-grainhouse repository (establish storehouse)</li><li><strong>Test Clojure on both</strong> (document compatibility issues)</li><li><strong>Choose final direction</strong> after 2-3 months hands-on experience<h2></h2></li></ol><h2>The Cosmopolitan Libc Revolution: A Third Path</h2><h3>For Apprentices: What is Actually Portable Executable (APE)?</h3><pre><code class=\"clojure\">{:cosmopolitan-libc-overview\n {:created-by &quot;Justine Tunney&quot;\n  :tagline &quot;build-once run-anywhere C library&quot;\n  \n  :the-radical-idea\n  &quot;Traditional approach:\n   - Compile for Linux → linux-binary\n   - Compile for macOS → macos-binary\n   - Compile for Windows → windows.exe\n   - Compile for BSD → bsd-binary\n   Result: 4 binaries for 4 platforms\n   \n   Cosmopolitan approach:\n   - Compile ONCE → actually-portable-executable\n   - Runs on: Linux, macOS, Windows, FreeBSD, OpenBSD, NetBSD\n   Result: 1 binary for ALL platforms\n   \n   How? The binary contains bootloaders for each OS format:\n   - Looks like ELF to Linux\n   - Looks like Mach-O to macOS\n   - Looks like PE to Windows\n   - Looks like a.out to BSD\n   \n   It's a polyglot binary—speaks every OS's native language!&quot;\n  \n  :analogy-for-seventh-grader\n  &quot;Imagine a magic book that changes its language based on who's reading it.\n   English speaker sees English.\n   Spanish speaker sees Spanish.\n   Chinese speaker sees Chinese.\n   \n   Same book, different readers, perfect translation for each.\n   \n   Cosmopolitan binaries are magic books for operating systems.&quot;}\n</code></pre><h3>How Cosmopolitan Changes Everything</h3><pre><code class=\"clojure\">{:cosmopolitan-implications\n {:for-framework-laptop\n  &quot;Compile your OS utilities ONCE on Framework:\n   - Binary runs on Linux &#40;your Artix/Void&#41;\n   - Same binary runs on macOS &#40;your Mac&#41;\n   - Same binary runs on Windows &#40;friend's PC&#41;\n   - Same binary tests on BSD &#40;production server&#41;\n   \n   Development workflow:\n   1. Write C code using Cosmopolitan headers\n   2. Compile: cosmocc -o myapp myapp.c\n   3. Ship myapp to any platform\n   4. Done.&quot;\n  \n  :for-risc-v-future\n  &quot;Current limitation: Cosmopolitan supports x86&#95;64 primarily.\n   ARM64 support exists but limited.\n   RISC-V: Not yet &#40;as of 2025&#41;.\n   \n   But the APPROACH is revolutionary:\n   Once Cosmopolitan adds RISC-V target,\n   your binaries run on x86 + ARM + RISC-V simultaneously.\n   \n   This is the ULTIMATE portability.&quot;\n  \n  :for-grainhouse-strategy\n  &quot;Instead of forking void-packages &#40;13,000 templates&#41;,\n   or maintaining Nix packages &#40;80,000+ packages&#41;,\n   \n   Build YOUR essential tools with Cosmopolitan:\n   - Text editors &#40;compile vi/neovim with cosmocc&#41;\n   - Build tools &#40;make, cmake, etc.&#41;\n   - System utilities &#40;coreutils&#41;\n   - Your applications\n   \n   Result: TINY grainhouse &#40;maybe 100 tools&#41;\n   that works EVERYWHERE &#40;Linux, Mac, BSD, RISC-V eventually&#41;&quot;}\n \n :performance-vs-musl-vs-glibc\n {:memcpy-benchmark\n  &quot;Cosmopolitan's memcpy&#40;&#41; outperforms:\n   - glibc: 15% faster &#40;multiple optimized strategies&#41;\n   - musl: 30% faster &#40;clever assembly tricks&#41;\n   - Apple's: 20% faster\n   \n   Other functions similarly optimized.\n   Smaller binaries than glibc, comparable to musl.&quot;\n  \n  :startup-time\n  &quot;Cosmopolitan binaries detect OS and configure at startup.\n   Overhead: &#126;1-2 milliseconds\n   Negligible for most applications.\n   \n   For comparison:\n   - JVM startup: 50-200 ms\n   - Python startup: 20-50 ms\n   - Cosmopolitan overhead: 1-2 ms\n   \n   Essentially free.&quot;}}\n</code></pre><h3>The Rich Hickey Analysis: Cosmopolitan vs Traditional</h3><pre><code class=\"clojure\">{:hickey-lens\n {:traditional-approach-complected\n  &quot;Cross-platform C development traditionally:\n   \n   - Autotools &#40;./configure, make&#41; for build portability\n   - #ifdef PLATFORM macros everywhere\n   - Different makefiles for different OSes\n   - Conditional compilation\n   - Link different libraries per platform\n   \n   This is COMPLECTED:\n   - Build logic interleaved with platform logic\n   - Source code braided with conditionals\n   - Hard to reason about: Which code runs on which platform?&quot;\n  \n  :cosmopolitan-approach-simple\n  &quot;With Cosmopolitan:\n   \n   - Write standard POSIX C &#40;one codebase&#41;\n   - Compile once with cosmocc\n   - Binary contains ALL platform code\n   - Runtime detects and chooses\n   \n   This is SIMPLE:\n   - One concern: Write correct C\n   - One dimension: POSIX compliance\n   - No platform interleaving in source\n   - Runtime polymorphism &#40;like OOP, but for OSes&#41;&quot;\n  \n  :hickey-verdict\n  &quot;Cosmopolitan achieves what Hickey calls 'simplicity':\n   - Decomplecting platform concerns from application logic\n   - Single artifact &#40;like immutable value&#41;\n   - Polymorphic behavior &#40;runtime adaptation&#41;\n   \n   This is elegant system design.&quot;}\n \n :ecological-metaphor\n &quot;Helen Atthowe: 'A healthy plant adapts to its environment.'\n  \n  Traditional cross-compilation:\n  - Grow separate plant varieties for each climate\n  - Tomato for California, different tomato for Oregon\n  - Maintain multiple seed lines\n  \n  Cosmopolitan approach:\n  - Single seed that adapts to any climate\n  - Same genetic code, phenotype varies by environment\n  - One seed line to maintain\n  \n  This is like perennial polyculture:\n  Plant once, harvest everywhere.&quot;}\n</code></pre><h3>The Grainhouse Vision with Cosmopolitan</h3><pre><code class=\"clojure\">{:cosmopolitan-grainhouse\n {:the-concept\n  &quot;Instead of forking entire distro repositories:\n   \n   void-packages: 13,000 templates &#40;huge&#41;\n   nixpkgs: 80,000+ packages &#40;overwhelming&#41;\n   \n   Fork Cosmopolitan + YOUR essential tools:\n   \n   your-grainhouse/\n     ├── cosmocc/           # Compiler toolchain\n     ├── tools/\n     │   ├── coreutils/     # ls, cp, mv, etc.\n     │   ├── editor/        # vim or neovim\n     │   ├── shell/         # bash or zsh\n     │   ├── build/         # make, cmake\n     │   └── network/       # curl, wget\n     ├── runtime/\n     │   ├── babashka/      # If possible to compile with Cosmopolitan\n     │   └── your-app/\n     └── README.md\n   \n   Total: Maybe 50-100 programs.\n   Each is APE &#40;works on any platform&#41;.\n   \n   This is manageable. This is owned. This is your storehouse.&quot;\n  \n  :build-process\n  &quot;# Clone Cosmopolitan\n   git clone https://github.com/jart/cosmopolitan.git\n   \n   # Build cosmocc compiler\n   make -j8\n   \n   # Compile your tool\n   cosmocc -o myeditor myeditor.c\n   \n   # Test on multiple platforms\n   ./myeditor  # Works on Linux\n   scp myeditor mac:  # Copy to Mac\n   ssh mac ./myeditor  # Works on macOS!\n   \n   Same binary, zero modification.&quot;\n  \n  :for-clojure-workflow\n  &quot;Challenge: Babashka is GraalVM native-image.\n   GraalVM doesn't support Cosmopolitan &#40;yet&#41;.\n   \n   Two paths:\n   \n   Path A &#40;pragmatic&#41;:\n   - Use Babashka on host system &#40;Artix/Void&#41;\n   - Use Cosmopolitan for system utilities\n   - bb.edn tasks call Cosmopolitan tools\n   \n   Path B &#40;ambitious&#41;:\n   - Build minimal Clojure interpreter in C\n   - Compile with Cosmopolitan\n   - Limited Clojure subset, but portable\n   \n   Path C &#40;hybrid&#41;:\n   - Use Janet language &#40;Lisp-like, C-based&#41;\n   - Compiles with Cosmopolitan\n   - Similar to Clojure &#40;REPL, functional&#41;\n   - Your bb.edn → janet build scripts&quot;}\n \n :risc-v-timeline\n &quot;Cosmopolitan + RISC-V:\n  \n  Current: x86&#95;64 primary, ARM64 experimental\n  Future: RISC-V target planned\n  \n  When it arrives, your grainhouse binaries\n  automatically work on RISC-V.\n  \n  No recompile. No port. Just run.\n  \n  This is the dream of 'write once, run anywhere'\n  that Java promised but never fully delivered.&quot;}\n</code></pre><h3>Updated Recommendation with Cosmopolitan</h3><pre><code class=\"clojure\">{:three-path-strategy\n {:path-1-artix-runit\n  &quot;Start here &#40;Framework laptop NOW&#41;:\n   - Productive immediately &#40;Arch packages&#41;\n   - Learn runit &#40;9998 Phase 2&#41;\n   - Clojure/Babashka work perfectly\n   - Build Redox, seL4, SixOS in QEMU&quot;\n  \n  :path-2-void-musl-grainhouse\n  &quot;Parallel development &#40;QEMU first&#41;:\n   - Fork void-packages → your-grainhouse\n   - Test musl compatibility\n   - Prepare RISC-V templates\n   - Minimal, portable, owned&quot;\n  \n  :path-3-cosmopolitan-tools\n  &quot;Long-term portability layer:\n   - Build core tools with Cosmopolitan\n   - APE binaries in your grainhouse\n   - Works on Framework AND future RISC-V\n   - Smallest possible trusted base\n   \n   Progression:\n   1. Compile coreutils with Cosmopolitan\n   2. Test on Artix, Mac, Void\n   3. Add your custom tools\n   4. When RISC-V comes, binaries just work&quot;}\n \n :the-synthesis\n &quot;┌─────────────────────────────────────────┐\n  │ Your Applications &#40;Clojure/Babashka&#41;   │\n  │ - bb.edn tasks                          │\n  │ - Business logic                        │\n  └────────────┬────────────────────────────┘\n               │\n               ↓\n  ┌─────────────────────────────────────────┐\n  │ Cosmopolitan Tools &#40;APE binaries&#41;       │\n  │ - System utilities                      │\n  │ - Build tools                           │\n  │ - Your grainhouse                       │\n  └────────────┬────────────────────────────┘\n               │\n               ↓\n  ┌─────────────────────────────────────────┐\n  │ Void musl OR Artix runit               │\n  │ - runit supervision                     │\n  │ - Minimal base system                   │\n  └────────────┬────────────────────────────┘\n               │\n               ↓\n  ┌─────────────────────────────────────────┐\n  │ Framework AMD &#40;now&#41; → RISC-V &#40;future&#41;   │\n  │ - Open hardware                         │\n  │ - Upgradeable, repairable               │\n  └─────────────────────────────────────────┘\n  \n  Each layer is:\n  ✓ Simple &#40;single concern&#41;\n  ✓ Portable &#40;works across platforms&#41;\n  ✓ Owned &#40;you control the source&#41;\n  ✓ Observable &#40;no hidden magic&#41;\n  \n  This is Rich Hickey's simplicity +\n  Helen Atthowe's ecological stewardship +\n  Cosmopolitan's radical portability.&quot;}\n</code></pre><h3>Why Artix Wins</h3><pre><code class=\"clojure\">{:artix-rationale\n {:simplicity\n  &quot;runit as default = 9998 Phase 2 mastery built-in.\n   Every time you boot, you're learning.&quot;\n  \n  :beauty\n  &quot;Helen Atthowe: 'Observe natural processes.'\n   runit's three-stage boot is clean, observable:\n   Stage 1: Setup → Stage 2: Supervise → Stage 3: Shutdown\n   \n   No hidden magic. Text-based service directories.\n   Like a well-tended garden bed—everything visible.&quot;\n  \n  :flexibility\n  &quot;Pacman + AUR = vast package ecosystem.\n   Want seL4? `yay -S sel4-deps` &#40;from AUR&#41;.\n   Want Rust for Redox? `pacman -S rust`.\n   Want Nix? `curl -L https://nixos.org/nix/install | sh`&quot;\n  \n  :framework-support\n  &quot;Arch-based = stellar AMD support.\n   Framework-specific tweaks documented in Arch Wiki.&quot;\n  \n  :learning-path-alignment\n  &quot;✓ Phase 0 &#40;foundations&#41;: Learn Linux basics on Artix\n   ✓ Phase 1 &#40;SixOS&#41;: Understand s6 via runit similarities\n   ✓ Phase 2 &#40;OpenRC/runit&#41;: Artix supports both!\n   ✓ Phase 3 &#40;Rust&#41;: Build Redox OS natively\n   ✓ Phase 4 &#40;synthesis&#41;: Test SixOS in QEMU on Artix host&quot;}}\n</code></pre><h2></h2><h1>Part III: Installation Guide — Artix Linux on Framework Laptop</h1><h2>Pre-Installation: Apprentice Checklist</h2><pre><code class=\"clojure\">{:preparation\n {:download\n  &#91;&quot;Visit: artixlinux.org/download.php&quot;\n   &quot;Choose: artix-base-runit &#40;minimal, 600MB ISO&#41;&quot;\n   &quot;Verify: Check SHA256 sum&quot;&#93;\n  \n  :create-bootable-usb\n  &#91;&quot;macOS: Use balenaEtcher or dd command&quot;\n   &quot;Windows: Use Rufus or balenaEtcher&quot;\n   &quot;Linux: dd if=artix.iso of=/dev/sdX bs=4M&quot;&#93;\n  \n  :framework-bios-setup\n  &#91;&quot;Boot Framework, press F2 for BIOS&quot;\n   &quot;Disable Secure Boot &#40;Linux needs this&#41;&quot;\n   &quot;Set boot order: USB first&quot;\n   &quot;Save and exit&quot;&#93;\n  \n  :backup\n  &quot;If dual-booting, BACK UP EVERYTHING first!&quot;}\n</code></pre><h2>Installation: Step-by-Step for Beginners</h2><h3>Step 1: Boot the Live USB</h3><pre><code class=\"bash\"># You'll see Artix boot menu\n# Select: artix-base &#40;default&#41;\n# Login as: root &#40;no password on live system&#41;\n</code></pre><h3>Step 2: Connect to WiFi (If No Ethernet)</h3><pre><code class=\"bash\"># For Framework WiFi &#40;MediaTek MT7922&#41;:\nrfkill unblock wifi\nconnmanctl\n&gt; enable wifi\n&gt; agent on\n&gt; scan wifi\n&gt; services  # Lists available networks\n&gt; connect wifi&#95;&lt;TAB&gt;  # Auto-complete your network\n&gt; &#40;enter password&#41;\n&gt; quit\n\n# Test connection:\nping -c 3 artixlinux.org\n</code></pre><h3>Step 3: Partition the Disk</h3><p><strong>Framework ships with NVMe SSD. Let's use GPT + UEFI:</strong></p><pre><code class=\"bash\"># List disks:\nlsblk\n\n# Partition &#40;replace nvme0n1 with your disk&#41;:\ncfdisk /dev/nvme0n1\n\n# Create layout:\n# /dev/nvme0n1p1: 512MB  EFI System\n# /dev/nvme0n1p2: Rest   Linux filesystem\n\n# Format:\nmkfs.fat -F32 /dev/nvme0n1p1  # EFI partition\nmkfs.ext4 /dev/nvme0n1p2      # Root partition\n\n# Mount:\nmount /dev/nvme0n1p2 /mnt\nmkdir /mnt/boot\nmount /dev/nvme0n1p1 /mnt/boot\n</code></pre><h3>Step 4: Install Base System</h3><pre><code class=\"bash\"># Update package database:\npacman -Sy\n\n# Install base:\nbasestrap /mnt base base-devel runit elogind-runit linux linux-firmware\n\n# AMD-specific firmware:\nbasestrap /mnt amd-ucode\n\n# Essential tools:\nbasestrap /mnt vim networkmanager networkmanager-runit\n\n# Generate fstab:\nfstabgen -U /mnt &gt;&gt; /mnt/etc/fstab\n</code></pre><h3>Step 5: Configure the System</h3><pre><code class=\"bash\"># Chroot into new system:\nartix-chroot /mnt\n\n# Set timezone &#40;example: US Pacific&#41;:\nln -sf /usr/share/zoneinfo/America/Los&#95;Angeles /etc/localtime\nhwclock --systohc\n\n# Set locale:\nvim /etc/locale.gen\n# Uncomment: en&#95;US.UTF-8 UTF-8\nlocale-gen\necho &quot;LANG=en&#95;US.UTF-8&quot; &gt; /etc/locale.conf\n\n# Set hostname:\necho &quot;framework-dev&quot; &gt; /etc/hostname\n\n# Set root password:\npasswd\n\n# Create user:\nuseradd -m -G wheel -s /bin/bash yourname\npasswd yourname\n\n# Enable sudo:\nEDITOR=vim visudo\n# Uncomment: %wheel ALL=&#40;ALL:ALL&#41; ALL\n</code></pre><h3>Step 6: Install Bootloader</h3><pre><code class=\"bash\"># Install GRUB for UEFI:\npacman -S grub efibootmgr\n\n# Install GRUB:\ngrub-install --target=x86&#95;64-efi --efi-directory=/boot --bootloader-id=GRUB\n\n# Generate config:\ngrub-mkconfig -o /boot/grub/grub.cfg\n</code></pre><h3>Step 7: Enable Services (runit Style!)</h3><pre><code class=\"bash\"># NetworkManager:\nln -s /etc/runit/sv/networkmanager /run/runit/service/\n\n# &#40;More services added post-install as needed&#41;\n</code></pre><h3>Step 8: Reboot</h3><pre><code class=\"bash\">exit  # Leave chroot\numount -R /mnt\nreboot\n</code></pre><p><strong>Remove USB when Framework restarts. You should boot into Artix!</strong><h2></h2></p><h1>Part IV: Post-Installation — Building Your Microkernel Dev Environment</h1><h2>Phase 1: Essential Setup (Day 1)</h2><h3>Connect to WiFi</h3><pre><code class=\"bash\"># As your user:\nsudo nmcli device wifi connect &quot;YourSSID&quot; password &quot;YourPassword&quot;\n</code></pre><h3>Install Yay (AUR Helper)</h3><pre><code class=\"bash\">cd /tmp\npacman -S git\ngit clone https://aur.archlinux.org/yay.git\ncd yay\nmakepkg -si\n</code></pre><h3>Install Graphics Drivers (AMD)</h3><pre><code class=\"bash\"># Framework 13/16 AMD integrated graphics:\nsudo pacman -S mesa lib32-mesa vulkan-radeon lib32-vulkan-radeon\n\n# If you have Framework 16 with dGPU:\nsudo pacman -S xf86-video-amdgpu\n\n# Verify:\nglxinfo | grep &quot;OpenGL renderer&quot;\n# Should show: AMD Radeon...\n</code></pre><h3>Install Desktop Environment (Optional but Recommended for Beginners)</h3><pre><code class=\"bash\"># For simplicity, use Xfce &#40;lightweight, elegant&#41;:\nsudo pacman -S xfce4 xfce4-goodies lightdm lightdm-runit\n\n# Enable display manager:\nsudo ln -s /etc/runit/sv/lightdm /run/runit/service/\n\n# Reboot to graphical login:\nsudo reboot\n</code></pre><p><strong>You now have a beautiful, minimal Artix Linux desktop!</strong><h2></h2></p><h2>Phase 2: Microkernel Development Tools (Week 1)</h2><h3>Install Rust (for Redox OS)</h3><pre><code class=\"bash\">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\nsource &#126;/.cargo/env\n\n# Verify:\nrustc --version\ncargo --version\n</code></pre><h3>Install seL4 Dependencies</h3><pre><code class=\"bash\"># From Arch Wiki &#40;applies to Artix&#41;:\nsudo pacman -S base-devel cmake ninja python python-pip \\\n  libxml2 dtc qemu-system-aarch64 qemu-system-arm \\\n  qemu-system-x86 gcc-arm-none-eabi\n\n# seL4-specific Python packages:\npip install --user sel4-deps\n</code></pre><h3>Set Up NixOS (in QEMU for SixOS experiments)</h3><pre><code class=\"bash\"># Install QEMU:\nsudo pacman -S qemu-full\n\n# Install Nix package manager &#40;on Artix host&#41;:\nsh &lt;&#40;curl -L https://nixos.org/nix/install&#41; --daemon\n\n# Follow prompts, then:\nsource /etc/profile.d/nix.sh\n\n# Verify:\nnix --version\n</code></pre><h3>Clone Redox OS</h3><pre><code class=\"bash\">mkdir &#126;/dev\ncd &#126;/dev\ngit clone https://gitlab.redox-os.org/redox-os/redox.git --origin upstream --recursive\ncd redox\n\n# Install Redox dependencies:\n./bootstrap.sh -d\n\n# Build minimal Redox &#40;takes 30-60 minutes&#41;:\nmake all\n</code></pre><h2></h2><h2>Phase 3: Daily Workflow — Simple and Beautiful</h2><h3>Terminal Setup</h3><pre><code class=\"bash\"># Install modern terminal:\nsudo pacman -S alacritty\n\n# Configure &#40;&#126;/.config/alacritty/alacritty.yml&#41;:\ncat &gt; &#126;/.config/alacritty/alacritty.yml &lt;&lt; 'EOF'\nfont:\n  normal:\n    family: &quot;JetBrains Mono&quot;\n  size: 11.0\n\ncolors:\n  primary:\n    background: '#002b36'  # Solarized Dark\n    foreground: '#839496'\nEOF\n\n# Install JetBrains Mono font:\nsudo pacman -S ttf-jetbrains-mono\n</code></pre><h3>Editor: Neovim with LSP</h3><pre><code class=\"bash\"># Install Neovim:\nsudo pacman -S neovim\n\n# For Rust development &#40;Redox OS&#41;:\nrustup component add rust-analyzer\n\n# For Nix:\nsudo pacman -S nil  # Nix LSP\n\n# Configure Neovim &#40;minimal&#41;:\nmkdir -p &#126;/.config/nvim\ncat &gt; &#126;/.config/nvim/init.vim &lt;&lt; 'EOF'\n&quot; Simple, beautiful Neovim config\nset number          &quot; Line numbers\nset tabstop=4       &quot; Tabs = 4 spaces\nset shiftwidth=4\nset expandtab       &quot; Spaces not tabs\nsyntax on           &quot; Syntax highlighting\ncolorscheme desert\nEOF\n</code></pre><h3>runit Service Exploration (Learning from 9998 Phase 2)</h3><pre><code class=\"bash\"># List running services:\nsudo sv status /run/runit/service/&#42;\n\n# Examine a service &#40;NetworkManager&#41;:\nls -la /etc/runit/sv/networkmanager/\ncat /etc/runit/sv/networkmanager/run\n\n# Create your own service &#40;example: hello world daemon&#41;:\nsudo mkdir /etc/runit/sv/hello-daemon\nsudo vim /etc/runit/sv/hello-daemon/run\n\n# Content:\n#!/bin/sh\nexec 2&gt;&amp;1\nwhile true; do\n  echo &quot;Hello from runit service&quot;\n  sleep 60\ndone\n\n# Make executable:\nsudo chmod +x /etc/runit/sv/hello-daemon/run\n\n# Enable:\nsudo ln -s /etc/runit/sv/hello-daemon /run/runit/service/\n\n# Check status:\nsudo sv status hello-daemon\n\n# View logs:\nsudo svlogtail hello-daemon\n</code></pre><p><strong>This is hands-on learning of runit (9998 Phase 2) on real hardware!</strong><h2></h2></p><h1>Part V: Connecting Back to 9998 — The Learning Journey</h1><h2>Week 1-2: Foundations on Framework</h2><pre><code class=\"clojure\">{:applying-phase-0\n &quot;Your Artix Framework laptop IS the foundation lab.\n  \n  Tasks:\n  - Boot and observe runit stages &#40;Stage 1 → 2 → 3&#41;\n  - Read /etc/runit/1, /etc/runit/2, /etc/runit/3 scripts\n  - Create 3 custom services, test restarts\n  - Compare to systemd &#40;install VM with Ubuntu, contrast&#41;&quot;}\n</code></pre><h2>Week 3-4: SixOS Exploration</h2><pre><code class=\"clojure\">{:applying-phase-1\n &quot;Use Nix &#40;installed on Artix&#41; to experiment with infuse.nix.\n  \n  Tasks:\n  - Install infuse.nix: nix-env -i -f https://github.com/...\n  - Practice examples from 9998 &#40;nginx override, list pipelining&#41;\n  - Boot SixOS in QEMU on Framework\n  - Map s6-rc concepts to runit knowledge&quot;}\n</code></pre><h2>Week 5-6: Rust Supervisor Development</h2><pre><code class=\"clojure\">{:applying-phase-3\n &quot;Build the Rust supervisor from 9998 Phase 3, run on Framework.\n  \n  Tasks:\n  - Code the supervisor &#40;services.toml config&#41;\n  - Test with real services &#40;postgres, nginx&#41;\n  - Integrate with runit as fallback\n  - Document learnings&quot;}\n</code></pre><h2>Week 7-8: Redox OS on Framework</h2><pre><code class=\"clojure\">{:applying-phase-4\n &quot;Your Redox build runs natively on Framework hardware!\n  \n  Tasks:\n  - Boot Redox on Framework &#40;make live&#41;\n  - Test scheme system &#40;file:, tcp:, display:&#41;\n  - Write simple Redox driver\n  - Compare microkernel boot to Artix/runit boot&quot;}\n</code></pre><h2></h2><h1>Part VI: Troubleshooting — Framework-Specific</h1><h2>Common Issues and Fixes</h2><h3>Framework 13 WiFi Not Working</h3><pre><code class=\"bash\"># MediaTek driver might need firmware:\nsudo pacman -S linux-firmware\n\n# If still broken, check rfkill:\nrfkill list\nsudo rfkill unblock all\n</code></pre><h3>Framework 16 dGPU Not Detected</h3><pre><code class=\"bash\"># Ensure amdgpu module loaded:\nlsmod | grep amdgpu\n\n# If not, add to /etc/modules-load.d/amdgpu.conf:\necho &quot;amdgpu&quot; | sudo tee /etc/modules-load.d/amdgpu.conf\n\n# Rebuild initramfs:\nsudo mkinitcpio -P\nsudo reboot\n</code></pre><h3>Suspend/Resume Issues</h3><pre><code class=\"bash\"># Framework-specific power management:\nsudo pacman -S tlp tlp-runit\n\n# Enable:\nsudo ln -s /etc/runit/sv/tlp /run/runit/service/\n</code></pre><h3>Brightness Control</h3><pre><code class=\"bash\"># Add your user to video group:\nsudo usermod -aG video $USER\n\n# Reboot, then brightness keys should work\n</code></pre><h2></h2><h1>Part VII: The Ecological Metaphor — Your Framework as a Garden Bed</h1><p>Helen Atthowe teaches us to view the garden as a living system, not a machine. Your Framework laptop, running Artix with runit, embodies this:</p><pre><code class=\"clojure\">{:framework-as-garden-bed\n {:the-soil\n  &quot;Artix Linux = rich, living soil\n   - runit microorganisms = service supervision\n   - Pacman nutrients = software packages\n   - Open firmware = healthy biome&quot;\n  \n  :the-plants\n  &quot;Your development projects:\n   - seL4 = alpine flowers &#40;delicate, verified&#41;\n   - Redox OS = nitrogen-fixing legumes &#40;Rust safety&#41;\n   - infuse.nix = companion herbs &#40;enhance other plants&#41;&quot;\n  \n  :minimal-intervention\n  &quot;No-till approach:\n   - Don't install unnecessary packages &#40;tilling&#41;\n   - Use runit supervision &#40;let nature self-correct&#41;\n   - Observe before acting &#40;read logs first&#41;&quot;\n  \n  :polyculture\n  &quot;Multiple projects coexist:\n   - Rust for Redox\n   - C for seL4\n   - Nix for SixOS\n   - All in harmony on Framework soil&quot;}\n</code></pre><h2></h2><h1>Conclusion: Simple, Beautiful, Yours</h1><p>Your Framework laptop running Artix Linux with runit is not just a development machine—it's a <strong>learning environment that teaches you every day</strong>.</p><ul><li><strong>Boot</strong>: Watch runit's three stages → understand init systems</li><li><strong>Install software</strong>: Use pacman → understand package management</li><li><strong>Write services</strong>: Create runit service dirs → understand supervision</li><li><strong>Build Redox</strong>: Compile Rust kernel → understand microkernels</li><li><strong>Repair hardware</strong>: Swap Framework modules → understand ownership</li></ul><p>This is the path Rich Hickey describes: <strong>simple, not easy</strong>. It requires understanding, but that understanding is <strong>liberating</strong>.</p><p>This is the path Helen Atthowe walks: <strong>observe, intervene minimally, let the system thrive</strong>.</p><p>Your Framework laptop is the spade. Artix Linux is the soil. The 9998 learning path is the seed catalog. Now go cultivate your garden.<h2></h2></p><p><strong>Next Writing:</strong> <a href='9996-nixos-dev-containers-vms'>9996-nixos-dev-containers-vms.md</a> — NixOS Development Environments: VMs, Containers, and Build Management<br /> <strong>Previous Writing:</strong> <a href='9998-learning-path-init-systems'>9998-learning-path-init-systems.md</a> — A Comprehensive Learning Path for Modern Init Systems<h2></h2></p><p><em>\"The superior person cultivates the root; when the root is established, the Way grows.\"</em><br /> — Confucius, Analects 1.2</p><p><em>Your Framework laptop is the root. The 9998 learning path is the Way.</em><h2></h2></p><p><div style=\"text-align: center; opacity: 0.6; font-size: 0.85em; margin-top: 3em; padding-top: 1em; border-top: 1px solid rgba(139, 116, 94, 0.2);\"></p><p><strong>Copyright © 2025 <a href='https://codeberg.org/kae3g/12025-10/'>kae3g</a></strong> | Dual-licensed under <a href='https://www.apache.org/licenses/LICENSE-2.0'>Apache-2.0</a> / <a href='https://opensource.org/licenses/MIT'>MIT</a><br /> Competitive technology in service of clarity and beauty</p><p></div></p><p><em><a href='/12025-10/hidden-docs-index.html'>View Hidden Docs Index</a></em> | <em><a href='/12025-10/'>Return to Main Index</a></em></p>",
  "hash" : "2025-10-22T10:21:16.81052703Z-42312"
}