{
  "slug" : "9593-networking-basics-sockets-protocols",
  "meta" : {
    "slug" : "9593-networking-basics-sockets-protocols",
    "title" : "kae3g 9592: Networking Basics - Sockets and Protocols",
    "filename" : "9593-networking-basics-sockets-protocols.md",
    "source-dir" : "hidden"
  },
  "html" : "<h1>kae3g 9592: Networking Basics - Sockets and Protocols</h1><p><strong>Phase 1: Foundations & Philosophy</strong> | <strong>Week 4</strong> | <strong>Reading Time: 17 minutes</strong><h2></h2></p><h2>What You'll Learn</h2><ul><li>How processes communicate across machines</li><li>TCP/IP: The protocol stack that powers the internet</li><li>Sockets: Programming interface for networking</li><li>Client-server model vs peer-to-peer</li><li>IP addresses, ports, and the routing system</li><li>DNS: How names become numbers</li><li>The OSI model (and why TCP/IP simplified it)</li><li>Networking as rivers connecting gardens (plant lens)<h2></h2></li></ul><h2>Prerequisites</h2><ul><li><strong><a href='/12025-10/9501-what-is-compute'>9501: What Is Compute?</a></strong> - Distributed computing, P2P</li><li><strong><a href='/12025-10/9570-processes-programs-in-motion'>9570: Processes</a></strong> - What communicates</li><li><strong><a href='/12025-10/9590-filesystem-hierarchical-organization'>9590: Filesystem</a></strong> - Local organization (networking extends globally)<h2></h2></li></ul><h2>Networks: Rivers Between Gardens</h2><p><strong>Filesystem</strong> (Essay 9590): Organize data <strong>within</strong> one machine.</p><p><strong>Networking</strong>: Connect <strong>across</strong> machines.</p><p><strong>Plant lens</strong>: <strong>\"Networks are irrigation channels—water (data) flows between gardens (computers), nourishing the entire valley (internet).\"</strong></p><p><strong>Key insight</strong>: The internet is just <strong>processes on different machines talking to each other</strong>.<h2></h2></p><h2>The TCP/IP Stack</h2><p><strong>Internet uses layers</strong> (each handles different concern):</p><pre><code>Application Layer &#40;HTTP, SSH, DNS&#41;\n    ↓ &quot;What to send&quot;\nTransport Layer &#40;TCP, UDP&#41;\n    ↓ &quot;How to send reliably&quot;\nInternet Layer &#40;IP&#41;\n    ↓ &quot;Where to send&quot;\nLink Layer &#40;Ethernet, WiFi&#41;\n    ↓ &quot;Physical transmission&quot;\n</code></pre><p><strong>Each layer</strong> talks to its peer on the other machine:</p><pre><code>Your Computer                  Remote Computer\n    App &#40;HTTP&#41;  ←→ HTTP ←→        App &#40;HTTP&#41;\n    TCP         ←→ TCP  ←→        TCP\n    IP          ←→ IP   ←→        IP\n    Ethernet    ←→ ...  ←→        Ethernet\n</code></pre><p><strong>This is composition</strong> (Essay 9510 - Unix philosophy). Each layer does one thing well.<h2></h2></p><h2>IP Addresses: Finding Machines</h2><p><strong>Every machine</strong> on the internet has an IP address:</p><p><strong>IPv4</strong> (old, but still dominant):</p><pre><code>192.168.1.100  &#40;4 numbers, 0-255 each&#41;\n\nPrivate ranges &#40;not routable on internet&#41;:\n10.0.0.0 - 10.255.255.255\n172.16.0.0 - 172.31.255.255\n192.168.0.0 - 192.168.255.255\n\nPublic: Everything else &#40;globally unique&#41;\n</code></pre><p><strong>IPv6</strong> (new, larger address space):</p><pre><code>2001:0db8:85a3:0000:0000:8a2e:0370:7334\n\nAbbreviated: 2001:db8:85a3::8a2e:370:7334\n</code></pre><p><strong>Why IPv6?</strong> IPv4 has ~4 billion addresses (running out!). IPv6 has 340 undecillion (enough for every grain of sand on Earth).</p><p><strong>Check your IP</strong>:<pre><code class=\"bash\"># Local network IP\nip addr show  # Linux\nifconfig      # macOS\n\n# Public IP\ncurl ifconfig.me\n</code></pre></p><h2></h2><h2>Ports: Finding Processes</h2><p><strong>IP address</strong> finds the machine. <strong>Port</strong> finds the process.</p><p><strong>Port numbers</strong>:</p><pre><code>0-1023:    Well-known &#40;HTTP=80, HTTPS=443, SSH=22&#41;\n1024-49151: Registered &#40;apps can request&#41;\n49152-65535: Dynamic &#40;OS assigns temporarily&#41;\n</code></pre><p><strong>Example</strong>:</p><pre><code>http://example.com:80/\n│                  └─ Port 80 &#40;HTTP&#41;\n└─ Domain name &#40;becomes IP via DNS&#41;\n\nssh user@192.168.1.100:22\n         │              └─ Port 22 &#40;SSH&#41;\n         └─ IP address\n</code></pre><p><strong>One machine</strong> can run multiple services (different ports):</p><pre><code>Server:\n  - Web server: port 80 &#40;HTTP&#41;\n  - SSH daemon: port 22 &#40;SSH&#41;\n  - Database: port 5432 &#40;PostgreSQL&#41;\n  - API server: port 3000 &#40;custom&#41;\n</code></pre><p><strong>Plant lens</strong>: <strong>\"IP address is the garden's location, port is the specific plot within that garden.\"</strong><h2></h2></p><h2>DNS: Names to Numbers</h2><p><strong>Humans prefer names</strong> (<code>google.com</code>) over numbers (<code>142.250.185.46</code>).</p><p><strong>DNS</strong> (Domain Name System) translates:</p><pre><code class=\"bash\"># Query DNS\nnslookup google.com\n\n# Output:\n# Server: 8.8.8.8\n# Address: 8.8.8.8#53\n# \n# Name: google.com\n# Address: 142.250.185.46\n</code></pre><p><strong>How it works</strong>:</p><pre><code>1. You type &quot;google.com&quot; in browser\n2. Browser asks DNS server: &quot;What's the IP for google.com?&quot;\n3. DNS server responds: &quot;142.250.185.46&quot;\n4. Browser connects to that IP\n</code></pre><p><strong>DNS hierarchy</strong>:</p><pre><code>.                  &#40;root&#41;\n├── .com           &#40;top-level domain&#41;\n│   └── google.com &#40;second-level&#41;\n│       └── www.google.com &#40;subdomain&#41;\n└── .org\n    └── wikipedia.org\n</code></pre><p><strong>Like filesystem</strong> (Essay 9590), but for domain names!<h2></h2></p><h2>TCP vs UDP</h2><h3>TCP (Transmission Control Protocol)</h3><p><strong>Reliable</strong>:</p><ul><li>Guarantees delivery (packets arrive, in order)</li><li>Retransmits lost packets</li><li>Flow control (doesn't overwhelm receiver)</li></ul><p><strong>Use cases</strong>:</p><ul><li>Web (HTTP/HTTPS)</li><li>SSH (remote shell)</li><li>Email (SMTP, IMAP)</li><li>File transfer (FTP)</li></ul><p><strong>Cost</strong>: Overhead (connection setup, acknowledgments).</p><h3>UDP (User Datagram Protocol)</h3><p><strong>Unreliable</strong> (but fast):</p><ul><li>Best-effort delivery (packets might be lost, out-of-order)</li><li>No retransmission</li><li>No flow control</li></ul><p><strong>Use cases</strong>:</p><ul><li>DNS queries (small, fast, can retry)</li><li>Video streaming (losing a frame is OK, latency matters)</li><li>Gaming (real-time, stale data is useless)</li><li>VoIP (voice calls - latency > reliability)</li></ul><p><strong>Benefit</strong>: Lower latency (no connection overhead).</p><p><strong>Trade-off</strong>: Reliability vs speed.<h2></h2></p><h2>Sockets: Programming Interface</h2><p><strong>A socket</strong> is an endpoint for communication:</p><pre><code class=\"python\"># Server &#40;listens&#41;\nimport socket\n\nserver = socket.socket&#40;socket.AF&#95;INET, socket.SOCK&#95;STREAM&#41;\nserver.bind&#40;&#40;'0.0.0.0', 8080&#41;&#41;  # Listen on port 8080\nserver.listen&#40;&#41;\n\nwhile True:\n    client, addr = server.accept&#40;&#41;  # Wait for connection\n    client.send&#40;b&quot;Hello, client!&quot;&#41;\n    client.close&#40;&#41;\n</code></pre><pre><code class=\"python\"># Client &#40;connects&#41;\nimport socket\n\nclient = socket.socket&#40;socket.AF&#95;INET, socket.SOCK&#95;STREAM&#41;\nclient.connect&#40;&#40;'localhost', 8080&#41;&#41;  # Connect to server\ndata = client.recv&#40;1024&#41;\nprint&#40;data&#41;  # Output: b&quot;Hello, client!&quot;\nclient.close&#40;&#41;\n</code></pre><p><strong>This is how</strong> all internet communication happens (web servers, SSH, databases, etc.).<h2></h2></p><h2>Client-Server vs Peer-to-Peer</h2><h3>Client-Server</h3><p><strong>One server</strong>, many clients:</p><pre><code>Server &#40;always running&#41;\n    ↑\n    ├── Client 1 &#40;connects when needed&#41;\n    ├── Client 2\n    └── Client 3\n</code></pre><p><strong>Examples</strong>: Web (browser → server), email, databases.</p><p><strong>Pros</strong>: Centralized, easy to manage<br /> <strong>Cons</strong>: Single point of failure, server must scale</p><h3>Peer-to-Peer (P2P)</h3><p><strong>All nodes equal</strong> (each is both client and server):</p><pre><code>Peer 1 ←→ Peer 2\n  ↕         ↕\nPeer 3 ←→ Peer 4\n</code></pre><p><strong>Examples</strong>: BitTorrent, IPFS, Urbit (Essay 9503 - Nock), Bitcoin.</p><p><strong>Pros</strong>: Decentralized, resilient, scales naturally<br /> <strong>Cons</strong>: Complex (discovery, NAT traversal)</p><p><strong>Sovereignty perspective</strong> (from 9503, 9960): P2P = no central authority (digital sovereignty!).<h2></h2></p><h2>The OSI Model (Historical)</h2><p><strong>OSI</strong> (Open Systems Interconnection) defined <strong>7 layers</strong>:</p><pre><code>7. Application  &#40;HTTP, FTP, SSH&#41;\n6. Presentation &#40;SSL, compression&#41;\n5. Session      &#40;connections, dialogs&#41;\n4. Transport    &#40;TCP, UDP&#41;\n3. Network      &#40;IP, routing&#41;\n2. Data Link    &#40;Ethernet, WiFi&#41;\n1. Physical     &#40;cables, radio waves&#41;\n</code></pre><p><strong>TCP/IP simplified</strong> to 4 layers:</p><pre><code>Application &#40;combines OSI 5-7&#41;\nTransport   &#40;OSI 4&#41;\nInternet    &#40;OSI 3&#41;\nLink        &#40;combines OSI 1-2&#41;\n</code></pre><p><strong>Why simplify?</strong> OSI was <strong>designed</strong> (committee, spec-first). TCP/IP was <strong>evolved</strong> (implemented, working code first).</p><p><strong>Result</strong>: TCP/IP won (simpler, proven in practice).</p><p><strong>Plant lens</strong>: <strong>\"OSI = ornamental garden (beautiful design). TCP/IP = working farm (produces food).\"</strong><h2></h2></p><h2>Practical Networking</h2><h3>Check Connections</h3><pre><code class=\"bash\"># Active connections\nnetstat -an  # All connections, numeric\n\n# Or &#40;modern&#41;:\nss -tuln  # TCP, UDP, listening, numeric\n\n# Who's connected?\nnetstat -tn  # TCP, no DNS lookup\n</code></pre><h3>Test Connectivity</h3><pre><code class=\"bash\"># Ping &#40;ICMP echo&#41;\nping google.com\n# See if host is reachable\n\n# Trace route\ntraceroute google.com\n# See path packets take\n\n# DNS lookup\nnslookup google.com\n# Or:\ndig google.com\n</code></pre><h3>Listen on Port</h3><pre><code class=\"bash\"># Simple HTTP server &#40;Python&#41;\npython3 -m http.server 8000\n# Serves current directory on http://localhost:8000\n\n# Test with curl\ncurl http://localhost:8000\n</code></pre><h2></h2><h2>Try This</h2><h3>Exercise 1: Explore Network Stack</h3><pre><code class=\"bash\"># What's listening?\nsudo lsof -i -P -n | grep LISTEN\n\n# Example output:\n# sshd   1000 root   3u  IPv4  TCP &#42;:22 &#40;LISTEN&#41;\n# nginx  2000 www    6u  IPv4  TCP &#42;:80 &#40;LISTEN&#41;\n</code></pre><p><strong>Observe</strong>: Process, port, protocol.<h2></h2></p><h3>Exercise 2: HTTP from Scratch</h3><pre><code class=\"bash\"># Connect to web server manually\ntelnet example.com 80\n\n# Type &#40;then press Enter twice&#41;:\nGET / HTTP/1.1\nHost: example.com\n\n# Server responds with HTML!\n# &#40;HTTP is just text over TCP&#41;\n</code></pre><p><strong>Insight</strong>: \"High-level\" protocols (HTTP) are just text (Essay 9560!).<h2></h2></p><h3>Exercise 3: DNS Investigation</h3><pre><code class=\"bash\"># DNS lookup\ndig google.com\n\n# Output shows:\n# - Query &#40;what you asked&#41;\n# - Answer &#40;IP address&#41;\n# - Authority &#40;which DNS server answered&#41;\n# - TTL &#40;how long to cache&#41;\n\n# Reverse lookup &#40;IP → name&#41;\ndig -x 8.8.8.8\n# Answer: dns.google.\n</code></pre><h2></h2><h2>Going Deeper</h2><h3>Related Essays</h3><ul><li><strong><a href='/12025-10/9501-what-is-compute'>9501: What Is Compute?</a></strong> - Distributed computing context</li><li><strong><a href='/12025-10/9570-processes-programs-in-motion'>9570: Processes</a></strong> - What runs networking code</li><li><strong><a href='/12025-10/9503-what-is-nock'>9503: What Is Nock?</a></strong> - Urbit (P2P networking)</li><li><strong><a href='/12025-10/9960-grainhouse-risc-v-synthesis'>9960: The Grainhouse</a></strong> - Sovereignty (P2P vs centralized)</li></ul><h3>External Resources</h3><ul><li><strong>\"TCP/IP Illustrated\"</strong> - Classic networking book</li><li><strong>Beej's Guide to Network Programming</strong> - Sockets tutorial</li><li><strong><code>man socket</code></strong> - Socket API documentation</li><li><strong>Wireshark</strong> - Packet analysis tool (see actual network traffic)<h2></h2></li></ul><h2>Reflection Questions</h2><ol><li><strong>Why TCP for web, UDP for video?</strong> (Reliability vs latency trade-off)</li><li><strong>Is DNS a single point of failure?</strong> (Centralized naming - what if it goes down?)</li><li><strong>Why did P2P lose to client-server?</strong> (BitTorrent, Napster shut down - but why?)</li><li><strong>Can networking be more secure by default?</strong> (Current internet: trust all traffic - bad assumption)</li><li><strong>What would Nock-based networking look like?</strong> (All messages as nouns, provably correct protocols?)<h2></h2></li></ol><h2>Summary</h2><p><strong>Networking Fundamentals</strong>:</p><p><strong>TCP/IP Stack</strong>:</p><ul><li><strong>Application</strong>: HTTP, SSH, DNS (what to send)</li><li><strong>Transport</strong>: TCP, UDP (how to send)</li><li><strong>Internet</strong>: IP (where to send)</li><li><strong>Link</strong>: Ethernet, WiFi (physical transmission)</li></ul><p><strong>Key Concepts</strong>:</p><ul><li><strong>IP address</strong>: Machine location (192.168.1.100, IPv6)</li><li><strong>Port</strong>: Process identifier (80=HTTP, 22=SSH, 443=HTTPS)</li><li><strong>DNS</strong>: Names → numbers (google.com → 142.250.185.46)</li><li><strong>Socket</strong>: Programming interface (bind, listen, connect, send, recv)</li></ul><p><strong>Protocols</strong>:</p><ul><li><strong>TCP</strong>: Reliable (guarantees delivery, order)</li><li><strong>UDP</strong>: Fast (best-effort, lower latency)</li></ul><p><strong>Architectures</strong>:</p><ul><li><strong>Client-Server</strong>: Centralized (web, email, databases)</li><li><strong>Peer-to-Peer</strong>: Decentralized (BitTorrent, IPFS, Urbit)</li></ul><p><strong>Key Insights</strong>:</p><ul><li><strong>Layering enables composition</strong> (each layer = one concern)</li><li><strong>TCP/IP beat OSI</strong> (evolved > designed, simpler > more complete)</li><li><strong>Everything is text</strong> (HTTP, DNS, SMTP - all text protocols!)</li><li><strong>P2P = sovereignty</strong> (no central authority, resilient)</li></ul><p><strong>In the Valley</strong>:</p><ul><li><strong>We respect layering</strong> (compose protocols, don't monolith)</li><li><strong>We prefer P2P</strong> when possible (sovereignty over convenience)</li><li><strong>We use text protocols</strong> (HTTP, not binary blobs - easier to debug)</li><li><strong>We understand trade-offs</strong> (TCP reliability vs UDP speed)</li></ul><p><strong>Plant lens</strong>: <strong>\"Networks are irrigation channels—data flows like water between gardens (machines), nourishing the entire valley (internet ecosystem).\"</strong><h2></h2></p><p><strong>Next</strong>: We'll explore <strong>concurrency</strong>—how to do multiple things simultaneously, threads vs processes, and the coordination challenges that arise!<h2></h2></p><p><strong>Navigation</strong>:<br /> ← Previous: <a href='/12025-10/9592-permissions-who-can-do-what'>9592 (permissions who can do what)</a> | <strong>Phase 1 Index</strong> | Next: <a href='/12025-10/9594-concurrency-threads-parallelism'>9594 (concurrency threads parallelism)</a></p><p><strong>Metadata</strong>:</p><ul><li><strong>Phase</strong>: 1 (Foundations)</li><li><strong>Week</strong>: 4</li><li><strong>Prerequisites</strong>: 9501, 9570, 9590</li><li><strong>Concepts</strong>: TCP/IP, sockets, DNS, protocols, client-server, P2P, IP addresses, ports</li><li><strong>Next Concepts</strong>: Concurrency, threads, parallelism, synchronization</li><li><strong>Plant Lens</strong>: Networks = irrigation channels, data = water flow, internet = valley ecosystem</li></ul><h2></h2><p><div style=\"text-align: center; opacity: 0.6; font-size: 0.85em; margin-top: 3em; padding-top: 1em; border-top: 1px solid rgba(139, 116, 94, 0.2);\"></p><p><strong>Copyright © 2025 <a href='https://codeberg.org/kae3g/12025-10/'>kae3g</a></strong> | Dual-licensed under <a href='https://www.apache.org/licenses/LICENSE-2.0'>Apache-2.0</a> / <a href='https://opensource.org/licenses/MIT'>MIT</a><br /> Competitive technology in service of clarity and beauty</p><p></div></p><p><em><a href='/12025-10/hidden-docs-index.html'>View Hidden Docs Index</a></em> | <em><a href='/12025-10/'>Return to Main Index</a></em></p>",
  "hash" : "2025-10-22T10:21:16.802527339Z-12802"
}