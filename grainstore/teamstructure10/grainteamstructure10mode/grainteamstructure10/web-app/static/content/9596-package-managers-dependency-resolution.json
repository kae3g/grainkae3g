{
  "slug" : "9596-package-managers-dependency-resolution",
  "meta" : {
    "slug" : "9596-package-managers-dependency-resolution",
    "title" : "kae3g 9595: Package Managers - Dependency Resolution",
    "filename" : "9596-package-managers-dependency-resolution.md",
    "source-dir" : "hidden"
  },
  "html" : "<h1>kae3g 9595: Package Managers - Dependency Resolution</h1><p><strong>Phase 1: Foundations & Philosophy</strong> | <strong>Week 4</strong> | <strong>Reading Time: 19 minutes</strong><h2></h2></p><h2>What You'll Learn</h2><ul><li>What package managers do (and why they exist)</li><li>Dependency hell and how it happens</li><li>Semantic versioning (semver: 1.2.3)</li><li>Different approaches: apt, npm, cargo, Nix</li><li>Why Nix solves problems others can't</li><li>The /nix/store: Content-addressed packages</li><li>Reproducible environments</li><li>Grainhouse strategy through package management<h2></h2></li></ul><h2>Prerequisites</h2><ul><li><strong><a href='/12025-10/9594-build-systems-source-to-binary'>9594: Build Systems</a></strong> - How software is built</li><li><strong><a href='/12025-10/9590-filesystem-hierarchical-organization'>9590: Filesystem</a></strong> - Where packages install</li><li><strong><a href='/12025-10/9504-what-is-clojure'>9504: What Is Clojure?</a></strong> - Mentions Nix</li><li><strong><a href='/12025-10/9949-intro-clojure-nix-ecosystem'>9949: The Wise Elders</a></strong> - Nix as Meticulous Architect<h2></h2></li></ul><h2>The Dependency Problem</h2><p><strong>Modern software</strong> depends on hundreds of libraries:</p><pre><code>Your App\n├── web-framework &#40;needs http-library, templating&#41;\n│   ├── http-library &#40;needs sockets, crypto&#41;\n│   │   └── crypto &#40;needs random, math&#41;\n│   └── templating &#40;needs parser&#41;\n└── database-driver &#40;needs connection-pool&#41;\n    └── connection-pool &#40;needs threading&#41;\n</code></pre><p><strong>Managing this manually</strong> = nightmare.</p><p><strong>Package managers</strong> automate:</p><ol><li><strong>Install</strong> dependencies</li><li><strong>Resolve</strong> version conflicts</li><li><strong>Update</strong> packages</li><li><strong>Remove</strong> packages (and unused deps)</li></ol><p><strong>Plant lens</strong>: <strong>\"Package managers are seed catalogs—track which seeds (packages) you need, where to get them, which varieties (versions) work together.\"</strong><h2></h2></p><h2>Dependency Hell</h2><p><strong>The problem</strong>:</p><pre><code>Your App needs:\n  Library A v2.0\n  Library B v3.0\n\nBut:\n  Library B v3.0 needs Library A v1.5\n  &#40;Conflict! You need A v2.0, but B needs A v1.5&#41;\n</code></pre><p><strong>Result</strong>: <strong>Can't install both!</strong></p><p><strong>Variations</strong>:</p><ul><li><strong>Diamond dependency</strong>: A→C, B→C (which version of C?)</li><li><strong>Circular dependency</strong>: A→B, B→A (infinite loop!)</li><li><strong>Version lock</strong>: Upgrading A breaks B</li></ul><p><strong>This is dependency hell.</strong><h2></h2></p><h2>Semantic Versioning (Semver)</h2><p><strong>Convention</strong>: <code>MAJOR.MINOR.PATCH</code></p><pre><code>Example: 2.4.7\n         │ │ │\n         │ │ └─ Patch &#40;bug fixes, no breaking changes&#41;\n         │ └─── Minor &#40;new features, backward compatible&#41;\n         └───── Major &#40;breaking changes!&#41;\n</code></pre><p><strong>Rules</strong>:</p><ul><li>Patch (2.4.7 → 2.4.8): Safe to upgrade (just fixes)</li><li>Minor (2.4.7 → 2.5.0): Safe to upgrade (new features, compatible)</li><li>Major (2.4.7 → 3.0.0): <strong>Might break!</strong> (review changes)</li></ul><p><strong>Example</strong>:</p><pre><code>Your app requires: react@&#94;16.8.0\n                        └─── &quot;&#94;&quot; means: ≥16.8.0, &lt;17.0.0\n                             &#40;Minor/patch OK, major NO&#41;\n</code></pre><p><strong>This helps</strong>, but doesn't solve everything (minor versions can still break things!).<h2></h2></p><h2>Traditional Package Managers</h2><h3>apt (Debian, Ubuntu)</h3><pre><code class=\"bash\"># Install\nsudo apt install nginx\n\n# Update package list\nsudo apt update\n\n# Upgrade packages\nsudo apt upgrade\n\n# Remove\nsudo apt remove nginx\n</code></pre><p><strong>Model</strong>: System-wide installation (<code>/usr/bin/</code>, <code>/usr/lib/</code>)</p><p><strong>Problem</strong>: One version per package (can't have nginx 1.18 AND 1.20).</p><h3>npm (Node.js)</h3><pre><code class=\"bash\"># Install &#40;project-local&#41;\nnpm install express\n\n# Creates node&#95;modules/ directory\n# Can have DIFFERENT versions per project!\n</code></pre><p><strong>Model</strong>: Per-project installation (<code>node&#95;modules/</code>)</p><p><strong>Problem</strong>: Duplication (every project downloads same packages), disk space explosion.</p><h3>cargo (Rust)</h3><pre><code class=\"bash\"># Install library &#40;adds to Cargo.toml&#41;\ncargo add serde\n\n# Build &#40;downloads deps&#41;\ncargo build\n</code></pre><p><strong>Model</strong>: Per-project (like npm), but smarter caching (<code>&#126;/.cargo/</code>).</p><p><strong>Better</strong>, but still has version conflicts.<h2></h2></p><h2>Nix: The Radically Different Approach</h2><p><strong>Nix</strong> doesn't install packages <strong>into</strong> the system. It installs them <strong>beside</strong> it.</p><h3>The /nix/store</h3><p><strong>Every package</strong> gets a unique path:</p><pre><code>/nix/store/abc123-nodejs-18.0.0/\n/nix/store/def456-nodejs-20.0.0/\n/nix/store/ghi789-nginx-1.18.0/\n/nix/store/jkl012-nginx-1.20.0/\n</code></pre><p><strong>Hash</strong> (<code>abc123</code>) is based on:</p><ul><li>Package name + version</li><li>All dependencies (recursively!)</li><li>Build script</li><li>Compiler used</li></ul><p><strong>Result</strong>: Identical inputs → identical hash → <strong>same package</strong>.</p><h3>Multiple Versions Coexist</h3><pre><code class=\"bash\"># Project A uses nodejs 18\nnix-shell -p nodejs-18&#95;x\n\n# Project B uses nodejs 20\nnix-shell -p nodejs-20&#95;x\n\n# No conflict! Different paths in /nix/store\n</code></pre><p><strong>This is impossible</strong> with apt (system-wide = one version only).</p><h3>Atomic Upgrades</h3><p><strong>Traditional</strong>:<pre><code class=\"bash\">apt upgrade\n# &#40;Downloads, starts replacing files...&#41;\n# Power loss? BROKEN SYSTEM!\n</code></pre></p><p><strong>Nix</strong>:<pre><code class=\"bash\">nix-env -u\n# Builds new profile &#40;doesn't touch old!&#41;\n# Switch atomically\n# If power loss: old system still works!\n</code></pre></p><p><strong>Rollback</strong>:<pre><code class=\"bash\">nix-env --rollback\n# Instantly back to previous state!\n</code></pre></p><h2></h2><h2>Reproducible Environments</h2><p><strong>Traditional problem</strong>:</p><pre><code>Developer machine: Python 3.9, numpy 1.20, works fine\nCI server:         Python 3.10, numpy 1.22, fails!\n</code></pre><p><strong>Nix solution</strong>:</p><pre><code class=\"nix\"># shell.nix\n{ pkgs ? import &lt;nixpkgs&gt; {} }:\n\npkgs.mkShell {\n  buildInputs = &#91;\n    pkgs.python39\n    pkgs.python39Packages.numpy&#95;1&#95;20\n  &#93;;\n}\n</code></pre><p><strong>Everyone runs</strong>:<pre><code class=\"bash\">nix-shell\n# Now: EXACT same Python, EXACT same numpy\n# Developer, CI, production: identical!\n</code></pre></p><p><strong>This is the grainhouse</strong> (Essay 9960) in action: total control, perfect reproducibility.<h2></h2></p><h2>Dependency Resolution Strategies</h2><h3>Pessimistic (apt, yum)</h3><pre><code>Only one version of each package\nIf conflict: fail, ask user to resolve\n</code></pre><p><strong>Simple</strong>, but <strong>inflexible</strong> (can't have two versions).</p><h3>Optimistic (npm, cargo)</h3><pre><code>Try to satisfy all requirements\nIf possible: install &#40;might be multiple versions&#41;\nIf impossible: fail\n</code></pre><p><strong>More flexible</strong>, but <strong>duplicates packages</strong>.</p><h3>Content-Addressed (Nix)</h3><pre><code>Every unique build gets unique path\nHash = content &#40;source + deps + build&#41;\nNo conflicts possible!\n</code></pre><p><strong>Most flexible</strong>, but <strong>requires understanding</strong> (learning curve).<h2></h2></p><h2>The Nix Advantage</h2><p><strong>Why Nix wins for sovereignty</strong>:</p><h3>1. Perfect Reproducibility</h3><pre><code class=\"nix\"># flake.nix &#40;locks ALL dependencies&#41;\n{\n  inputs.nixpkgs.url = &quot;github:NixOS/nixpkgs/nixos-23.11&quot;;\n  # Exact commit hash locked!\n  \n  outputs = { self, nixpkgs }: {\n    # ... your config\n  };\n}\n</code></pre><p><strong>Result</strong>: Same flake → same build (bit-for-bit identical), even years later.</p><h3>2. Isolation</h3><p><strong>No global state</strong>:</p><ul><li><code>/usr/lib/</code> pollution? Nope (everything in <code>/nix/store/</code>)</li><li>Conflicting versions? Nope (different hashes)</li><li>\"Works on my machine\"? Nope (Nix makes it work everywhere)</li></ul><h3>3. Declarative</h3><p><strong>Say WHAT you want</strong> (not HOW to install):</p><pre><code class=\"nix\">environment.systemPackages = &#91;\n  pkgs.vim\n  pkgs.git\n  pkgs.clojure\n&#93;;\n\n# Nix figures out HOW &#40;dependencies, build order, etc.&#41;\n</code></pre><h3>4. Grainhouse-Compatible</h3><p><strong>Fork everything</strong>:<pre><code class=\"nix\"># Your own package set &#40;grainhouse!&#41;\nimport &#40;fetchTarball &quot;https://your-mirror.com/nixpkgs.tar.gz&quot;&#41;\n\n# Now: You control EVERY dependency\n# Upstream goes down? You're fine &#40;you have the seeds!&#41;\n</code></pre></p><p><strong>This is sovereignty</strong> (Essay 9503, 9960).<h2></h2></p><h2>Try This</h2><h3>Exercise 1: Dependency Discovery</h3><pre><code class=\"bash\"># Python\npip show numpy\n# Shows: dependencies, version, location\n\n# Node.js\nnpm ls\n# Shows: entire dependency tree\n\n# Rust\ncargo tree\n# Shows: dependencies &#40;with versions&#41;\n</code></pre><p><strong>Observe</strong>: How deep does the tree go? (Often dozens of transitive dependencies!)<h2></h2></p><h3>Exercise 2: Nix Experiment (if installed)</h3><pre><code class=\"bash\"># Enter environment with specific Python\nnix-shell -p python39\n\n# Check version\npython --version\n# Output: Python 3.9.x\n\n# Exit\nexit\n\n# Enter different Python\nnix-shell -p python310\n\npython --version\n# Output: Python 3.10.x\n\n# No conflict! Both coexist in /nix/store\n</code></pre><h2></h2><h3>Exercise 3: Version Conflict</h3><pre><code class=\"bash\"># Try creating conflict &#40;npm example&#41;\nmkdir conflict-test &amp;&amp; cd conflict-test\nnpm init -y\n\n# Install library A that needs old version\nnpm install old-lib@1.0.0\n\n# Install library B that needs new version\nnpm install new-lib@2.0.0\n\n# Check if both installed\nnpm ls\n# &#40;npm might install multiple versions - check node&#95;modules/&#41;\n</code></pre><p><strong>Observe</strong>: How does npm handle conflicts?<h2></h2></p><h2>Going Deeper</h2><h3>Related Essays</h3><ul><li><strong><a href='/12025-10/9594-build-systems-source-to-binary'>9594: Build Systems</a></strong> - Build pipeline</li><li><strong><a href='/12025-10/9504-what-is-clojure'>9504: What Is Clojure?</a></strong> - Nix + Clojure</li><li><strong><a href='/12025-10/9949-intro-clojure-nix-ecosystem'>9949: The Wise Elders</a></strong> - Nix as Meticulous Architect</li><li><strong><a href='/12025-10/9960-grainhouse-risc-v-synthesis'>9960: The Grainhouse</a></strong> - Nix for sovereignty</li></ul><h3>External Resources</h3><ul><li><strong><a href='https://nixos.org/manual/nix'>Nix Manual</a></strong> - Complete Nix reference</li><li><strong><a href='https://nixos.wiki/'>NixOS Wiki</a></strong> - Community documentation</li><li><strong>npm documentation</strong> - Node package manager</li><li><strong>\"Zero to Nix\"</strong> - Beginner-friendly Nix guide<h2></h2></li></ul><h2>Reflection Questions</h2><ol><li><strong>Why does dependency hell exist?</strong> (Shared mutable state - at the package level!)</li><li><strong>Is Nix's disk usage worth it?</strong> (Multiple versions = disk space, but total control)</li><li><strong>Could all package managers be like Nix?</strong> (Content-addressed, isolated - technically yes, culturally hard)</li><li><strong>What if we never upgraded dependencies?</strong> (Pin forever - secure but miss bug fixes)</li><li><strong>How would Nock specify a package manager?</strong> (Pure functions: package-spec → derivation → build)<h2></h2></li></ol><h2>Summary</h2><p><strong>Package Managers Solve</strong>:</p><ul><li><strong>Dependency installation</strong> (automated downloading)</li><li><strong>Version resolution</strong> (which versions work together)</li><li><strong>Conflict management</strong> (multiple packages need same dependency)</li></ul><p><strong>Common Approaches</strong>:</p><ul><li><strong>apt</strong>: System-wide, one version, simple</li><li><strong>npm</strong>: Per-project, multiple versions, duplicates</li><li><strong>cargo</strong>: Per-project, better caching, still conflicts</li><li><strong>Nix</strong>: Content-addressed, isolated, reproducible</li></ul><p><strong>Dependency Hell</strong>:</p><ul><li><strong>Version conflicts</strong> (A needs X v1, B needs X v2)</li><li><strong>Diamond dependencies</strong> (multiple paths to same library)</li><li><strong>Breaking changes</strong> (major version bump)</li></ul><p><strong>Semantic Versioning</strong>:</p><ul><li><strong>MAJOR.MINOR.PATCH</strong> (2.4.7)</li><li>Major: breaking changes</li><li>Minor: new features (compatible)</li><li>Patch: bug fixes only</li></ul><p><strong>Nix's Radical Solution</strong>:</p><ul><li><strong>Content-addressed</strong>: Hash = inputs (source + deps + build)</li><li><strong>Isolated</strong>: Everything in <code>/nix/store/hash-name/</code></li><li><strong>Multiple versions</strong>: No conflicts (different hashes)</li><li><strong>Atomic</strong>: Upgrades/rollbacks instant</li><li><strong>Reproducible</strong>: Same inputs → same output (always)</li><li><strong>Declarative</strong>: Say what, not how</li></ul><p><strong>Key Insights</strong>:</p><ul><li><strong>Most package managers = mutable state</strong> (shared <code>/usr/</code>, conflicts)</li><li><strong>Nix = immutable</strong> (append-only store, no conflicts)</li><li><strong>Reproducibility requires isolation</strong> (hermetic builds)</li><li><strong>Sovereignty requires control</strong> (Nix + grainhouse = own everything)</li></ul><p><strong>In the Valley</strong>:</p><ul><li><strong>We use Nix</strong> (reproducibility, sovereignty)</li><li><strong>We lock dependencies</strong> (flakes, exact hashes)</li><li><strong>We fork when needed</strong> (grainhouse strategy)</li><li><strong>We never trust, always verify</strong> (reproducible builds)</li></ul><p><strong>Plant lens</strong>: <strong>\"Package managers are seed catalogs—track varieties (versions), source (repositories), and which combinations grow well together (dependency resolution).\"</strong><h2></h2></p><p><strong>Next</strong>: We'll explore <strong>version control</strong> (Git)—how to track changes, collaborate with others, and preserve every version of your work for eternity!<h2></h2></p><p><strong>Navigation</strong>:<br /> ← Previous: <a href='/12025-10/9595-build-systems-source-to-binary'>9595 (build systems source to binary)</a> | <strong>Phase 1 Index</strong> | Next: <a href='/12025-10/9597-version-control-git-foundations'>9597 (version control git foundations)</a></p><p><strong>Metadata</strong>:</p><ul><li><strong>Phase</strong>: 1 (Foundations)</li><li><strong>Week</strong>: 4</li><li><strong>Prerequisites</strong>: 9594, 9590, 9504</li><li><strong>Concepts</strong>: Package managers, dependency resolution, semver, apt, npm, cargo, Nix, content-addressing, reproducibility</li><li><strong>Next Concepts</strong>: Version control, Git, commits, branches, history</li><li><strong>Plant Lens</strong>: Seed catalogs (package registries), varieties (versions), compatibility (which seeds grow together)</li></ul><h2></h2><p><div style=\"text-align: center; opacity: 0.6; font-size: 0.85em; margin-top: 3em; padding-top: 1em; border-top: 1px solid rgba(139, 116, 94, 0.2);\"></p><p><strong>Copyright © 2025 <a href='https://codeberg.org/kae3g/12025-10/'>kae3g</a></strong> | Dual-licensed under <a href='https://www.apache.org/licenses/LICENSE-2.0'>Apache-2.0</a> / <a href='https://opensource.org/licenses/MIT'>MIT</a><br /> Competitive technology in service of clarity and beauty</p><p></div></p><p><em><a href='/12025-10/hidden-docs-index.html'>View Hidden Docs Index</a></em> | <em><a href='/12025-10/'>Return to Main Index</a></em></p>",
  "hash" : "2025-10-22T10:21:16.802527339Z-12563"
}