{
  "slug" : "9511-kubernetes-cloud-orchestration",
  "meta" : {
    "slug" : "9511-kubernetes-cloud-orchestration",
    "title" : "kae3g 9511: Kubernetes - Container Orchestration at Scale",
    "filename" : "9511-kubernetes-cloud-orchestration.md",
    "source-dir" : "hidden"
  },
  "html" : "<h1>kae3g 9511: Kubernetes - Container Orchestration at Scale</h1><p><strong>Phase 1: Foundations & Philosophy</strong> | <strong>Week 2</strong> | <strong>Reading Time: 12 minutes</strong><h2></h2></p><h2>What You'll Learn</h2><ul><li>What Kubernetes is and why it dominates enterprise</li><li>Container orchestration fundamentals</li><li>Pods, Deployments, Services (core concepts)</li><li>How Kubernetes embodies Unix philosophy (Essay 9510!)</li><li>Running Kubernetes locally (minikube, k3s)</li><li>When to use Kubernetes vs. simpler alternatives</li><li><strong>Fast track to cloud orchestration mastery!</strong><h2></h2></li></ul><h2>Prerequisites</h2><ul><li><strong><a href='/12025-10/9500-what-is-a-computer'>9500: What Is a Computer?</a></strong> - Hardware foundations</li><li><strong><a href='/12025-10/9501-what-is-compute'>9501: What Is Compute?</a></strong> - Cloud, distributed systems</li><li><strong><a href='/12025-10/9510-unix-philosophy-primer'>9510: Unix Philosophy</a></strong> - Composition principles (critical!)<h2></h2></li></ul><h2>What Is Kubernetes?</h2><p><strong>Kubernetes</strong> (k8s) is a <strong>container orchestration platform</strong>.</p><p><strong>What that means</strong>:</p><ul><li>You have <strong>containers</strong> (isolated apps, like Docker - Essay 9570!)</li><li>You have <strong>many machines</strong> (cluster of nodes)</li><li><strong>Kubernetes</strong> decides where containers run, restarts them if they crash, routes traffic between them</li></ul><p><strong>Born at Google</strong> (2014), now <strong>industry standard</strong> for cloud deployments.</p><p><strong>Think of it as</strong>: Unix process management (Essay 9570), but for <strong>distributed systems</strong> at cloud scale!<h2></h2></p><h2>Why Kubernetes Exists</h2><p><strong>The problem</strong>: Modern apps are distributed systems.</p><p><strong>Example web app</strong>:</p><ul><li>10 web servers (HTTP)</li><li>5 API servers (business logic)</li><li>3 database replicas</li><li>2 cache servers (Redis)</li><li>1 message queue (Kafka)</li></ul><p><strong>Without orchestration</strong>:</p><ul><li>Manual SSH to each machine</li><li>Start/stop services by hand</li><li>No automatic recovery</li><li>Scaling = manual work</li></ul><p><strong>With Kubernetes</strong>:</p><ul><li>Declare desired state (YAML)</li><li>Kubernetes makes it happen (automatically)</li><li>Self-healing (crashed pod → new pod)</li><li>Auto-scaling (traffic → more pods)</li><li>Load balancing (built-in)<h2></h2></li></ul><h2>Core Concepts</h2><h3>1. Pods (Smallest Unit)</h3><pre><code class=\"yaml\">apiVersion: v1\nkind: Pod\nmetadata:\n  name: my-app\nspec:\n  containers:\n  - name: web\n    image: nginx:latest\n    ports:\n    - containerPort: 80\n</code></pre><p><strong>Pod</strong> = one or more containers sharing:</p><ul><li>Network (same IP)</li><li>Storage</li><li>Lifecycle (start/stop together)</li></ul><p><strong>Typically</strong>: One container per pod.<h2></h2></p><h3>2. Deployments (Manage Replicas)</h3><pre><code class=\"yaml\">apiVersion: apps/v1\nkind: Deployment\nmetadata:\n  name: web-app\nspec:\n  replicas: 3  # Run 3 copies!\n  selector:\n    matchLabels:\n      app: web\n  template:\n    metadata:\n      labels:\n        app: web\n    spec:\n      containers:\n      - name: nginx\n        image: nginx:1.21\n</code></pre><p><strong>Deployment ensures</strong>:</p><ul><li>3 replicas always running</li><li>Rolling updates (gradual replacement)</li><li>Rollback (if new version breaks)</li></ul><p><strong>This is declarative</strong> (like Nix!): You declare \"I want 3\", Kubernetes ensures 3 exist.<h2></h2></p><h3>3. Services (Stable Networking)</h3><pre><code class=\"yaml\">apiVersion: v1\nkind: Service\nmetadata:\n  name: web-service\nspec:\n  selector:\n    app: web\n  ports:\n  - port: 80\n    targetPort: 80\n  type: LoadBalancer\n</code></pre><p><strong>Problem</strong>: Pods have dynamic IPs (come and go).</p><p><strong>Solution</strong>: Service provides stable endpoint:</p><ul><li>DNS name</li><li>Load balances across replicas</li><li>Survives pod restarts<h2></h2></li></ul><h2>Kubernetes Architecture (Simplified)</h2><pre><code>Control Plane &#40;Brain&#41;\n├── API Server &#40;central interface&#41;\n├── Scheduler &#40;assigns pods to nodes&#41;\n├── Controller Manager &#40;reconciliation&#41;\n└── etcd &#40;state storage&#41;\n        │\n    ────┴────────────────\n    │         │         │\n  Node 1   Node 2   Node 3\n  &#40;Pods&#41;   &#40;Pods&#41;   &#40;Pods&#41;\n</code></pre><p><strong>Control Plane</strong>: Makes decisions<br /> <strong>Nodes</strong>: Run workloads<h2></h2></p><h2>Unix Philosophy in Kubernetes</h2><p><strong>Kubernetes embodies Unix principles</strong> (Essay 9510):</p><h3>1. Do One Thing Well</h3><p><strong>Each component specialized</strong>:</p><ul><li><strong>Scheduler</strong>: Decides placement (one job)</li><li><strong>Controller</strong>: Reconciles state (one job)</li><li><strong>kubelet</strong>: Runs containers (one job)</li><li><strong>Service</strong>: Provides networking (one job)</li></ul><p><strong>Not monolithic</strong>. Each part replaceable.</p><h3>2. Composition</h3><pre><code class=\"yaml\"># Compose simple resources\nPod + Service + Deployment = Complete app\n</code></pre><p><strong>Like Unix pipes</strong>: Simple tools → complex workflows.</p><h3>3. Declarative</h3><p><strong>Unix</strong>:<pre><code class=\"bash\">ls | grep &quot;.txt&quot; | wc -l  # &quot;Count .txt files&quot; &#40;what, not how&#41;\n</code></pre></p><p><strong>Kubernetes</strong>:<pre><code class=\"yaml\">replicas: 3  # &quot;I want 3&quot; &#40;what, not how&#41;\n</code></pre></p><p>Kubernetes figures out <strong>HOW</strong> (like Nix!).<h2></h2></p><h2>Running Kubernetes Locally</h2><h3>Option 1: Minikube</h3><pre><code class=\"bash\"># Install &#40;macOS&#41;\nbrew install minikube\n\n# Start\nminikube start\n\n# Deploy nginx\nkubectl create deployment nginx --image=nginx\nkubectl expose deployment nginx --port=80 --type=NodePort\n\n# Access\nminikube service nginx\n</code></pre><p><strong>Pros</strong>: Full k8s API<br /> <strong>Cons</strong>: Resource-heavy (VM)</p><h3>Option 2: K3s (Lightweight!)</h3><pre><code class=\"bash\"># Install &#40;100MB binary&#41;\ncurl -sfL https://get.k3s.io | sh -\n\n# Use\nexport KUBECONFIG=/etc/rancher/k3s/k3s.yaml\nkubectl get nodes\n\n# Deploy\nkubectl create deployment nginx --image=nginx\n</code></pre><p><strong>Pros</strong>: Fast, lightweight, production-ready<br /> <strong>Cons</strong>: Slightly different from full k8s<h2></h2></p><h2>When to Use Kubernetes</h2><p><strong>Use Kubernetes when</strong>:</p><ul><li><strong>Scale</strong>: 100+ services, 1000+ containers</li><li><strong>Multi-tenancy</strong>: Multiple teams, shared infrastructure</li><li><strong>High availability</strong>: 99.99%+ uptime needed</li><li><strong>Auto-scaling</strong>: Traffic varies dramatically</li><li><strong>Team coordination</strong>: Many developers, CI/CD pipelines</li></ul><p><strong>Examples</strong>:</p><ul><li>SaaS products (Stripe, Shopify)</li><li>E-commerce platforms</li><li>Social media backends</li><li>Enterprise applications</li></ul><p><strong>Don't use Kubernetes when</strong>:</p><ul><li>Small projects (1-3 services)</li><li>Personal apps (overkill!)</li><li>Learning (too complex to start)</li><li>Simple deployments (Docker Compose sufficient)</li></ul><p><strong>Rule of thumb</strong>: Start simple. Add Kubernetes when you outgrow simpler tools.<h2></h2></p><h2>Try This</h2><h3>Exercise: Run K3s Locally</h3><pre><code class=\"bash\"># Install kubectl\nbrew install kubectl\n\n# Deploy app\nkubectl create deployment hello --image=rancher/hello-world\n\n# Expose\nkubectl expose deployment hello --port=80 --type=NodePort\n\n# Get service port\nkubectl get services\n\n# Visit http://localhost:&lt;PORT&gt;\n</code></pre><p><strong>Observe</strong>:</p><ul><li>Declarative deployment</li><li>Automatic pod creation</li><li>Self-healing (kill pod, watch restart!)<h2></h2></li></ul><h2>Summary</h2><p><strong>Kubernetes is</strong>:</p><ul><li><strong>Container orchestration</strong> (manage 1000s of containers)</li><li><strong>Declarative</strong> (YAML configs)</li><li><strong>Self-healing</strong> (automatic recovery)</li><li><strong>Scalable</strong> (auto-scaling, load balancing)</li></ul><p><strong>Core concepts</strong>:</p><ul><li><strong>Pods</strong>: Smallest unit (1+ containers)</li><li><strong>Deployments</strong>: Manage replicas</li><li><strong>Services</strong>: Stable networking</li></ul><p><strong>Unix Philosophy in Kubernetes</strong>:</p><ul><li>Each component does one thing well</li><li>Compose resources (like pipes)</li><li>Declarative (what, not how)</li></ul><p><strong>When to use</strong>:</p><ul><li>Scale (100+ services)</li><li>Teams (coordination needed)</li><li>High availability (99.99%+)</li></ul><p><strong>When NOT to use</strong>:</p><ul><li>Small projects (overkill!)</li><li>Learning (too complex)</li><li>Personal apps (simpler alternatives exist!)</li></ul><p><strong>Modern applications</strong>:</p><ul><li><strong>Kubernetes</strong>: Enterprise scale (you are here!)</li><li><strong>Framework laptops</strong>: Personal sovereignty (Essay 9513!)</li><li><strong>Both use Unix philosophy</strong>: Modularity, composition, simplicity</li></ul><p><strong>In the Valley</strong>:</p><ul><li>We understand <strong>scale</strong> (Kubernetes handles it!)</li><li>We choose <strong>consciously</strong> (k8s for teams, simpler tools for solo)</li><li>We apply <strong>Unix principles</strong> everywhere (composition, modularity)</li></ul><p><strong>Plant lens</strong>: \"Kubernetes is large-scale agricultural coordination (managing thousands of crop rows). Simple deployments are home gardens (tend directly). Choose the right scale for your needs.\"<h2></h2></p><p><strong>Next</strong>: Continue to <strong>functional programming</strong> (Essay 9520), or explore the deep dives!</p><p><strong>Optional Deep Dives</strong> (can skip or read later):</p><ul><li><strong><a href='/12025-10/9512-unix-philosophy-deep-dive'>9512: Unix Philosophy Deep Dive</a></strong> - Verified Unix, seL4, Nock specifications!</li><li><strong><a href='/12025-10/9513-personal-sovereignty-framework-stack'>9513: Personal Sovereignty Stack</a></strong> - Framework laptops, RISC-V, complete hardware/software control!<h2></h2></li></ul><p><strong>Navigation</strong>:<br /> ← Previous: <a href='/12025-10/9510-unix-philosophy-primer'>9510 (unix philosophy primer)</a> | <strong>Phase 1 Index</strong> | Next: <a href='/12025-10/9512-unix-philosophy-deep-dive'>9512 (unix philosophy deep dive)</a></p><p><strong>Optional Deep Dives</strong>: <a href='/12025-10/9512-unix-philosophy-deep-dive'>9512 (Unix Deep)</a> | <a href='/12025-10/9513-personal-sovereignty-framework-stack'>9513 (Sovereignty Deep)</a></p><p><strong>Metadata</strong>:</p><ul><li><strong>Phase</strong>: 1 (Foundations)</li><li><strong>Week</strong>: 2</li><li><strong>Prerequisites</strong>: 9500, 9501, 9510</li><li><strong>Concepts</strong>: Kubernetes, container orchestration, pods, deployments, services, declarative infrastructure</li><li><strong>Next</strong>: Functional programming (9520), or optional deep dives (9512, 9513)</li><li><strong>Reading Time</strong>: 12 minutes (focused on k8s essentials!)</li></ul><h2></h2><p><div style=\"text-align: center; opacity: 0.6; font-size: 0.85em; margin-top: 3em; padding-top: 1em; border-top: 1px solid rgba(139, 116, 94, 0.2);\"></p><p><strong>Copyright © 2025 <a href='https://codeberg.org/kae3g/12025-10/'>kae3g</a></strong> | Dual-licensed under <a href='https://www.apache.org/licenses/LICENSE-2.0'>Apache-2.0</a> / <a href='https://opensource.org/licenses/MIT'>MIT</a><br /> Competitive technology in service of clarity and beauty</p><p></div></p><p><em><a href='/12025-10/hidden-docs-index.html'>View Hidden Docs Index</a></em> | <em><a href='/12025-10/'>Return to Main Index</a></em></p>",
  "hash" : "2025-10-22T10:21:16.801527377Z-9206"
}